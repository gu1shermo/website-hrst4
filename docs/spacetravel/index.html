<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="uniform vec2 iResolution; uniform float iTime; uniform sampler2D iChannel0; varying highp vec2 vTextureCoord; void mainImage(out vec4 fragColor, in vec2 fragCoord); void main(void) { mainImage(gl_FragColor, vTextureCoord*iResolution); } // ----------------------------------------------------------------------- // END - Common prelude // ----------------------------------------------------------------------- #define PI 3.141592654 #define TAU (2.0*PI) #define TIME iTime #define RESOLUTION iResolution #define PERIOD 30.0 #define FADE 0.0 #define SCA(a) vec2(sin(a), cos(a)) #define LESS(a,b,c) mix(a,b,step(0.,c)) #define SABS(x,k) LESS((.5/k)*x*x&#43;k*.5,abs(x),abs(x)-k) #define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a)) // Set effects below 0, 1 or 2 #define EFFECT_STRAIGHT 0 #define EFFECT_CASUAL 0 #define EFFECT_WARP 0 const mat2 rotSome = MROT(1.">
<meta name="author" content="">
<link rel="canonical" href="https://hrst4.xyz/docs/spacetravel/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://hrst4.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hrst4.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hrst4.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hrst4.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://hrst4.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="uniform vec2 iResolution; uniform float iTime; uniform sampler2D iChannel0; varying highp vec2 vTextureCoord; void mainImage(out vec4 fragColor, in vec2 fragCoord); void main(void) { mainImage(gl_FragColor, vTextureCoord*iResolution); } // ----------------------------------------------------------------------- // END - Common prelude // ----------------------------------------------------------------------- #define PI 3.141592654 #define TAU (2.0*PI) #define TIME iTime #define RESOLUTION iResolution #define PERIOD 30.0 #define FADE 0.0 #define SCA(a) vec2(sin(a), cos(a)) #define LESS(a,b,c) mix(a,b,step(0.,c)) #define SABS(x,k) LESS((.5/k)*x*x&#43;k*.5,abs(x),abs(x)-k) #define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a)) // Set effects below 0, 1 or 2 #define EFFECT_STRAIGHT 0 #define EFFECT_CASUAL 0 #define EFFECT_WARP 0 const mat2 rotSome = MROT(1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hrst4.xyz/docs/spacetravel/" /><meta property="article:section" content="docs" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="uniform vec2 iResolution; uniform float iTime; uniform sampler2D iChannel0; varying highp vec2 vTextureCoord; void mainImage(out vec4 fragColor, in vec2 fragCoord); void main(void) { mainImage(gl_FragColor, vTextureCoord*iResolution); } // ----------------------------------------------------------------------- // END - Common prelude // ----------------------------------------------------------------------- #define PI 3.141592654 #define TAU (2.0*PI) #define TIME iTime #define RESOLUTION iResolution #define PERIOD 30.0 #define FADE 0.0 #define SCA(a) vec2(sin(a), cos(a)) #define LESS(a,b,c) mix(a,b,step(0.,c)) #define SABS(x,k) LESS((.5/k)*x*x&#43;k*.5,abs(x),abs(x)-k) #define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a)) // Set effects below 0, 1 or 2 #define EFFECT_STRAIGHT 0 #define EFFECT_CASUAL 0 #define EFFECT_WARP 0 const mat2 rotSome = MROT(1."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Docs",
      "item": "https://hrst4.xyz/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://hrst4.xyz/docs/spacetravel/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "uniform vec2 iResolution; uniform float iTime; uniform sampler2D iChannel0; varying highp vec2 vTextureCoord; void mainImage(out vec4 fragColor, in vec2 fragCoord); void main(void) { mainImage(gl_FragColor, vTextureCoord*iResolution); } // ----------------------------------------------------------------------- // END - Common prelude // ----------------------------------------------------------------------- #define PI 3.141592654 #define TAU (2.0*PI) #define TIME iTime #define RESOLUTION iResolution #define PERIOD 30.0 #define FADE 0.0 #define SCA(a) vec2(sin(a), cos(a)) #define LESS(a,b,c) mix(a,b,step(0.,c)) #define SABS(x,k) LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k) #define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a)) // Set effects below 0, 1 or 2 #define EFFECT_STRAIGHT 0 #define EFFECT_CASUAL 0 #define EFFECT_WARP 0 const mat2 rotSome = MROT(1.",
  "keywords": [
    
  ],
  "articleBody": " uniform vec2 iResolution; uniform float iTime; uniform sampler2D iChannel0; varying highp vec2 vTextureCoord; void mainImage(out vec4 fragColor, in vec2 fragCoord); void main(void) { mainImage(gl_FragColor, vTextureCoord*iResolution); } // ----------------------------------------------------------------------- // END - Common prelude // ----------------------------------------------------------------------- #define PI 3.141592654 #define TAU (2.0*PI) #define TIME iTime #define RESOLUTION iResolution #define PERIOD 30.0 #define FADE 0.0 #define SCA(a) vec2(sin(a), cos(a)) #define LESS(a,b,c) mix(a,b,step(0.,c)) #define SABS(x,k) LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k) #define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a)) // Set effects below 0, 1 or 2 #define EFFECT_STRAIGHT 0 #define EFFECT_CASUAL 0 #define EFFECT_WARP 0 const mat2 rotSome = MROT(1.0); const vec3 stdGamma = vec3(2.2); float tanh(float x) { float ex = exp(x); float nex = exp(-x); float sum = ex + nex; return ex/sum - nex/sum; } vec3 hsv2rgb(vec3 c) { const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); } float hash(in float co) { return fract(sin(co*12.9898) * 13758.5453); } float hash(in vec2 co) { return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453); } float psin(float a) { return 0.5 + 0.5*sin(a); } float pcos(float a) { return 0.5 + 0.5*cos(a); } vec2 mod2_1(inout vec2 p) { vec2 c = floor(p + 0.5); p = fract(p + 0.5) - 0.5; return c; } float vnoise(vec2 x) { vec2 i = floor(x); vec2 w = fract(x); #if 1 // quintic interpolation vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0); #else // cubic interpolation vec2 u = w*w*(3.0-2.0*w); #endif float a = hash(i+vec2(0.0,0.0)); float b = hash(i+vec2(1.0,0.0)); float c = hash(i+vec2(0.0,1.0)); float d = hash(i+vec2(1.0,1.0)); float k0 = a; float k1 = b - a; float k2 = c - a; float k3 = d - c + a - b; float aa = mix(a, b, u.x); float bb = mix(c, d, u.x); float cc = mix(aa, bb, u.y); return k0 + k1*u.x + k2*u.y + k3*u.x*u.y; } vec4 alphaBlendGamma(vec4 back, vec4 front, vec3 gamma) { vec3 colb = max(back.xyz, 0.0); vec3 colf = max(front.xyz, 0.0); colb = pow(colb, gamma); colf = pow(colf, gamma); vec3 xyz = mix(colb*back.w, colf.xyz, front.w); float w = mix(back.w, 1.0, front.w); return max(vec4(pow(xyz, 1.0/gamma), w), 0.0); } vec3 alphaBlendGamma(vec3 back, vec4 front, vec3 gamma) { vec3 colb = max(back.xyz, 0.0); vec3 colf = max(front.xyz, 0.0);; colb = pow(colb, gamma); colf = pow(colf, gamma); vec3 xyz = mix(colb, colf.xyz, front.w); return pow(xyz, 1.0/gamma); } vec3 offset_0(float z) { float a = z; vec2 p = vec2(0.0); return vec3(p, z); } vec3 offset_1(float z) { const float off = 5.0; float a = 0.125*z; vec2 p = -1.0*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5)))); return vec3(p, z); } vec3 offset(int effect, float z) { if (effect == EFFECT_STRAIGHT) return offset_0(z); else if (effect == EFFECT_CASUAL) return offset_1(z); else if (effect == EFFECT_WARP) return offset_0 (z); else return offset_0 (z); } // Approximate derivate vec3 doffset(int effect, float z) { float eps = 0.1; return 0.5*(offset(effect, z + eps) - offset(effect, z - eps))/eps; } // Approximate 2nd derivate vec3 ddoffset(int effect, float z) { float eps = 0.1; return 0.125*(doffset(effect, z + eps) - doffset(effect, z - eps))/eps; } float globalCloudDensity(vec2 p, float n) { p*=0.1; float gcd = vnoise(p+10.0*hash(n)+100.0); return gcd; } float localCloudDensity(vec2 p, float n) { p*=1.0; const float aa = -0.45; const mat2 pp = 2.03*rotSome; float a = 0.5; float s = 0.0; p += 10.0*hash(n)+100.0; s += a*vnoise(p); a *= aa; p *= pp; s += a*vnoise(p); a *= aa; p *= pp; s += a*vnoise(p); a *= aa; p *= pp; s += a*vnoise(p); a *= aa; p *= pp; s += a*vnoise(p); a *= aa; p *= pp; return s*2.1-0.0; } vec4 plane(vec3 ro, vec3 rd, vec3 pp, float aa, float n) { vec2 p = pp.xy; float z = pp.z; float nz = pp.z-ro.z; float ds = 1E6; float r = 0.0; float gcd = globalCloudDensity(p, n); float s = mix(1.0, 2.0, gcd); vec2 ps = p; ps *= s; for (int i = 0; i \u003c 5; ++i) { ps *= rotSome; vec2 ips = ps; vec2 ipn = mod2_1(ips); float ir = hash(ipn+n*100.0+float(i)*10.0); ips = ips -0.3*vec2(ir, fract(-23.0*ir)); float ids = length(ips)-0.0025; if (ids \u003c ds) { r = ir; ds = min(ds, ids); } } float hues = mix(0.6, 0.8, r*r); float sats = mix(0.6, 0.0, sqrt(r)); float bris = mix(0.5, 1.0, r); float ts = pow(max(1.0-ds, 0.0), mix(200.0, 100.0, gcd)/sqrt(s)); vec3 cols = 3.0*hsv2rgb(vec3(hues, sats, bris)); vec4 cs = vec4(cols, ts); float cd = gcd*localCloudDensity(p, n); float cdo = gcd*localCloudDensity(p+vec2(0.125, 0.25), n); const float level0 = 0.0; const float level1 = 0.05; // Some serious fake shadow \u0026 lighting of clouds float cli = mix(-0.1, 1.0, 0.5 + 0.5*tanh(10.0*(cd-cdo))); float huec = (mix(-0.2, 0.05, (cd))+0.05)-0.1*pcos(2.0*pp.z); float tc = clamp(cd, 0.0, 1.0); float satc = 0.5; float bric = 1.0; vec3 colc = hsv2rgb(vec3(huec, satc, bric))+cli*0.65; vec4 cc = vec4(colc, tc); vec4 ct = alphaBlendGamma(cs, cc, stdGamma); return ct; } vec3 skyColor(vec3 ro, vec3 rd) { const vec3 l = normalize(vec3(0.0, 0.0, 1)); const vec3 baseCol = vec3(0.75, 0.75, 1.0); float diff = pow(max(dot(l, rd), 0.0), 20.0); return 1.5*baseCol*pow(max(dot(l, rd), 0.0), 20.0); } vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p, int effect, float effectTime) { float lp = length(p); vec3 rd; float planeDist; if (effect == EFFECT_WARP) { float warpf = smoothstep(FADE*2.0, PERIOD, effectTime); planeDist = mix(6.0, 0.2, warpf); rd = normalize(p.x*uu + p.y*vv + (2.0+mix(0.0, 15.0, warpf)*tanh(lp))*ww); } else { rd = normalize(p.x*uu + p.y*vv + (2.0+0.75*tanh(lp))*ww); planeDist = 3.0; } const int furthest = 6; const int fadeFrom = 4; //max((furthest - 2), 0); float nz = floor(ro.z / planeDist); vec3 skyCol = skyColor(ro, rd); vec3 col = skyCol; for (int i = furthest; i \u003e= 1 ; --i) { float pz = planeDist*nz + planeDist*float(i); float pd = (pz - ro.z)/rd.z; if (pd \u003e 0.0) { vec3 pp = ro + rd*pd; float aa = length(pp); //length(dFdy(pp)); vec4 pcol = plane(ro, rd, pp, aa, nz+float(i)); float nz = pp.z-ro.z; float fadeIn = (1.0-smoothstep(planeDist*float(fadeFrom), planeDist*float(furthest), nz)); float fadeOut = smoothstep(0.0, planeDist*0.25, nz); const float rs = 200.0; fadeIn *= rs/(rs+pd*pd); pcol.xyz = mix(skyCol, pcol.xyz, fadeIn); pcol.w *= fadeOut; col = alphaBlendGamma(col, pcol, stdGamma); } else { break; } } return col; } vec3 postProcess(vec3 col, vec2 q) { col=pow(clamp(col,0.0,1.0),vec3(0.75)); col=col*0.6+0.4*col*col*(3.0-2.0*col); col=mix(col, vec3(dot(col, vec3(0.33))), -0.4); col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7); return col; } vec3 effect(vec2 p, vec2 q) { float tm = TIME; float effectTime = mod(TIME, PERIOD); float effectPeriod = floor(TIME/PERIOD); int effect = int(mod(effectPeriod, 3.0)); if (effect == EFFECT_WARP) { tm = effectTime; } vec3 ro = offset(effect, tm); vec3 dro = doffset(effect, tm); vec3 ddro = ddoffset(effect, tm); vec3 ww = normalize(dro); vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww)); vec3 vv = normalize(cross(ww, uu)); vec3 col = color(ww, uu, vv, ro, p, effect, effectTime); col = postProcess(col, q); col *= smoothstep(0.0, FADE*FADE, effectTime); col *= smoothstep(0.0, FADE*FADE, PERIOD-effectTime); return col; } void mainImage(out vec4 fragColor, vec2 fragCoord) { vec2 q = fragCoord/RESOLUTION.xy; vec2 p = -1. + 2. * q; p.x *= RESOLUTION.x/RESOLUTION.y; vec3 col = effect(p, q); fragColor = vec4(col, 1.0); } ",
  "wordCount" : "1214",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hrst4.xyz/docs/spacetravel/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hrst4.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hrst4.xyz/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre><code>  uniform vec2 iResolution;
  uniform float iTime;
  uniform sampler2D iChannel0;

  varying highp vec2 vTextureCoord;

  void mainImage(out vec4 fragColor, in vec2 fragCoord);

  void main(void) {
    mainImage(gl_FragColor, vTextureCoord*iResolution);
  }
  // -----------------------------------------------------------------------
  // END - Common prelude
  // -----------------------------------------------------------------------

  #define PI              3.141592654
  #define TAU             (2.0*PI)
  #define TIME            iTime
  #define RESOLUTION      iResolution
  #define PERIOD          30.0
  #define FADE            0.0
  
  #define SCA(a)          vec2(sin(a), cos(a))
  #define LESS(a,b,c)     mix(a,b,step(0.,c))
  #define SABS(x,k)       LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)
  #define MROT(a)         mat2(cos(a), sin(a), -sin(a), cos(a))
  
  // Set effects below 0, 1 or 2
  #define EFFECT_STRAIGHT 0
  #define EFFECT_CASUAL   0
  #define EFFECT_WARP     0
  
  const mat2 rotSome      = MROT(1.0);
  const vec3 stdGamma     = vec3(2.2);

  float tanh(float x)
{
  float ex = exp(x);
  float nex = exp(-x);
  float sum = ex + nex;
  return ex/sum - nex/sum;
}
  
  vec3 hsv2rgb(vec3 c) {
    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
  }
  
  float hash(in float co) {
    return fract(sin(co*12.9898) * 13758.5453);
  }
  
  float hash(in vec2 co) {
    return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);
  }
  
  float psin(float a) {
    return 0.5 + 0.5*sin(a);
  }
  
  float pcos(float a) {
    return 0.5 + 0.5*cos(a);
  }
  
  vec2 mod2_1(inout vec2 p) {
    vec2 c = floor(p + 0.5);
    p = fract(p + 0.5) - 0.5;
    return c;
  }
  
  float vnoise(vec2 x) {
    vec2 i = floor(x);
    vec2 w = fract(x);
      
  #if 1
    // quintic interpolation
    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);
  #else
    // cubic interpolation
    vec2 u = w*w*(3.0-2.0*w);
  #endif    
  
    float a = hash(i+vec2(0.0,0.0));
    float b = hash(i+vec2(1.0,0.0));
    float c = hash(i+vec2(0.0,1.0));
    float d = hash(i+vec2(1.0,1.0));
      
    float k0 =   a;
    float k1 =   b - a;
    float k2 =   c - a;
    float k3 =   d - c + a - b;
  
    float aa = mix(a, b, u.x);
    float bb = mix(c, d, u.x);
    float cc = mix(aa, bb, u.y);
    
    return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;
  }
  
  vec4 alphaBlendGamma(vec4 back, vec4 front, vec3 gamma) {
    vec3 colb = max(back.xyz, 0.0);
    vec3 colf = max(front.xyz, 0.0);
    colb = pow(colb, gamma);
    colf = pow(colf, gamma);
    vec3 xyz = mix(colb*back.w, colf.xyz, front.w);
    float w = mix(back.w, 1.0, front.w);
    return max(vec4(pow(xyz, 1.0/gamma), w), 0.0);
  }
  
  vec3 alphaBlendGamma(vec3 back, vec4 front, vec3 gamma) {
    vec3 colb = max(back.xyz, 0.0);
    vec3 colf = max(front.xyz, 0.0);;
    
    colb = pow(colb, gamma);
    colf = pow(colf, gamma);
    vec3 xyz = mix(colb, colf.xyz, front.w);
    return pow(xyz, 1.0/gamma);
  }
  
  vec3 offset_0(float z) {
    float a = z;
    vec2 p = vec2(0.0);
    return vec3(p, z);
  }
  
  vec3 offset_1(float z) {
    const float off = 5.0;
    float a = 0.125*z;
    vec2 p = -1.0*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));
    return vec3(p, z);
  }
  
  vec3 offset(int effect, float z) {
    if (effect == EFFECT_STRAIGHT)    return offset_0(z);
    else if (effect == EFFECT_CASUAL) return offset_1(z);
    else if (effect == EFFECT_WARP)   return offset_0 (z);
    else                              return offset_0 (z);
  }
  
  // Approximate derivate
  vec3 doffset(int effect, float z) {
    float eps = 0.1;
    return 0.5*(offset(effect, z + eps) - offset(effect, z - eps))/eps;
  }
  
  // Approximate 2nd derivate
  vec3 ddoffset(int effect, float z) {
    float eps = 0.1;
    return 0.125*(doffset(effect, z + eps) - doffset(effect, z - eps))/eps;
  }
  
  float globalCloudDensity(vec2 p, float n) {
    p*=0.1;
    float gcd = vnoise(p+10.0*hash(n)+100.0);
    return gcd;
  }
  
  float localCloudDensity(vec2 p, float n) {
    p*=1.0;
    const float aa = -0.45;
    const mat2 pp = 2.03*rotSome;
    float a = 0.5;
    float s = 0.0;
    p += 10.0*hash(n)+100.0;
  
    s += a*vnoise(p); a *= aa; p *= pp;
    s += a*vnoise(p); a *= aa; p *= pp;
    s += a*vnoise(p); a *= aa; p *= pp;
    s += a*vnoise(p); a *= aa; p *= pp;
    s += a*vnoise(p); a *= aa; p *= pp;
    return s*2.1-0.0;
  }
  
  vec4 plane(vec3 ro, vec3 rd, vec3 pp, float aa, float n) {
    vec2 p = pp.xy;
    float z = pp.z;
    float nz = pp.z-ro.z;
  
    float ds = 1E6;
    float r = 0.0;
  
    float gcd = globalCloudDensity(p, n);
  
    float s = mix(1.0, 2.0, gcd);
    vec2 ps = p;
    ps *= s;
    for (int i = 0; i &lt; 5; ++i) {
      ps *= rotSome;
      vec2 ips = ps;
      vec2 ipn = mod2_1(ips);
      float ir = hash(ipn+n*100.0+float(i)*10.0);
      ips = ips -0.3*vec2(ir, fract(-23.0*ir));
      float ids = length(ips)-0.0025;
      if (ids &lt; ds) {
        r = ir;
        ds = min(ds, ids);
      }
    }
  
    float hues = mix(0.6, 0.8, r*r);
    float sats = mix(0.6, 0.0, sqrt(r));
    float bris = mix(0.5, 1.0, r);
    float ts = pow(max(1.0-ds, 0.0), mix(200.0, 100.0, gcd)/sqrt(s));
    vec3 cols = 3.0*hsv2rgb(vec3(hues, sats, bris));
    vec4 cs = vec4(cols, ts);
  
    float cd = gcd*localCloudDensity(p, n);
    float cdo = gcd*localCloudDensity(p+vec2(0.125, 0.25), n);
    const float level0 = 0.0;
    const float level1 = 0.05;
    // Some serious fake shadow &amp; lighting of clouds
    float cli = mix(-0.1, 1.0, 0.5 + 0.5*tanh(10.0*(cd-cdo)));
  
    float huec = (mix(-0.2, 0.05, (cd))+0.05)-0.1*pcos(2.0*pp.z);
    float tc = clamp(cd, 0.0, 1.0);
    float satc = 0.5;
    float bric = 1.0;
    vec3 colc = hsv2rgb(vec3(huec, satc, bric))+cli*0.65;
    vec4 cc = vec4(colc, tc);
    
    vec4 ct = alphaBlendGamma(cs, cc, stdGamma);
    return ct;
  }
  
  vec3 skyColor(vec3 ro, vec3 rd) {
    const vec3 l = normalize(vec3(0.0, 0.0, 1));
    const vec3 baseCol = vec3(0.75, 0.75, 1.0);
    float diff = pow(max(dot(l, rd), 0.0), 20.0);  
    return 1.5*baseCol*pow(max(dot(l, rd), 0.0), 20.0);
  }
  
  vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p, int effect, float effectTime) {
    float lp = length(p);
  
    vec3 rd;
    float planeDist;
    
    if (effect == EFFECT_WARP) {
        float warpf = smoothstep(FADE*2.0, PERIOD, effectTime);
        planeDist = mix(6.0, 0.2, warpf);
        rd = normalize(p.x*uu + p.y*vv + (2.0+mix(0.0, 15.0, warpf)*tanh(lp))*ww);
    } else {
        rd = normalize(p.x*uu + p.y*vv + (2.0+0.75*tanh(lp))*ww);
        planeDist = 3.0;
    }
    
    const int furthest = 6;
    const int fadeFrom = 4; //max((furthest - 2), 0);
  
    float nz = floor(ro.z / planeDist);
  
    vec3 skyCol = skyColor(ro, rd);  
    
    vec3 col = skyCol;
  
    for (int i = furthest; i &gt;= 1 ; --i) {
      float pz = planeDist*nz + planeDist*float(i);
      
      float pd = (pz - ro.z)/rd.z;
      
      if (pd &gt; 0.0) {
        vec3 pp = ro + rd*pd;
     
        float aa = length(pp); //length(dFdy(pp));
  
        vec4 pcol = plane(ro, rd, pp, aa, nz+float(i));
        float nz = pp.z-ro.z;
        float fadeIn = (1.0-smoothstep(planeDist*float(fadeFrom), planeDist*float(furthest), nz));
        float fadeOut = smoothstep(0.0, planeDist*0.25, nz);
        const float rs = 200.0;
        fadeIn *= rs/(rs+pd*pd);
        pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);
        pcol.w *= fadeOut;
  
        col = alphaBlendGamma(col, pcol, stdGamma);
      } else {
        break;
      }
      
    }
    
    return col;
  }
  
  vec3 postProcess(vec3 col, vec2 q)  {
    col=pow(clamp(col,0.0,1.0),vec3(0.75)); 
    col=col*0.6+0.4*col*col*(3.0-2.0*col);
    col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);
    col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);
    return col;
  }
  
  vec3 effect(vec2 p, vec2 q) {
    float tm = TIME;
    
    float effectTime   = mod(TIME, PERIOD);
    float effectPeriod = floor(TIME/PERIOD);
    
    int effect = int(mod(effectPeriod, 3.0));
    if (effect == EFFECT_WARP) {
      tm = effectTime;
    }
    vec3 ro    = offset(effect, tm);
    vec3 dro   = doffset(effect, tm);
    vec3 ddro  = ddoffset(effect, tm);
  
    vec3 ww = normalize(dro);
    vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));
    vec3 vv = normalize(cross(ww, uu));
    
    vec3 col = color(ww, uu, vv, ro, p, effect, effectTime);
    col = postProcess(col, q);
    
    col *= smoothstep(0.0, FADE*FADE, effectTime);
    col *= smoothstep(0.0, FADE*FADE, PERIOD-effectTime);
    
    return col;
  }
  
  void mainImage(out vec4 fragColor, vec2 fragCoord) {
    vec2 q = fragCoord/RESOLUTION.xy;
    vec2 p = -1. + 2. * q;
    p.x *= RESOLUTION.x/RESOLUTION.y;
    
    vec3 col = effect(p, q);
    
    fragColor = vec4(col, 1.0);
  }
&lt;/script&gt;

&lt;script id=&quot;shader-vs&quot; type=&quot;x-shader/x-vertex&quot;&gt;
  attribute highp vec3 aVertexPosition;
  attribute highp vec3 aVertexNormal;
  attribute highp vec2 aTextureCoord;

  varying highp vec2 vTextureCoord;
  varying highp vec3 vNormal;

  void main(void) {
    gl_Position   = vec4(aVertexPosition, 1.0);
    vNormal = aVertexNormal;
    vTextureCoord = aTextureCoord;
  }
&lt;/script&gt;
</code></pre>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hrst4.xyz/">My New Hugo Site</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
