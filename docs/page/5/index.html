<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>hrst4&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="docs _index.md ">
<meta name="author" content="">
<link rel="canonical" href="https://hrst4.xyz/docs/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://hrst4.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hrst4.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hrst4.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hrst4.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://hrst4.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://hrst4.xyz/docs/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hrst4.xyz/docs/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "",
      "item": "https://hrst4.xyz/docs/"
    }
  ]
}
</script>
</head>

<body class="list dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hrst4.xyz/" accesskey="h" title="hrst4&#39;s blog (Alt + H)">hrst4&#39;s blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://hrst4.xyz/apropos" title="apropos">
                    <span>apropos</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<div class="post-content"><h1 id="docs-_indexmd">docs _index.md<a hidden class="anchor" aria-hidden="true" href="#docs-_indexmd">#</a></h1>


</div>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>
    </h2>
  </header>
  <div class="entry-content">
    <p>Le mapping parallaxe Le mapping parallaxe est une technique similaire au normal mapping, mais basé sur des principes différents. Tout comme le normal mapping, il s’agit d’une technique qui augmente considérablement les détails d’une surface texturée et lui donne une impression de profondeur. Bien qu’il s’agisse également d’une illusion, le parallaxe mapping est beaucoup plus efficace pour donner une impression de profondeur et, combinée au normal mapping, il donne des résultats incroyablement réalistes....</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/04_parallax_mapping/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>
    </h2>
  </header>
  <div class="entry-content">
    <p>HDR Les valeurs de luminosité et de couleur sont, par défaut, comprises entre $0.0$ et $1.0$ lorsqu’elles sont stockées dans un framebuffer. Cette déclaration, à première vue innocente, nous a poussés à toujours spécifier les valeurs de luminosité et de couleur quelque part dans cette fourchette, en essayant de les faire correspondre à la scène. Cela fonctionne bien et donne des résultats corrects, mais que se passe-t-il si nous marchons dans une zone très lumineuse avec plusieurs sources lumineuses dont la somme totale dépasse $1....</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/05_hdr/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>
    </h2>
  </header>
  <div class="entry-content">
    <p>Bloom Les sources lumineuses vives et les régions très éclairées sont souvent difficiles à faire comprendre à l’observateur, car la plage d’intensité d’un moniteur est limitée. L’un des moyens de distinguer les sources lumineuses vives sur un moniteur consiste à les faire briller ; la lumière s’étend alors autour de la source lumineuse. Cela donne au spectateur l’illusion que ces sources lumineuses ou ces zones lumineuses sont intensément lumineuses.
Cet effet de brillance/lueur (bleeding) est obtenu grâce à un effet de post-traitement appelé Bloom....</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/06_bloom/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>
    </h2>
  </header>
  <div class="entry-content">
    <p>Ombrage différé La méthode d’éclairage utilisée jusqu’à présent s’appelait “forward rendering” ou “forward shading”. Il s’agit d’une approche simple qui consiste à effectuer le rendu d’un objet et à l’éclairer en fonction de toutes les sources lumineuses de la scène. Nous faisons cela pour chaque objet individuellement pour chaque objet de la scène. Bien qu’elle soit facile à comprendre et à mettre en œuvre, cette approche est également très coûteuse en termes de performances, car chaque objet rendu doit itérer sur chaque source de lumière pour chaque fragment rendu, ce qui est beaucoup !...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/07_deferred_shading/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>
    </h2>
  </header>
  <div class="entry-content">
    <p>SSAO Nous avons brièvement abordé le sujet dans le chapitre sur l’éclairage de base : l’éclairage ambiant. L’éclairage ambiant est une constante lumineuse fixe que nous ajoutons à l’éclairage global d’une scène pour simuler la diffusion de la lumière. En réalité, la lumière se disperse dans toutes sortes de directions avec des intensités variables, de sorte que les parties indirectement éclairées d’une scène doivent également présenter des intensités variables. L’un des types d’approximation de l’éclairage indirect est appelé occlusion ambiante....</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/08_ssao/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>
    </h2>
  </header>
  <div class="entry-content">
    <p>Théorie Le PBR, ou plus communément appelé rendu basé sur la physique (physically based renderer), est un ensemble de techniques de rendu plus ou moins basées sur la même théorie sous-jacente qui correspond plus étroitement à celle du monde physique. Comme le rendu basé sur la physique vise à imiter la lumière d’une manière physiquement plausible, il semble généralement plus réaliste que nos algorithmes d’éclairage originaux tels que Phong et Blinn-Phong....</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://hrst4.xyz/docs/learnopengl_fr/06_pbr/01_theory/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>
    </h2>
  </header>
  <div class="entry-content">
    <p>Lighting Dans le chapitre précédent, nous avons jeté les bases d’un moteur de rendu réaliste basé sur la physique. Dans ce chapitre, nous allons nous concentrer sur la traduction de la théorie discutée précédemment en un moteur de rendu réel qui utilise des sources de lumière directes (ou analytiques) : pensez aux lumières ponctuelles, aux lumières directionnelles et/ou aux projecteurs.
Commençons par revoir l’équation de réflectance finale du chapitre précédent : $$ L_0(p,w_0) \int_{\Omega} ( k_d {c\over \pi} &#43; { DFG \over 4(w_0 *n)(w_i * n) } L_i(p,w_i)n * w_idw_i ) $$...</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://hrst4.xyz/docs/learnopengl_fr/06_pbr/02_lighting/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>
    </h2>
  </header>
  <div class="entry-content">
    <p>Rayonnement diffus L’IBL, ou éclairage basé sur l’image, est un ensemble de techniques permettant d’éclairer des objets, non pas par des lumières analytiques directes comme dans le chapitre précédent, mais en traitant l’environnement comme une grande source de lumière. Ceci est généralement réalisé en manipulant une map d’environnement cubemap (prise dans le monde réel ou générée à partir d’une scène 3D) de telle sorte que nous puissions l’utiliser directement dans nos équations d’éclairage : en traitant chaque texel cubemap comme un émetteur de lumière....</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://hrst4.xyz/docs/learnopengl_fr/06_pbr/03_ibl/01_diffuse_irradiance/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>
    </h2>
  </header>
  <div class="entry-content">
    <p>*# IBL Spéculaire Dans le chapitre précédent, nous avons mis en place le PBR en combinaison avec l’éclairage basé sur l’image en pré-calculant une map d’irradiance comme partie diffuse indirecte de l’éclairage. Dans ce chapitre, nous allons nous concentrer sur la partie spéculaire de l’équation de réflectance : $$ L_o(p,w_o) = \int_{\Omega} ( k_d { c \over \pi } k_s { DFG \over 4(w_on)(w_in) } L_i(p,w_i)n*w_idw_i ) $$ Vous remarquerez que la partie spéculaire de Cook-Torrance (multipliée par $k_S$) n’est pas constante sur l’intégrale et dépend de la direction de la lumière entrante, mais aussi de la direction de la vue entrante....</p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="https://hrst4.xyz/docs/learnopengl_fr/06_pbr/03_ibl/02_specular_ibl/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://hrst4.xyz/docs/page/4/">
      «&nbsp;Prev&nbsp;
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hrst4.xyz/">hrst4&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
