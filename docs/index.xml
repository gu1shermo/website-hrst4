<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hrst4&#39;s blog</title>
    <link>https://hrst4.xyz/docs/</link>
    <description>Recent content on hrst4&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 11 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://hrst4.xyz/docs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>src_post</title>
      <link>https://hrst4.xyz/docs/src_post/</link>
      <pubDate>Sat, 11 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/src_post/</guid>
      <description>modif04
where-does-it-come-froms Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through the cites of the word in classical literature, discovered the undoubtable source.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/another_post/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/another_post/</guid>
      <description>Another post </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/</guid>
      <description>00_Introduction
introduction 01_Getting_Started
00_opengl
01_creating a window
02_hello window
03_hello triangle
04_shaders
05_textures
06_transformations
07_coordinate systems
08_camera
09_glossary
img
video
02_Lighting
00_Colors colors 01_Basic Lighting basic lighting 02_Materials materials 03_Lighting Maps lighting maps 04_Light Casters light casters 05_Multiple Lights multiple lights glossary 03_Model_Loading
assimp mesh model 04_Advanced_OpenGL
00_depth_testing 01_stencil_testing 02_blending 03_face_culling 04_framebuffers 05_cubemaps 06_advanced_data 07_advanced_glsl 08_geometry_shader 09_instancing 10_anti_aliasing 05_Advanced_Lighting
00_advanced_lighting 01_gamma_correction 02a_shadow_mapping 02b_point_shadows 03_normal_mapping 04_parallax_mapping 05_hdr 06_bloom 07_deferred_shading 08_ssao 06_PBR</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/00_introduction/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/00_introduction/introduction/</guid>
      <description>Introduction Depuis que vous êtes arrivé ici, vous voulez probablement apprendre les rouages de l&amp;rsquo;infographie et faire tous les trucs que les jeunes cool font par eux-mêmes. Faire les choses par soi-même est extrêmement amusant et plein de ressources, et cela vous permet d&amp;rsquo;acquérir une excellente compréhension de la programmation graphique. Cependant, il y a quelques points à prendre en considération avant de commencer votre voyage.
Prérequis Comme OpenGL est une API graphique et non une plateforme propre, il nécessite un langage pour fonctionner et le langage de choix est le C++.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/00_opengl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/00_opengl/</guid>
      <description>OpenGL Avant de commencer notre voyage, nous devons d&amp;rsquo;abord définir ce qu&amp;rsquo;est OpenGL. OpenGL est principalement considéré comme une API (une interface de programmation d&amp;rsquo;applications) qui nous fournit un large ensemble de fonctions que nous pouvons utiliser pour manipuler les graphiques et les images. Cependant, OpenGL en lui-même n&amp;rsquo;est pas une API, mais simplement une spécification, développée et maintenue par le groupe Khronos.
La spécification OpenGL précise exactement le résultat/la sortie de chaque fonction et la manière dont elle doit fonctionner.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/01_creating-a-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/01_creating-a-window/</guid>
      <description>Créer une fenêtre La première chose à faire avant de commencer à créer des graphiques étonnants est de créer un contexte OpenGL et une fenêtre d&amp;rsquo;application pour dessiner. Cependant, ces opérations sont spécifiques à chaque système d&amp;rsquo;exploitation et OpenGL essaie délibérément de s&amp;rsquo;abstraire de ces opérations. Cela signifie que nous devons créer une fenêtre, définir un contexte et gérer l&amp;rsquo;entrée de l&amp;rsquo;utilisateur par nous-mêmes.
Heureusement, il existe de nombreuses bibliothèques qui fournissent les fonctionnalités que nous recherchons, dont certaines sont spécifiquement destinées à OpenGL.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/02_hello-window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/02_hello-window/</guid>
      <description>Hello Window Voyons si nous pouvons faire fonctionner GLFW. Tout d&amp;rsquo;abord, créez un fichier .cpp et ajoutez les inclusions suivantes au début de votre fichier nouvellement créé.
#include &amp;lt;glad/glad.h&amp;gt; #include &amp;lt;GLFW/glfw3.h&amp;gt; Assurez-vous d&amp;rsquo;inclure GLAD avant GLFW. Le fichier include de GLAD inclut les en-têtes OpenGL nécessaires dans les coulisses (comme GL/gl.h). Il faut donc s&amp;rsquo;assurer d&amp;rsquo;inclure GLAD avant les autres fichiers d&amp;rsquo;en-tête qui nécessitent OpenGL (comme GLFW).
Ensuite, nous créons la fonction principale dans laquelle nous allons instancier la fenêtre GLFW:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/03_hello-triangle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/03_hello-triangle/</guid>
      <description>Hello Dans OpenGL, tout est dans l&amp;rsquo;espace 3D, mais l&amp;rsquo;écran ou la fenêtre est un tableau de pixels 2D. Une grande partie du travail d&amp;rsquo;OpenGL consiste donc à transformer toutes les coordonnées 3D en pixels 2D qui tiennent sur l&amp;rsquo;écran. Le processus de transformation des coordonnées 3D en pixels 2D est géré par le pipeline graphique d&amp;rsquo;OpenGL. Le pipeline graphique peut être divisé en deux grandes parties : la première transforme vos coordonnées 3D en coordonnées 2D et la seconde transforme les coordonnées 2D en pixels colorés.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/04_shaders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/04_shaders/</guid>
      <description>Shaders Comme mentionné dans le chapitre 03_hello triangle, les shaders sont de petits programmes qui reposent sur le GPU. Ces programmes sont exécutés pour chaque section spécifique du pipeline graphique. En gros, les shaders ne sont rien d&amp;rsquo;autre que des programmes qui transforment les entrées en sorties. Les shaders sont également des programmes très isolés dans la mesure où ils ne sont pas autorisés à communiquer entre eux ; la seule communication qu&amp;rsquo;ils ont se fait par le biais de leurs entrées et sorties.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/05_textures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/05_textures/</guid>
      <description>Textures Nous avons appris que pour ajouter plus de détails à nos objets, nous pouvons utiliser des couleurs pour chaque sommet afin de créer des images intéressantes. Cependant, pour obtenir un certain réalisme, nous devons avoir beaucoup de sommets afin de pouvoir spécifier un grand nombre de couleurs. Cela représente un surcoût considérable, car chaque modèle nécessite beaucoup plus de sommets et, pour chacun d&amp;rsquo;eux, un attribut de couleur.
Les artistes et les programmeurs préfèrent généralement utiliser une texture.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/06_transformations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/06_transformations/</guid>
      <description>Transformations Nous savons maintenant comment créer des objets, les colorer et/ou leur donner une apparence détaillée à l&amp;rsquo;aide de textures, mais ils ne sont toujours pas très intéressants puisqu&amp;rsquo;il s&amp;rsquo;agit d&amp;rsquo;objets statiques. Nous pourrions essayer de les faire bouger en changeant leurs sommets et en reconfigurant leurs buffers à chaque image, mais c&amp;rsquo;est lourd et coûteux en puissance de traitement. Il existe de bien meilleures façons de transformer un objet, et c&amp;rsquo;est en utilisant des objets matriciels (multiples).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/07_coordinate-systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/07_coordinate-systems/</guid>
      <description>Systèmes de coordonnées Dans le dernier chapitre, nous avons appris comment utiliser les matrices à notre avantage en transformant tous les sommets avec des matrices de transformation. OpenGL s&amp;rsquo;attend à ce que tous les sommets, que nous voulons rendre visibles, soient en coordonnées normalisées après chaque exécution du vertex shader. C&amp;rsquo;est-à-dire que les coordonnées $x$, $y$ et $z$ de chaque sommet doivent être comprises entre $-1.0$ et $1.0$ ; les coordonnées en dehors de cette plage ne seront pas visibles.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/08_camera/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/08_camera/</guid>
      <description>Camera Dans le chapitre précédent, nous avons discuté de la matrice de vue et de la façon dont nous pouvons l&amp;rsquo;utiliser pour nous déplacer dans la scène (nous avons un peu reculé). OpenGL n&amp;rsquo;est pas familier avec le concept de caméra, mais nous pouvons essayer d&amp;rsquo;en simuler une en déplaçant tous les objets de la scène dans le sens inverse, donnant l&amp;rsquo;illusion que nous nous déplaçons.
Dans ce chapitre, nous verrons comment mettre en place une caméra dans OpenGL.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/09_glossary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/09_glossary/</guid>
      <description>Glossaire OpenGL : une spécification formelle d&amp;rsquo;une API graphique qui définit la disposition et la sortie de chaque fonction. GLAD : une bibliothèque de chargement d&amp;rsquo;extension qui charge et définit tous les pointeurs de fonction d&amp;rsquo;OpenGL pour nous afin que nous puissions utiliser toutes les fonctions (modernes) d&amp;rsquo;OpenGL. Viewport : la région de la fenêtre 2D dans laquelle nous effectuons le rendu. Graphics Pipeline : le processus complet par lequel les vertices doivent passer avant de se retrouver sous la forme d&amp;rsquo;un ou plusieurs pixels sur l&amp;rsquo;écran.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/00_colors/colors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/00_colors/colors/</guid>
      <description>Couleurs Nous avons brièvement utilisé et manipulé les couleurs dans les chapitres précédents, mais nous ne les avons jamais définies correctement. Nous allons ici discuter de ce que sont les couleurs et commencer à construire la scène pour les prochains chapitres sur l&amp;rsquo;éclairage.
Dans le monde réel, les couleurs peuvent prendre n&amp;rsquo;importe quelle valeur connue, chaque objet ayant sa propre couleur. Dans le monde numérique, nous devons convertir les couleurs réelles (infinies) en valeurs numériques (limitées) et, par conséquent, toutes les couleurs du monde réel ne peuvent pas être représentées numériquement.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/01_basic-lighting/basic-lighting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/01_basic-lighting/basic-lighting/</guid>
      <description>Basic lighting L&amp;rsquo;éclairage dans le monde réel est extrêmement compliqué et dépend de beaucoup trop de facteurs, ce que nous ne pouvons pas nous permettre de calculer avec la puissance de traitement limitée dont nous disposons. L&amp;rsquo;éclairage dans OpenGL est donc basé sur des approximations de la réalité en utilisant des modèles simplifiés qui sont beaucoup plus faciles à traiter et relativement similaires. Ces modèles d&amp;rsquo;éclairage sont basés sur la physique de la lumière telle que nous la comprenons.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/02_materials/materials/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/02_materials/materials/</guid>
      <description>Materials Dans le monde réel, chaque objet a une réaction différente à la lumière. Les objets en acier sont souvent plus brillants qu&amp;rsquo;un vase en argile, par exemple, et un récipient en bois ne réagit pas de la même manière à la lumière qu&amp;rsquo;un récipient en acier. Certains objets reflètent la lumière sans trop se disperser, ce qui donne de petits reflets spéculaires, tandis que d&amp;rsquo;autres se dispersent beaucoup, ce qui donne un plus grand rayon au reflet.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/03_lighting-maps/lighting-maps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/03_lighting-maps/lighting-maps/</guid>
      <description>Lighting Maps Dans le chapitre précédent, nous avons évoqué la possibilité de doter chaque objet d&amp;rsquo;un matériau unique qui réagit différemment à la lumière. Cela permet de donner à chaque objet un aspect unique par rapport aux autres objets, mais n&amp;rsquo;offre pas encore beaucoup de flexibilité sur le rendu visuel d&amp;rsquo;un objet.
Dans le chapitre précédent, nous avons défini un matériau pour l&amp;rsquo;ensemble d&amp;rsquo;un objet. Cependant, dans le monde réel, les objets ne sont généralement pas constitués d&amp;rsquo;un seul matériau, mais de plusieurs matériaux.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/04_light-casters/light-casters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/04_light-casters/light-casters/</guid>
      <description>Projecteurs de lumière Tous les éclairages que nous avons utilisés jusqu&amp;rsquo;à présent provenaient d&amp;rsquo;une source unique, c&amp;rsquo;est-à-dire d&amp;rsquo;un seul point dans l&amp;rsquo;espace. Cela donne de bons résultats, mais dans le monde réel, nous avons plusieurs types de lumière qui agissent chacun différemment. Une source de lumière qui projette de la lumière sur des objets est appelée un projecteur de lumière (light caster). Dans ce chapitre, nous aborderons plusieurs types de projecteurs de lumière.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/05_multiple-lights/multiple-lights/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/05_multiple-lights/multiple-lights/</guid>
      <description>Plusieurs lumières Dans les chapitres précédents, nous avons beaucoup appris sur l&amp;rsquo;éclairage en OpenGL. Nous avons découvert l&amp;rsquo;ombrage Phong (Phong shading), les matériaux, les maps d&amp;rsquo;éclairage et les différents types de projecteurs de lumière. Dans ce chapitre, nous allons combiner toutes les connaissances acquises précédemment en créant une scène entièrement éclairée avec 6 sources de lumière actives. Nous allons simuler une lumière semblable à celle du soleil comme source de lumière directionnelle, 4 lumières ponctuelles dispersées dans la scène et nous ajouterons également une lampe de poche.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/glossary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/02_lighting/glossary/</guid>
      <description>Glossaire Vecteur de couleur : un vecteur représentant la plupart des couleurs du monde réel par une combinaison des composantes rouge, verte et bleue (abrégé en RGB). La couleur d&amp;rsquo;un objet est la composante de couleur réfléchie que l&amp;rsquo;objet n&amp;rsquo;a pas absorbée. Modèle d&amp;rsquo;éclairage Phong : modèle d&amp;rsquo;approximation de l&amp;rsquo;éclairage du monde réel par le calcul d&amp;rsquo;une composante ambiante, diffuse et spéculaire. Éclairage ambiant : approximation de l&amp;rsquo;éclairage global en donnant à chaque objet une petite luminosité afin que les objets ne soient pas complètement sombres s&amp;rsquo;ils ne sont pas directement éclairés.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/03_model_loading/assimp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/03_model_loading/assimp/</guid>
      <description>Assimp Dans toutes les scènes présentées jusqu&amp;rsquo;à présent, nous avons beaucoup joué avec notre petit ami le conteneur, mais avec le temps, même nos meilleurs amis peuvent devenir un peu ennuyeux. Dans les applications graphiques plus importantes, il y a généralement beaucoup de modèles compliqués et intéressants qui sont beaucoup plus jolis à regarder qu&amp;rsquo;un conteneur statique. Cependant, contrairement à l&amp;rsquo;objet conteneur, nous ne pouvons pas vraiment définir manuellement tous les sommets, les normales et les coordonnées de texture de formes compliquées telles que des maisons, des véhicules ou des personnages humains.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/03_model_loading/mesh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/03_model_loading/mesh/</guid>
      <description>Mesh Avec Assimp, nous pouvons charger de nombreux modèles différents dans l&amp;rsquo;application, mais une fois chargés, ils sont tous stockés dans les structures de données d&amp;rsquo;Assimp. Ce que nous voulons finalement, c&amp;rsquo;est transformer ces données dans un format qu&amp;rsquo;OpenGL comprend afin que nous puissions effectuer le rendu des objets. Nous avons appris dans le chapitre précédent qu&amp;rsquo;un mesh représente une seule entité dessinable, alors commençons par définir notre propre classe de mesh.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/03_model_loading/model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/03_model_loading/model/</guid>
      <description>Modèle Il est maintenant temps de mettre la main à la pâte avec Assimp et de commencer à créer le code de chargement et de traduction. L&amp;rsquo;objectif de ce chapitre est de créer une autre classe qui représente un modèle dans son intégralité, c&amp;rsquo;est-à-dire un modèle qui contient plusieurs meshes, éventuellement avec plusieurs textures. Une maison qui contient un balcon en bois, une tour et peut-être une piscine peut être chargée comme un seul modèle.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/00_depth_testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/00_depth_testing/</guid>
      <description>Test de profondeur (depth testing) Dans le chapitre sur les systèmes de coordonnées , nous avons effectué le rendu d&amp;rsquo;un conteneur 3D et utilisé un tampon de profondeur (depth buffer) pour éviter que des triangles ne soient rendus à l&amp;rsquo;avant alors qu&amp;rsquo;ils sont censés se trouver derrière d&amp;rsquo;autres triangles. Dans ce chapitre, nous allons développer un peu plus les valeurs de profondeur que le tampon de profondeur (ou tampon z : z-buffer) stocke et la manière dont il détermine si un fragment est à l&amp;rsquo;avant.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/01_stencil_testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/01_stencil_testing/</guid>
      <description>Stencil testing Une fois que le shader de fragment a traité le fragment, un test de stencil est exécuté qui, tout comme le test de profondeur, a la possibilité d&amp;rsquo;éliminer des fragments. Après cela, les fragments restants sont transmis au test de profondeur où OpenGL peut éventuellement rejeter encore plus de fragments. Le test de stencil (pochoir en français?) est basé sur le contenu d&amp;rsquo;un autre tampon appelé tampon de stencil que nous sommes autorisés à mettre à jour pendant le rendu pour obtenir des effets intéressants.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/02_blending/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/02_blending/</guid>
      <description>Blending (transparence/blending) Le blending dans OpenGL est communément connu comme la technique pour implémenter la transparence dans les objets. La transparence consiste à ce que les objets (ou des parties d&amp;rsquo;objets) n&amp;rsquo;aient pas une couleur unie, mais une combinaison de couleurs provenant de l&amp;rsquo;objet lui-même et de tout autre objet situé derrière lui, avec une intensité variable. Une fenêtre en verre coloré est un objet transparent ; le verre a sa propre couleur, mais la couleur résultante contient également les couleurs de tous les objets situés derrière le verre.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/03_face_culling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/03_face_culling/</guid>
      <description>Face culling Essayez de visualiser mentalement un cube en 3D et comptez le nombre maximum de faces que vous pourrez voir dans n&amp;rsquo;importe quelle direction. Si votre imagination n&amp;rsquo;est pas trop créative, vous avez probablement abouti à un nombre maximal de 3. Vous pouvez voir un cube dans n&amp;rsquo;importe quelle position et/ou direction, mais vous ne pourrez jamais voir plus de 3 faces. Alors pourquoi gaspiller l&amp;rsquo;effort de dessiner ces 3 autres faces que nous ne pouvons même pas voir.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/04_framebuffers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/04_framebuffers/</guid>
      <description>Framebuffers Jusqu&amp;rsquo;à présent, nous avons utilisé plusieurs types de tampons d&amp;rsquo;écran (screen buffers) : un tampon de couleur pour écrire les valeurs de couleur, un tampon de profondeur pour écrire et tester les informations de profondeur, et enfin un tampon de stencil qui nous permet d&amp;rsquo;écarter certains fragments en fonction d&amp;rsquo;une certaine condition. La combinaison de ces tampons est stockée quelque part dans la mémoire du GPU et est appelée framebuffer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/05_cubemaps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/05_cubemaps/</guid>
      <description>Cubemaps Nous utilisons des textures 2D depuis un certain temps, mais il existe d&amp;rsquo;autres types de textures que nous n&amp;rsquo;avons pas encore explorés. Dans ce chapitre, nous aborderons un type de texture qui est une combinaison de plusieurs textures mappées en une seule : une cubemap.
Une cubemap est une texture qui contient 6 textures 2D individuelles qui forment chacune un côté d&amp;rsquo;un cube : un cube texturé. Vous vous demandez peut-être quel est l&amp;rsquo;intérêt d&amp;rsquo;un tel cube ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/06_advanced_data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/06_advanced_data/</guid>
      <description>Data avancée Dans la plupart des chapitres, nous avons largement utilisé les tampons dans OpenGL pour stocker des données sur le GPU. Dans ce chapitre, nous discuterons brièvement de quelques approches alternatives pour gérer les tampons.
Un tampon dans OpenGL est, à la base, un objet qui gère une partie de la mémoire du GPU et rien de plus. Nous donnons un sens à un tampon en le liant à une cible spécifique.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/07_advanced_glsl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/07_advanced_glsl/</guid>
      <description>GLSL avancé Ce chapitre ne vous montrera pas vraiment de nouvelles fonctionnalités super avancées qui donneront un énorme coup de pouce à la qualité visuelle de votre scène. Ce chapitre aborde plus ou moins des aspects intéressants de GLSL et des astuces qui peuvent vous aider dans vos projets futurs. En gros, quelques bonnes choses à savoir et des fonctionnalités qui peuvent vous faciliter la vie lorsque vous créez des applications OpenGL en combinaison avec GLSL.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/08_geometry_shader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/08_geometry_shader/</guid>
      <description>Shader de géométrie Entre le shader de sommets et le shader de fragments, il existe une étape de shader optionnelle appelée shader de géométrie. Un shader géométrique prend en entrée un ensemble de sommets qui forment une primitive unique, par exemple un point ou un triangle. Le shader géométrique peut ensuite transformer ces sommets comme il l&amp;rsquo;entend avant de les envoyer à l&amp;rsquo;étape suivante du shader. Ce qui rend le shader géométrique intéressant, c&amp;rsquo;est qu&amp;rsquo;il est capable de convertir la primitive d&amp;rsquo;origine (ensemble de sommets) en des primitives complètement différentes, en générant éventuellement plus de sommets qu&amp;rsquo;il n&amp;rsquo;y en avait au départ.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/09_instancing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/09_instancing/</guid>
      <description>Instanciation Supposons que vous ayez une scène dans laquelle vous dessinez un grand nombre de modèles dont la plupart contiennent le même ensemble de données de vertex, mais avec des transformations du monde différentes. Imaginez une scène remplie de feuilles d&amp;rsquo;herbe : chaque feuille d&amp;rsquo;herbe est un petit modèle composé de quelques triangles seulement. Vous voudrez probablement en dessiner un certain nombre et votre scène pourra se retrouver avec des milliers, voire des dizaines de milliers de feuilles d&amp;rsquo;herbe que vous devrez rendre à chaque image.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/10_anti_aliasing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/10_anti_aliasing/</guid>
      <description>Anti Aliasing (Anti-crénelage) Au cours de votre aventure dans le domaine du rendu, vous avez probablement rencontré des motifs dentelés semblables à des scies sur les bords de vos modèles. La raison pour laquelle ces bords dentelés apparaissent est due à la façon dont le rasterizer transforme les données de vertex en fragments réels. Un exemple de ce à quoi ressemblent ces bords crénelés peut déjà être vu en dessinant un simple cube : Bien que cela ne soit pas immédiatement visible, si vous regardez de plus près les bords du cube, vous verrez un motif crénelé.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/00_advanced_lighting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/00_advanced_lighting/</guid>
      <description>Eclairage avancé Dans les chapitres consacrés à l&amp;rsquo;éclairage, nous avons brièvement présenté le modèle d&amp;rsquo;éclairage Phong afin d&amp;rsquo;apporter un minimum de réalisme à nos scènes. Le modèle Phong est agréable à regarder, mais il présente quelques nuances sur lesquelles nous allons nous concentrer dans ce chapitre.
Blinn-Phong L&amp;rsquo;éclairage Phong est une excellente approximation très efficace de l&amp;rsquo;éclairage, mais ses réflexions spéculaires se dégradent dans certaines conditions, en particulier lorsque la propriété de brillance est faible, ce qui entraîne une grande zone spéculaire (rugueuse).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/01_gamma_correction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/01_gamma_correction/</guid>
      <description>Gamma Correction Dès que nous avons calculé les couleurs des pixels de la scène, nous devons les afficher sur un moniteur. À l&amp;rsquo;époque de l&amp;rsquo;imagerie numérique, la plupart des moniteurs étaient des tubes cathodiques (CRT). Ces moniteurs avaient la propriété physique que le double de la tension d&amp;rsquo;entrée n&amp;rsquo;entraînait pas le double de la luminosité. Le doublement de la tension d&amp;rsquo;entrée se traduisait par une luminosité égale à une relation exponentielle d&amp;rsquo;environ 2,2, connue sous le nom de gamma d&amp;rsquo;un moniteur.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/02a_shadow_mapping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/02a_shadow_mapping/</guid>
      <description>Shadow mapping Les ombres résultent de l&amp;rsquo;absence de lumière due à une occlusion. Lorsque les rayons lumineux d&amp;rsquo;une source de lumière n&amp;rsquo;atteignent pas un objet parce qu&amp;rsquo;il est occulté par un autre objet, l&amp;rsquo;objet est dans l&amp;rsquo;ombre. Les ombres ajoutent beaucoup de réalisme à une scène éclairée et permettent au spectateur d&amp;rsquo;observer plus facilement les relations spatiales entre les objets. Elles donnent une plus grande impression de profondeur à la scène et aux objets.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/02b_point_shadows/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/02b_point_shadows/</guid>
      <description>Ombres ponctuelles Dans le dernier chapitre, nous avons appris à créer des ombres dynamiques avec le shadow mapping. Cette méthode fonctionne très bien, mais elle est surtout adaptée aux lumières directionnelles (ou ponctuelles), car les ombres ne sont générées que dans la direction de la source lumineuse. C&amp;rsquo;est pourquoi elle est également connue sous le nom de mapping directionnel des ombres, car la map de profondeur (ou d&amp;rsquo;ombres) est générée uniquement dans la direction vers laquelle la lumière regarde.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/03_normal_mapping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/03_normal_mapping/</guid>
      <description>Normal mapping Toutes nos scènes sont remplies de meshes, chacun composé de centaines, voire de milliers de triangles. Nous avons renforcé le réalisme en appliquant des textures 2D sur ces triangles plats, cachant ainsi le fait que les polygones ne sont que de minuscules triangles plats. Les textures sont utiles, mais lorsque l&amp;rsquo;on examine de près les meshes, il est toujours facile de voir les surfaces planes sous-jacentes. La plupart des surfaces de la vie réelle ne sont cependant pas plates et présentent de nombreux détails (bosses).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/04_parallax_mapping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/04_parallax_mapping/</guid>
      <description>Le mapping parallaxe Le mapping parallaxe est une technique similaire au normal mapping, mais basé sur des principes différents. Tout comme le normal mapping, il s&amp;rsquo;agit d&amp;rsquo;une technique qui augmente considérablement les détails d&amp;rsquo;une surface texturée et lui donne une impression de profondeur. Bien qu&amp;rsquo;il s&amp;rsquo;agisse également d&amp;rsquo;une illusion, le parallaxe mapping est beaucoup plus efficace pour donner une impression de profondeur et, combinée au normal mapping, il donne des résultats incroyablement réalistes.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/05_hdr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/05_hdr/</guid>
      <description>HDR Les valeurs de luminosité et de couleur sont, par défaut, comprises entre $0.0$ et $1.0$ lorsqu&amp;rsquo;elles sont stockées dans un framebuffer. Cette déclaration, à première vue innocente, nous a poussés à toujours spécifier les valeurs de luminosité et de couleur quelque part dans cette fourchette, en essayant de les faire correspondre à la scène. Cela fonctionne bien et donne des résultats corrects, mais que se passe-t-il si nous marchons dans une zone très lumineuse avec plusieurs sources lumineuses dont la somme totale dépasse $1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/06_bloom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/06_bloom/</guid>
      <description>Bloom Les sources lumineuses vives et les régions très éclairées sont souvent difficiles à faire comprendre à l&amp;rsquo;observateur, car la plage d&amp;rsquo;intensité d&amp;rsquo;un moniteur est limitée. L&amp;rsquo;un des moyens de distinguer les sources lumineuses vives sur un moniteur consiste à les faire briller ; la lumière s&amp;rsquo;étend alors autour de la source lumineuse. Cela donne au spectateur l&amp;rsquo;illusion que ces sources lumineuses ou ces zones lumineuses sont intensément lumineuses.
Cet effet de brillance/lueur (bleeding) est obtenu grâce à un effet de post-traitement appelé Bloom.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/07_deferred_shading/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/07_deferred_shading/</guid>
      <description>Ombrage différé La méthode d&amp;rsquo;éclairage utilisée jusqu&amp;rsquo;à présent s&amp;rsquo;appelait &amp;ldquo;forward rendering&amp;rdquo; ou &amp;ldquo;forward shading&amp;rdquo;. Il s&amp;rsquo;agit d&amp;rsquo;une approche simple qui consiste à effectuer le rendu d&amp;rsquo;un objet et à l&amp;rsquo;éclairer en fonction de toutes les sources lumineuses de la scène. Nous faisons cela pour chaque objet individuellement pour chaque objet de la scène. Bien qu&amp;rsquo;elle soit facile à comprendre et à mettre en œuvre, cette approche est également très coûteuse en termes de performances, car chaque objet rendu doit itérer sur chaque source de lumière pour chaque fragment rendu, ce qui est beaucoup !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/08_ssao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/08_ssao/</guid>
      <description>SSAO Nous avons brièvement abordé le sujet dans le chapitre sur l&amp;rsquo;éclairage de base : l&amp;rsquo;éclairage ambiant. L&amp;rsquo;éclairage ambiant est une constante lumineuse fixe que nous ajoutons à l&amp;rsquo;éclairage global d&amp;rsquo;une scène pour simuler la diffusion de la lumière. En réalité, la lumière se disperse dans toutes sortes de directions avec des intensités variables, de sorte que les parties indirectement éclairées d&amp;rsquo;une scène doivent également présenter des intensités variables. L&amp;rsquo;un des types d&amp;rsquo;approximation de l&amp;rsquo;éclairage indirect est appelé occlusion ambiante.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/06_pbr/01_theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/06_pbr/01_theory/</guid>
      <description>Théorie Le PBR, ou plus communément appelé rendu basé sur la physique (physically based renderer), est un ensemble de techniques de rendu plus ou moins basées sur la même théorie sous-jacente qui correspond plus étroitement à celle du monde physique. Comme le rendu basé sur la physique vise à imiter la lumière d&amp;rsquo;une manière physiquement plausible, il semble généralement plus réaliste que nos algorithmes d&amp;rsquo;éclairage originaux tels que Phong et Blinn-Phong.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/06_pbr/02_lighting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/06_pbr/02_lighting/</guid>
      <description>Lighting Dans le chapitre précédent, nous avons jeté les bases d&amp;rsquo;un moteur de rendu réaliste basé sur la physique. Dans ce chapitre, nous allons nous concentrer sur la traduction de la théorie discutée précédemment en un moteur de rendu réel qui utilise des sources de lumière directes (ou analytiques) : pensez aux lumières ponctuelles, aux lumières directionnelles et/ou aux projecteurs.
Commençons par revoir l&amp;rsquo;équation de réflectance finale du chapitre précédent : $$ L_0(p,w_0) \int_{\Omega} ( k_d {c\over \pi} + { DFG \over 4(w_0 *n)(w_i * n) } L_i(p,w_i)n * w_idw_i ) $$</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/06_pbr/03_ibl/01_diffuse_irradiance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/06_pbr/03_ibl/01_diffuse_irradiance/</guid>
      <description>Rayonnement diffus L&amp;rsquo;IBL, ou éclairage basé sur l&amp;rsquo;image, est un ensemble de techniques permettant d&amp;rsquo;éclairer des objets, non pas par des lumières analytiques directes comme dans le chapitre précédent, mais en traitant l&amp;rsquo;environnement comme une grande source de lumière. Ceci est généralement réalisé en manipulant une map d&amp;rsquo;environnement cubemap (prise dans le monde réel ou générée à partir d&amp;rsquo;une scène 3D) de telle sorte que nous puissions l&amp;rsquo;utiliser directement dans nos équations d&amp;rsquo;éclairage : en traitant chaque texel cubemap comme un émetteur de lumière.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hrst4.xyz/docs/learnopengl_fr/06_pbr/03_ibl/02_specular_ibl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hrst4.xyz/docs/learnopengl_fr/06_pbr/03_ibl/02_specular_ibl/</guid>
      <description>*# IBL Spéculaire Dans le chapitre précédent, nous avons mis en place le PBR en combinaison avec l&amp;rsquo;éclairage basé sur l&amp;rsquo;image en pré-calculant une map d&amp;rsquo;irradiance comme partie diffuse indirecte de l&amp;rsquo;éclairage. Dans ce chapitre, nous allons nous concentrer sur la partie spéculaire de l&amp;rsquo;équation de réflectance : $$ L_o(p,w_o) = \int_{\Omega} ( k_d { c \over \pi } k_s { DFG \over 4(w_on)(w_in) } L_i(p,w_i)n*w_idw_i ) $$ Vous remarquerez que la partie spéculaire de Cook-Torrance (multipliée par $k_S$) n&amp;rsquo;est pas constante sur l&amp;rsquo;intégrale et dépend de la direction de la lumière entrante, mais aussi de la direction de la vue entrante.</description>
    </item>
    
  </channel>
</rss>
