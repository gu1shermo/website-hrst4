<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="Mesh Avec Assimp, nous pouvons charger de nombreux modèles différents dans l&rsquo;application, mais une fois chargés, ils sont tous stockés dans les structures de données d&rsquo;Assimp. Ce que nous voulons finalement, c&rsquo;est transformer ces données dans un format qu&rsquo;OpenGL comprend afin que nous puissions effectuer le rendu des objets. Nous avons appris dans le chapitre précédent qu&rsquo;un mesh représente une seule entité dessinable, alors commençons par définir notre propre classe de mesh.">
<meta name="author" content="">
<link rel="canonical" href="https://hrst4.xyz/docs/learnopengl_fr/03_model_loading/mesh/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://hrst4.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hrst4.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hrst4.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hrst4.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://hrst4.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="Mesh Avec Assimp, nous pouvons charger de nombreux modèles différents dans l&rsquo;application, mais une fois chargés, ils sont tous stockés dans les structures de données d&rsquo;Assimp. Ce que nous voulons finalement, c&rsquo;est transformer ces données dans un format qu&rsquo;OpenGL comprend afin que nous puissions effectuer le rendu des objets. Nous avons appris dans le chapitre précédent qu&rsquo;un mesh représente une seule entité dessinable, alors commençons par définir notre propre classe de mesh." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hrst4.xyz/docs/learnopengl_fr/03_model_loading/mesh/" /><meta property="article:section" content="docs" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Mesh Avec Assimp, nous pouvons charger de nombreux modèles différents dans l&rsquo;application, mais une fois chargés, ils sont tous stockés dans les structures de données d&rsquo;Assimp. Ce que nous voulons finalement, c&rsquo;est transformer ces données dans un format qu&rsquo;OpenGL comprend afin que nous puissions effectuer le rendu des objets. Nous avons appris dans le chapitre précédent qu&rsquo;un mesh représente une seule entité dessinable, alors commençons par définir notre propre classe de mesh."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Docs",
      "item": "https://hrst4.xyz/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://hrst4.xyz/docs/learnopengl_fr/03_model_loading/mesh/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "Mesh Avec Assimp, nous pouvons charger de nombreux modèles différents dans l\u0026rsquo;application, mais une fois chargés, ils sont tous stockés dans les structures de données d\u0026rsquo;Assimp. Ce que nous voulons finalement, c\u0026rsquo;est transformer ces données dans un format qu\u0026rsquo;OpenGL comprend afin que nous puissions effectuer le rendu des objets. Nous avons appris dans le chapitre précédent qu\u0026rsquo;un mesh représente une seule entité dessinable, alors commençons par définir notre propre classe de mesh.",
  "keywords": [
    
  ],
  "articleBody": "Mesh Avec Assimp, nous pouvons charger de nombreux modèles différents dans l’application, mais une fois chargés, ils sont tous stockés dans les structures de données d’Assimp. Ce que nous voulons finalement, c’est transformer ces données dans un format qu’OpenGL comprend afin que nous puissions effectuer le rendu des objets. Nous avons appris dans le chapitre précédent qu’un mesh représente une seule entité dessinable, alors commençons par définir notre propre classe de mesh.\nRevoyons un peu ce que nous avons appris jusqu’à présent pour réfléchir à ce qu’un mesh devrait minimalement avoir comme données. Un mesh doit au moins avoir un ensemble de sommets, où chaque sommet contient un vecteur de position, un vecteur de normalité et un vecteur de coordonnées de texture. Un maillage doit également contenir des indices pour le dessin indexé et des données matérielles sous la forme de textures (maps diffuses/spéculaires).\nMaintenant que nous avons défini les exigences minimales pour une classe de mesh, nous pouvons définir un sommet dans OpenGL :\nstruct Vertex { glm::vec3 Position; glm::vec3 Normal; glm::vec2 TexCoords; }; Nous stockons chacun des attributs de vertex requis dans une structure appelée Vertex. En plus de la structure Vertex, nous voulons également organiser les données de texture dans une structure Texture :\nstruct Texture { unsigned int id; string type; }; Nous stockons l’identifiant de la texture et son type, par exemple une texture diffuse ou spéculaire.\nConnaissant la représentation réelle d’un sommet et d’une texture, nous pouvons commencer à définir la structure de la classe de Mesh :\nclass Mesh { public: // mesh data vector\u003cVertex\u003e vertices; vector\u003cunsigned int\u003e indices; vector\u003cTexture\u003e textures; Mesh(vector\u003cVertex\u003e vertices, vector\u003cunsigned int\u003e indices, vector\u003cTexture\u003e textures); void Draw(Shader \u0026shader); private: // render data unsigned int VAO, VBO, EBO; void setupMesh(); }; Comme vous pouvez le voir, la classe n’est pas trop compliquée. Dans le constructeur, nous donnons au mesh toutes les données nécessaires, nous initialisons les buffers dans la fonction setupMesh, et enfin nous dessinons le mesh via la fonction Draw. Notez que nous donnons un shader à la fonction Draw ; en passant le shader au mesh, nous pouvons définir plusieurs uniformes avant de dessiner (comme lier les samplers aux unités de texture).\nLe contenu de la fonction du constructeur est assez simple. Nous définissons simplement les variables publiques de la classe avec les variables d’argument correspondantes du constructeur. Nous appelons également la fonction setupMesh dans le constructeur :\nMesh(vector\u003cVertex\u003e vertices, vector\u003cunsigned int\u003e indices, vector\u003cTexture\u003e textures) { this-\u003evertices = vertices; this-\u003eindices = indices; this-\u003etextures = textures; setupMesh(); } Il ne se passe rien de spécial ici. Plongeons maintenant dans la fonction setupMesh.\nInitialisation Grâce au constructeur, nous disposons maintenant de grandes listes de données de mesh que nous pouvons utiliser pour le rendu. Nous devons configurer les buffers appropriés et spécifier la disposition du vertex shader via les pointeurs d’attributs de vertex. Vous ne devriez plus avoir de problème avec ces concepts, mais nous les avons un peu pimentés avec l’introduction des données de vertex dans les structures :\nvoid setupMesh() { glGenVertexArrays(1, \u0026VAO); glGenBuffers(1, \u0026VBO); glGenBuffers(1, \u0026EBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), \u0026vertices[0], GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), \u0026indices[0], GL_STATIC_DRAW); // vertex positions glEnableVertexAttribArray(0);\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0); // vertex normals glEnableVertexAttribArray(1);\tglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal)); // vertex texture coords glEnableVertexAttribArray(2);\tglVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords)); glBindVertexArray(0); } Le code n’est pas très différent de ce à quoi on pourrait s’attendre, mais quelques petites astuces ont été utilisées avec l’aide de la structure Vertex.\nLes structures ont une grande propriété en C++, à savoir que leur disposition en mémoire est séquentielle. En d’autres termes, si nous devions représenter une structure comme un tableau de données, elle ne contiendrait que les variables de la structure dans un ordre séquentiel, ce qui se traduit directement par un tableau de flottants (en fait d’octets) que nous voulons pour un buffer de tableau. Par exemple, si nous avons une structure Vertex remplie, sa disposition en mémoire serait la suivante :\nVertex vertex; vertex.Position = glm::vec3(0.2f, 0.4f, 0.6f); vertex.Normal = glm::vec3(0.0f, 1.0f, 0.0f); vertex.TexCoords = glm::vec2(1.0f, 0.0f); // = [0.2f, 0.4f, 0.6f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f]; Grâce à cette propriété utile, nous pouvons directement passer un pointeur sur une grande liste de structures Vertex en tant que données du buffer et elles correspondent parfaitement à ce que glBufferData attend en tant qu’argument :\nglBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices[0], GL_STATIC_DRAW); Naturellement, l’opérateur sizeof peut également être utilisé sur la structure pour obtenir la taille appropriée en octets. Celle-ci devrait être de 32 octets (8 flottants * 4 octets chacun).\nUne autre utilisation intéressante des structures est une directive du préprocesseur appelée offsetof(s,m) qui prend comme premier argument une structure et comme second argument un nom de variable de la structure. La macro renvoie l’octet de décalage de cette variable à partir du début de la structure. Cette macro est parfaite pour définir le paramètre offset de la fonction glVertexAttribPointer :\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal)); Le décalage est maintenant défini à l’aide de la macro offsetof qui, dans ce cas, définit le décalage d’octet du vecteur normal égal au décalage d’octet de l’attribut normal dans la structure qui est de 3 flottants et donc de 12 octets.\nL’utilisation d’une telle structure ne nous permet pas seulement d’obtenir un code plus lisible, mais aussi d’étendre facilement la structure. Si nous voulons un autre attribut de sommet, nous pouvons simplement l’ajouter à la structure et, en raison de sa nature flexible, le code de rendu ne sera pas interrompu.\nRendu (Rendering) La dernière fonction que nous devons définir pour que la classe Mesh soit complète est la fonction Draw. Avant de rendre le mesh, nous voulons d’abord lier les textures appropriées avant d’appeler glDrawElements. ****Cependant, ceci est quelque peu difficile puisque nous ne savons pas dès le départ combien de textures (s’il y en a) le mesh possède et quel type elles peuvent avoir. Comment définir les unités de texture et les échantillonneurs dans les shaders ?\nPour résoudre ce problème, nous allons partir d’une certaine convention de nommage : chaque texture diffuse est nommée texture_diffuseN, et chaque texture spéculaire doit être nommée texture_specularN, où N est un nombre quelconque allant de 1 au nombre maximum d’échantillonneurs de textures autorisé. Supposons que nous ayons 3 textures diffuses et 2 textures spéculaires pour un maillage particulier, leurs échantillonneurs de texture devraient alors être appelés :\nuniform sampler2D texture_diffuse1; uniform sampler2D texture_diffuse2; uniform sampler2D texture_diffuse3; uniform sampler2D texture_specular1; uniform sampler2D texture_specular2; Grâce à cette convention, nous pouvons définir autant de samplers de textures que nous le souhaitons dans les shaders (jusqu’au maximum d’OpenGL) et si un maillage contient effectivement (autant) de textures, nous savons quels seront leurs noms. Grâce à cette convention, nous pouvons traiter n’importe quel nombre de textures sur un seul maillage et le développeur de shaders est libre d’en utiliser autant qu’il le souhaite en définissant les samplers appropriés.\nIl existe de nombreuses solutions à ce type de problème et si vous n’aimez pas cette solution particulière, c’est à vous de faire preuve de créativité et de trouver votre propre approche.\nLe code de dessin résultant devient alors :\nvoid Draw(Shader \u0026shader) { unsigned int diffuseNr = 1; unsigned int specularNr = 1; for(unsigned int i = 0; i \u003c textures.size(); i++) { glActiveTexture(GL_TEXTURE0 + i); // activate proper texture unit before binding // retrieve texture number (the N in diffuse_textureN) string number; string name = textures[i].type; if(name == \"texture_diffuse\") number = std::to_string(diffuseNr++); else if(name == \"texture_specular\") number = std::to_string(specularNr++); shader.setInt((\"material.\" + name + number).c_str(), i); glBindTexture(GL_TEXTURE_2D, textures[i].id); } glActiveTexture(GL_TEXTURE0); // draw mesh glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0); glBindVertexArray(0); } Nous calculons d’abord la composante N par type de texture et la concaténons à la chaîne de type de la texture pour obtenir le nom d’uniforme approprié. Nous localisons ensuite le sampler approprié, lui donnons la valeur d’emplacement correspondant à l’unité de texture actuellement active et lions la texture. C’est également la raison pour laquelle nous avons besoin du shader dans la fonction Draw.\nNous avons également ajouté “material.” au nom de l’uniforme résultant parce que nous stockons généralement les textures dans une structure matérielle (cela peut différer selon l’implémentation).\nNotez que nous incrémentons les compteurs diffus et spéculaires au moment où nous les convertissons en chaînes de caractères. En C++, l’appel à l’incrémentation : variable++ renvoie la variable telle quelle, puis l’incrémente, tandis que ++variable incrémente d’abord la variable, puis la renvoie. Dans notre cas, la valeur transmise à std::string est la valeur originale du compteur. Ensuite, la valeur est incrémentée pour le prochain tour.\nVous pouvez trouver le code source complet de la classe Mesh ici.\nLa classe Mesh que nous venons de définir est une abstraction pour de nombreux sujets que nous avons abordés dans les premiers chapitres. Dans le prochain chapitre, nous créerons un modèle qui servira de conteneur pour plusieurs objets mesh et qui implémentera l’interface de chargement d’Assimp.\n",
  "wordCount" : "1493",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hrst4.xyz/docs/learnopengl_fr/03_model_loading/mesh/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hrst4.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hrst4.xyz/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="mesh">Mesh<a hidden class="anchor" aria-hidden="true" href="#mesh">#</a></h1>
<p>Avec Assimp, nous pouvons charger de nombreux modèles différents dans l&rsquo;application, mais une fois chargés, ils sont tous stockés dans les structures de données d&rsquo;Assimp. <strong>Ce que nous voulons finalement, c&rsquo;est transformer ces données dans un format qu&rsquo;OpenGL comprend afin que nous puissions effectuer le rendu des objets</strong>. Nous avons appris dans le chapitre précédent qu&rsquo;un mesh représente une seule entité dessinable, alors commençons par définir notre propre classe de mesh.</p>
<p>Revoyons un peu ce que nous avons appris jusqu&rsquo;à présent pour réfléchir à ce qu&rsquo;un mesh devrait minimalement avoir comme données. <strong>Un mesh doit au moins avoir un ensemble de sommets, où chaque sommet contient un vecteur de position, un vecteur de normalité et un vecteur de coordonnées de texture</strong>. <strong>Un maillage doit également contenir des indices pour le dessin indexé et des données matérielles sous la forme de textures (maps diffuses/spéculaires).</strong></p>
<p>Maintenant que nous avons défini les exigences minimales pour une classe de mesh, nous pouvons définir un sommet dans OpenGL :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Vertex</span> {
</span></span><span style="display:flex;"><span>    glm<span style="color:#f92672">::</span>vec3 Position;
</span></span><span style="display:flex;"><span>    glm<span style="color:#f92672">::</span>vec3 Normal;
</span></span><span style="display:flex;"><span>    glm<span style="color:#f92672">::</span>vec2 TexCoords;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Nous stockons chacun des attributs de vertex requis dans une structure appelée <code>Vertex</code>. En plus de la structure <code>Vertex</code>, nous voulons également organiser les données de texture dans une structure <code>Texture</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Texture</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> id;
</span></span><span style="display:flex;"><span>    string type;
</span></span><span style="display:flex;"><span>}; 
</span></span></code></pre></div><p>Nous stockons l&rsquo;identifiant de la texture et son type, par exemple une texture diffuse ou spéculaire.</p>
<p>Connaissant la représentation réelle d&rsquo;un sommet et d&rsquo;une texture, nous pouvons commencer à définir la structure de la classe de Mesh :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Mesh</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// mesh data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span>Vertex<span style="color:#f92672">&gt;</span>       vertices;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> indices;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;</span>      textures;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Mesh(vector<span style="color:#f92672">&lt;</span>Vertex<span style="color:#f92672">&gt;</span> vertices, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> indices, vector<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;</span> textures);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Draw</span>(Shader <span style="color:#f92672">&amp;</span>shader);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//  render data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> VAO, VBO, EBO;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setupMesh</span>();
</span></span><span style="display:flex;"><span>};  
</span></span></code></pre></div><p>Comme vous pouvez le voir, la classe n&rsquo;est pas trop compliquée. Dans le constructeur, nous donnons au mesh toutes les données nécessaires, nous initialisons les buffers dans la fonction <code>setupMesh</code>, et enfin nous dessinons le mesh via la fonction <code>Draw</code>. Notez que nous donnons un shader à la fonction <code>Draw</code> ; en passant le shader au mesh, nous pouvons définir plusieurs uniformes avant de dessiner (comme lier les samplers aux unités de texture).</p>
<p>Le contenu de la fonction du constructeur est assez simple. Nous définissons simplement les variables publiques de la classe avec les variables d&rsquo;argument correspondantes du constructeur. Nous appelons également la fonction <code>setupMesh</code> dans le constructeur :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Mesh(vector<span style="color:#f92672">&lt;</span>Vertex<span style="color:#f92672">&gt;</span> vertices, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> indices, vector<span style="color:#f92672">&lt;</span>Texture<span style="color:#f92672">&gt;</span> textures)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>vertices <span style="color:#f92672">=</span> vertices;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>indices <span style="color:#f92672">=</span> indices;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>textures <span style="color:#f92672">=</span> textures;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    setupMesh();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Il ne se passe rien de spécial ici. Plongeons maintenant dans la fonction <code>setupMesh</code>.</p>
<h2 id="initialisation">Initialisation<a hidden class="anchor" aria-hidden="true" href="#initialisation">#</a></h2>
<p>Grâce au constructeur, nous disposons maintenant de grandes listes de données de mesh que nous pouvons utiliser pour le rendu. Nous devons configurer les buffers appropriés et spécifier la disposition du vertex shader via les pointeurs d&rsquo;attributs de vertex. Vous ne devriez plus avoir de problème avec ces concepts, mais nous les avons un peu pimentés avec l&rsquo;introduction des données de vertex dans les structures :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setupMesh</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    glGenVertexArrays(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>VAO);
</span></span><span style="display:flex;"><span>    glGenBuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>VBO);
</span></span><span style="display:flex;"><span>    glGenBuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>EBO);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    glBindVertexArray(VAO);
</span></span><span style="display:flex;"><span>    glBindBuffer(GL_ARRAY_BUFFER, VBO);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    glBufferData(GL_ARRAY_BUFFER, vertices.size() <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(Vertex), <span style="color:#f92672">&amp;</span>vertices[<span style="color:#ae81ff">0</span>], GL_STATIC_DRAW);  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
</span></span><span style="display:flex;"><span>    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>), 
</span></span><span style="display:flex;"><span>                 <span style="color:#f92672">&amp;</span>indices[<span style="color:#ae81ff">0</span>], GL_STATIC_DRAW);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// vertex positions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    glEnableVertexAttribArray(<span style="color:#ae81ff">0</span>);	
</span></span><span style="display:flex;"><span>    glVertexAttribPointer(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, GL_FLOAT, GL_FALSE, <span style="color:#66d9ef">sizeof</span>(Vertex), (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// vertex normals
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    glEnableVertexAttribArray(<span style="color:#ae81ff">1</span>);	
</span></span><span style="display:flex;"><span>    glVertexAttribPointer(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, GL_FLOAT, GL_FALSE, <span style="color:#66d9ef">sizeof</span>(Vertex), (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)offsetof(Vertex, Normal));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// vertex texture coords
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    glEnableVertexAttribArray(<span style="color:#ae81ff">2</span>);	
</span></span><span style="display:flex;"><span>    glVertexAttribPointer(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, GL_FLOAT, GL_FALSE, <span style="color:#66d9ef">sizeof</span>(Vertex), (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)offsetof(Vertex, TexCoords));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    glBindVertexArray(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Le code n&rsquo;est pas très différent de ce à quoi on pourrait s&rsquo;attendre, mais quelques petites astuces ont été utilisées avec l&rsquo;aide de la structure <code>Vertex</code>.</p>
<p><strong>Les structures ont une grande propriété en C++, à savoir que leur disposition en mémoire est séquentielle</strong>. En d&rsquo;autres termes, si nous devions représenter une structure comme un tableau de données, elle ne contiendrait que les variables de la structure dans un ordre séquentiel, <strong>ce qui se traduit directement par un tableau de flottants (en fait d&rsquo;octets) que nous voulons pour un buffer de tableau</strong>. Par exemple, si nous avons une structure Vertex remplie, sa disposition en mémoire serait la suivante :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Vertex vertex;
</span></span><span style="display:flex;"><span>vertex.Position  <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">0.2f</span>, <span style="color:#ae81ff">0.4f</span>, <span style="color:#ae81ff">0.6f</span>);
</span></span><span style="display:flex;"><span>vertex.Normal    <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>);
</span></span><span style="display:flex;"><span>vertex.TexCoords <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>vec2(<span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// = [0.2f, 0.4f, 0.6f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f];
</span></span></span></code></pre></div><p>Grâce à cette propriété utile, nous pouvons directement passer un pointeur sur une grande liste de structures <code>Vertex</code> en tant que données du buffer et elles correspondent parfaitement à ce que <code>glBufferData</code> attend en tant qu&rsquo;argument :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glBufferData(GL_ARRAY_BUFFER, vertices.size() <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(Vertex), vertices[<span style="color:#ae81ff">0</span>], GL_STATIC_DRAW);    
</span></span></code></pre></div><p>Naturellement, l&rsquo;opérateur <code>sizeof</code> peut également être utilisé sur la structure pour obtenir la taille appropriée en octets. Celle-ci devrait être de 32 octets (8 flottants * 4 octets chacun).</p>
<p>Une autre utilisation intéressante des structures est une directive du préprocesseur appelée <code>offsetof(s,m)</code> qui prend comme premier argument une structure et comme second argument un nom de variable de la structure. La macro renvoie l&rsquo;octet de décalage de cette variable à partir du début de la structure. Cette macro est parfaite pour définir le paramètre offset de la fonction <code>glVertexAttribPointer</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glVertexAttribPointer(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, GL_FLOAT, GL_FALSE, <span style="color:#66d9ef">sizeof</span>(Vertex), (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)offsetof(Vertex, Normal));  
</span></span></code></pre></div><p>Le décalage est maintenant défini à l&rsquo;aide de la macro <code>offsetof</code> qui, dans ce cas, définit le décalage d&rsquo;octet du vecteur normal égal au décalage d&rsquo;octet de l&rsquo;attribut normal dans la structure qui est de 3 flottants et donc de 12 octets.</p>
<p><strong>L&rsquo;utilisation d&rsquo;une telle structure ne nous permet pas seulement d&rsquo;obtenir un code plus lisible, mais aussi d&rsquo;étendre facilement la structure.</strong> Si nous voulons un autre attribut de sommet, nous pouvons simplement l&rsquo;ajouter à la structure et, en raison de sa nature flexible, le code de rendu ne sera pas interrompu.</p>
<h2 id="rendu-rendering">Rendu (Rendering)<a hidden class="anchor" aria-hidden="true" href="#rendu-rendering">#</a></h2>
<p>La dernière fonction que nous devons définir pour que la classe <code>Mesh</code> soit complète est la fonction <code>Draw</code>. <strong>Avant de rendre le mesh, nous voulons d&rsquo;abord lier les textures appropriées avant d&rsquo;appeler <code>glDrawElements</code></strong>. ****Cependant, ceci est quelque peu difficile puisque nous ne savons pas dès le départ combien de textures (s&rsquo;il y en a) le mesh possède et quel type elles peuvent avoir. Comment définir les unités de texture et les échantillonneurs dans les shaders ?</p>
<p><strong>Pour résoudre ce problème, nous allons partir d&rsquo;une certaine convention de nommage</strong> : chaque texture diffuse est nommée <code>texture_diffuseN</code>, et chaque texture spéculaire doit être nommée <code>texture_specularN</code>, <strong>où N est un nombre quelconque allant de 1 au nombre maximum d&rsquo;échantillonneurs de textures autorisé</strong>. Supposons que nous ayons 3 textures diffuses et 2 textures spéculaires pour un maillage particulier, leurs échantillonneurs de texture devraient alors être appelés :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>uniform sampler2D texture_diffuse1;
</span></span><span style="display:flex;"><span>uniform sampler2D texture_diffuse2;
</span></span><span style="display:flex;"><span>uniform sampler2D texture_diffuse3;
</span></span><span style="display:flex;"><span>uniform sampler2D texture_specular1;
</span></span><span style="display:flex;"><span>uniform sampler2D texture_specular2;
</span></span></code></pre></div><p>Grâce à cette convention, nous pouvons définir autant de samplers de textures que nous le souhaitons dans les shaders (jusqu&rsquo;au maximum d&rsquo;OpenGL) et si un maillage contient effectivement (autant) de textures, nous savons quels seront leurs noms. <strong>Grâce à cette convention, nous pouvons traiter n&rsquo;importe quel nombre de textures sur un seul maillage et le développeur de shaders est libre d&rsquo;en utiliser autant qu&rsquo;il le souhaite en définissant les samplers appropriés.</strong></p>
<blockquote>
<p>Il existe de nombreuses solutions à ce type de problème et si vous n&rsquo;aimez pas cette solution particulière, c&rsquo;est à vous de faire preuve de créativité et de trouver votre propre approche.</p>
</blockquote>
<p>Le code de dessin résultant devient alors :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Draw</span>(Shader <span style="color:#f92672">&amp;</span>shader) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> diffuseNr <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> specularNr <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> textures.size(); i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        glActiveTexture(GL_TEXTURE0 <span style="color:#f92672">+</span> i); <span style="color:#75715e">// activate proper texture unit before binding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// retrieve texture number (the N in diffuse_textureN)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        string number;
</span></span><span style="display:flex;"><span>        string name <span style="color:#f92672">=</span> textures[i].type;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(name <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;texture_diffuse&#34;</span>)
</span></span><span style="display:flex;"><span>            number <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>to_string(diffuseNr<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(name <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;texture_specular&#34;</span>)
</span></span><span style="display:flex;"><span>            number <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>to_string(specularNr<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        shader.setInt((<span style="color:#e6db74">&#34;material.&#34;</span> <span style="color:#f92672">+</span> name <span style="color:#f92672">+</span> number).c_str(), i);
</span></span><span style="display:flex;"><span>        glBindTexture(GL_TEXTURE_2D, textures[i].id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    glActiveTexture(GL_TEXTURE0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// draw mesh
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    glBindVertexArray(VAO);
</span></span><span style="display:flex;"><span>    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    glBindVertexArray(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Nous calculons d&rsquo;abord la composante <strong>N</strong> par type de texture et la concaténons à la chaîne de type de la texture pour obtenir le nom d&rsquo;uniforme approprié. Nous localisons ensuite le sampler approprié, lui donnons la valeur d&rsquo;emplacement correspondant à l&rsquo;unité de texture actuellement active et lions la texture. <strong>C&rsquo;est également la raison pour laquelle nous avons besoin du shader dans la fonction Draw.</strong></p>
<p>Nous avons également ajouté &ldquo;<code>material.</code>&rdquo; au nom de l&rsquo;uniforme résultant parce que nous stockons généralement les textures dans une structure matérielle (cela peut différer selon l&rsquo;implémentation).</p>
<blockquote>
<p>Notez que nous incrémentons les compteurs diffus et spéculaires au moment où nous les convertissons en chaînes de caractères. En C++, l&rsquo;appel à l&rsquo;incrémentation : <strong>variable++ renvoie la variable telle quelle, puis l&rsquo;incrémente, tandis que ++variable incrémente d&rsquo;abord la variable, puis la renvoie.</strong> Dans notre cas, la valeur transmise à <code>std::string</code> est la valeur originale du compteur. Ensuite, la valeur est incrémentée pour le prochain tour.</p>
</blockquote>
<p>Vous pouvez trouver le code source complet de la classe <code>Mesh</code> <a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/mesh.h">ici</a>.</p>
<p>La classe <code>Mesh</code> que nous venons de définir est une <strong>abstraction</strong> pour de nombreux sujets que nous avons abordés dans les premiers chapitres. Dans le prochain chapitre, nous créerons un modèle qui servira de conteneur pour plusieurs objets mesh et qui implémentera l&rsquo;interface de chargement d&rsquo;Assimp.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hrst4.xyz/">My New Hugo Site</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
