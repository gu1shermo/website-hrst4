<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>hrst4&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Stencil testing Une fois que le shader de fragment a traité le fragment, un test de stencil est exécuté qui, tout comme le test de profondeur, a la possibilité d&rsquo;éliminer des fragments. Après cela, les fragments restants sont transmis au test de profondeur où OpenGL peut éventuellement rejeter encore plus de fragments. Le test de stencil (pochoir en français?) est basé sur le contenu d&rsquo;un autre tampon appelé tampon de stencil que nous sommes autorisés à mettre à jour pendant le rendu pour obtenir des effets intéressants.">
<meta name="author" content="">
<link rel="canonical" href="https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/01_stencil_testing/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://hrst4.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hrst4.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hrst4.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hrst4.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://hrst4.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="Stencil testing Une fois que le shader de fragment a traité le fragment, un test de stencil est exécuté qui, tout comme le test de profondeur, a la possibilité d&rsquo;éliminer des fragments. Après cela, les fragments restants sont transmis au test de profondeur où OpenGL peut éventuellement rejeter encore plus de fragments. Le test de stencil (pochoir en français?) est basé sur le contenu d&rsquo;un autre tampon appelé tampon de stencil que nous sommes autorisés à mettre à jour pendant le rendu pour obtenir des effets intéressants." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/01_stencil_testing/" /><meta property="article:section" content="docs" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Stencil testing Une fois que le shader de fragment a traité le fragment, un test de stencil est exécuté qui, tout comme le test de profondeur, a la possibilité d&rsquo;éliminer des fragments. Après cela, les fragments restants sont transmis au test de profondeur où OpenGL peut éventuellement rejeter encore plus de fragments. Le test de stencil (pochoir en français?) est basé sur le contenu d&rsquo;un autre tampon appelé tampon de stencil que nous sommes autorisés à mettre à jour pendant le rendu pour obtenir des effets intéressants."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "",
      "item": "https://hrst4.xyz/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/01_stencil_testing/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "Stencil testing Une fois que le shader de fragment a traité le fragment, un test de stencil est exécuté qui, tout comme le test de profondeur, a la possibilité d\u0026rsquo;éliminer des fragments. Après cela, les fragments restants sont transmis au test de profondeur où OpenGL peut éventuellement rejeter encore plus de fragments. Le test de stencil (pochoir en français?) est basé sur le contenu d\u0026rsquo;un autre tampon appelé tampon de stencil que nous sommes autorisés à mettre à jour pendant le rendu pour obtenir des effets intéressants.",
  "keywords": [
    
  ],
  "articleBody": "Stencil testing Une fois que le shader de fragment a traité le fragment, un test de stencil est exécuté qui, tout comme le test de profondeur, a la possibilité d’éliminer des fragments. Après cela, les fragments restants sont transmis au test de profondeur où OpenGL peut éventuellement rejeter encore plus de fragments. Le test de stencil (pochoir en français?) est basé sur le contenu d’un autre tampon appelé tampon de stencil que nous sommes autorisés à mettre à jour pendant le rendu pour obtenir des effets intéressants.\nUn tampon de stencil contient (généralement) 8 bits par valeur de stencil, ce qui représente un total de 256 valeurs de stencil différentes par pixel. Nous pouvons définir ces valeurs de stencil à notre convenance et nous pouvons écarter ou conserver des fragments lorsqu’un fragment particulier a une certaine valeur de stencil.\nChaque bibliothèque de fenêtrage doit mettre en place un tampon de stencil pour vous. GLFW le fait automatiquement, nous n’avons donc pas besoin de lui dire d’en créer un, mais d’autres bibliothèques de fenêtrage peuvent ne pas créer de tampon de stencil par défaut, alors vérifiez la documentation de votre bibliothèque.\nUn exemple simple de tampon de stencil est illustré ci-dessous (les pixels ne sont pas à l’échelle) : Le stencil buffer est d’abord vidé avec des zéros, puis un rectangle ouvert de 1 est stocké dans le stencil buffer. Les fragments de la scène ne sont alors rendus (les autres sont rejetés) que là où la valeur du stencil de ce fragment contient un 1.\nLes opérations sur le tampon de stencil nous permettent de fixer le tampon de stencil à des valeurs spécifiques partout où nous rendons des fragments. En changeant le contenu du tampon de stencil pendant le rendu, nous écrivons dans le tampon de stencil. Dans la même image (ou les suivantes), nous pouvons lire ces valeurs pour écarter ou passer certains fragments. Lors de l’utilisation des tampons de stencil, vous pouvez être aussi fou que vous le souhaitez, mais les grandes lignes sont généralement les suivantes :\nActiver l’écriture dans le tampon du stencil. Rendre les objets, en mettant à jour le contenu de la mémoire tampon du stencil. Désactiver l’écriture dans le tampon du stencil. Rendu des (autres) objets, cette fois en écartant certains fragments sur la base du contenu de la mémoire tampon du stencil. L’utilisation de la mémoire tampon du stencil permet d’écarter certains fragments en fonction des fragments d’autres objets dessinés dans la scène.\nVous pouvez activer le test du stencil en activant GL_STENCIL_TEST. À partir de ce moment, tous les appels de rendu influenceront le tampon du stencil d’une manière ou d’une autre.\nglEnable(GL_STENCIL_TEST); Notez que vous devez également effacer le tampon du stencil à chaque itération, tout comme les tampons de couleur et de profondeur :\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); De même, tout comme la fonction glDepthMask du test de profondeur, il existe une fonction équivalente pour le tampon du stencil. La fonction glStencilMask nous permet de définir un masque de bits qui est ANDed avec la valeur du stencil sur le point d’être écrite dans le tampon. Par défaut, ce masque est constitué de tous les 1 qui n’affectent pas la sortie, mais si nous le fixons à 0x00, toutes les valeurs de stencil écrites dans le tampon se retrouveront sous forme de 0. C’est l’équivalent du masque de profondeur glDepthMask(GL_FALSE) du test de profondeur :\nglStencilMask(0xFF); // each bit is written to the stencil buffer as is glStencilMask(0x00); // each bit ends up as 0 in the stencil buffer (disabling writes) Dans la plupart des cas, vous n’utiliserez que 0x00 ou 0xFF comme masque de stencil, mais il est bon de savoir qu’il existe des options permettant de définir des masques de bits personnalisés.\nFonctions Stencil Comme pour les tests de profondeur, nous avons un certain contrôle sur le moment où un test de stencil doit réussir ou échouer et sur la manière dont il doit affecter le tampon de stencil. Il existe au total deux fonctions que nous pouvons utiliser pour configurer les tests de stencil : glStencilFunc et glStencilOp.\nLa fonction glStencilFunc(GLenum func, GLint ref, GLuint mask) a trois paramètres :\nfunc : définit la fonction de test du stencil qui détermine si un fragment est accepté ou rejeté. Cette fonction de test est appliquée à la valeur de stencil stockée et à la valeur ref de glStencilFunc. Les options possibles sont : GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, GL_ALWAYS. Leur signification sémantique est similaire à celle des fonctions du tampon de profondeur. ref : spécifie la valeur de référence pour le test du stencil. Le contenu de la mémoire tampon du stencil est comparé à cette valeur. mask : spécifie un masque qui est ANDed avec la valeur de référence et la valeur de stencil stockée avant que le test ne les compare. Initialement, toutes les valeurs sont à 1. Ainsi, dans le cas de l’exemple simple du stencil que nous avons montré au début, la fonction serait réglée sur :\nglStencilFunc(GL_EQUAL, 1, 0xFF) Cela indique à OpenGL qu’à chaque fois que la valeur du stencil d’un fragment est égale (GL_EQUAL) à la valeur de référence 1, le fragment passe le test et est dessiné, sinon il est rejeté.\nMais glStencilFunc décrit seulement si OpenGL doit accepter ou rejeter les fragments en se basant sur le contenu du tampon de stencil, mais pas comment nous pouvons réellement mettre à jour le tampon. C’est là que glStencilOp entre en jeu.\nLa commande glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass) contient trois options parmi lesquelles nous pouvons spécifier pour chaque option l’action à entreprendre :\nsfail : action à entreprendre si le test du stencil échoue.\ndpfail : action à entreprendre si le test du stencil réussit, mais que le test de profondeur échoue.\ndppass : action à entreprendre si le test du stencil et le test de profondeur sont tous deux réussis.\nEnsuite, pour chacune des options, vous pouvez entreprendre l’une des actions suivantes :\nACTION DESCRIPTION GL_KEEP La valeur du stencil actuellement enregistrée est conservée. GL_ZERO La valeur du stencil est fixée à 0. GL_REPLACE La valeur du stencil est remplacée par la valeur de référence définie avec glStencilFunc. GL_INCR La valeur du stencil est augmentée de 1 si elle est inférieure à la valeur maximale. GL_INCR_WRAP Identique à GL_INCR, mais le ramène à 0 dès que la valeur maximale est dépassée. GL_DECR La valeur du stencil est diminuée de 1 si elle est supérieure à la valeur minimale. GL_DECR_WRAP Identique à GL_DECR, mais l’enveloppe à la valeur maximale si elle est inférieure à 0. GL_INVERT Inverse dans le sens des bits la valeur actuelle de la mémoire tampon du stencil. Par défaut, la fonction glStencilOp est réglée sur (GL_KEEP, GL_KEEP, GL_KEEP), de sorte que, quel que soit le résultat des tests, le tampon du stencil conserve ses valeurs. Le comportement par défaut ne met pas à jour le tampon du stencil, donc si vous voulez écrire dans le tampon du stencil, vous devez spécifier au moins une action différente pour chacune des options.\nAinsi, en utilisant glStencilFunc et glStencilOp, nous pouvons spécifier précisément quand et comment nous voulons mettre à jour le stencil buffer et quand passer ou rejeter des fragments en fonction de son contenu.\nObject outlining (contour d’objet) Il est peu probable que vous ayez parfaitement compris le fonctionnement du test du stencil à partir des seules sections précédentes. Nous allons donc vous présenter une fonction particulièrement utile qui peut être mise en œuvre avec le seul test du stencil et qui s’appelle le contour d’objet ou object outlining. Le contournement d’objet fait exactement ce qu’il dit faire. Pour chaque objet (ou un seul), nous créons une petite bordure colorée autour des objets (combinés). Cet effet est particulièrement utile lorsque vous souhaitez sélectionner des unités dans un jeu de stratégie, par exemple, et que vous devez montrer à l’utilisateur quelles unités ont été sélectionnées. La routine pour délimiter vos objets est la suivante :\nActiver l’écriture au stencil. Mettre l’option stencil à GL_ALWAYS avant de dessiner les objets (à dessiner), en mettant à jour le tampon stencil avec des 1 chaque fois que les fragments des objets sont rendus. Effectuer le rendu des objets. Désactiver l’écriture du stencil et le test de profondeur. Modifiez légèrement l’échelle de chacun des objets. Utiliser un shader de fragment différent qui produit une seule couleur (de bordure). Dessiner à nouveau les objets, mais seulement si les valeurs de stencil de leurs fragments ne sont pas égales à 1. Activer à nouveau le test de profondeur et restaurer la fonction stencil à GL_KEEP. Ce processus définit le contenu du tampon de stencil à 1 pour chacun des fragments de l’objet et lorsqu’il est temps de dessiner les bordures, nous dessinons des versions agrandies des objets seulement là où le test de stencil est réussi. Nous rejetons effectivement tous les fragments des versions agrandies qui font partie des fragments des objets originaux en utilisant le tampon du stencil.\nNous allons donc commencer par créer un fragment shader très basique qui produit une couleur de bordure. Nous définissons simplement une valeur de couleur codée en dur et appelons le shader shaderSingleColor :\nvoid main() { FragColor = vec4(0.04, 0.28, 0.26, 1.0); } En utilisant la scène du chapitre précédent, nous allons ajouter un contour d’objet aux deux conteneurs, nous laisserons donc le sol en dehors de cela. Nous voulons d’abord dessiner le sol, puis les deux conteneurs (tout en écrivant dans le tampon du stencil), et enfin dessiner les conteneurs agrandis (tout en jetant les fragments qui écrivent sur les fragments de conteneurs précédemment dessinés).\nNous devons d’abord activer le test des stencil :\nglEnable(GL_STENCIL_TEST); Ensuite, pour chaque image, nous voulons spécifier l’action à entreprendre lorsque l’un des tests du stencil réussit ou échoue :\nglStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE); Si l’un des tests échoue, nous ne faisons rien ; nous conservons simplement la valeur actuellement stockée dans le tampon du stencil. Cependant, si le test du stencil et le test de profondeur réussissent, nous voulons remplacer la valeur du stencil stockée par la valeur de référence définie par glStencilFunc, que nous fixons ensuite à 1.\nAu début de l’image, la mémoire tampon du stencil est vidée et, pour les conteneurs, la mémoire tampon du stencil est mise à jour à 1 pour chaque fragment dessiné :\nglStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE); glStencilFunc(GL_ALWAYS, 1, 0xFF); // all fragments should pass the stencil test glStencilMask(0xFF); // enable writing to the stencil buffer normalShader.use(); DrawTwoContainers(); En utilisant GL_REPLACE comme op_function du stencil, nous nous assurons que chacun des fragments des conteneurs met à jour le tampon du stencil avec une valeur de stencil de 1. Comme les fragments passent toujours le test du stencil, le tampon du stencil est mis à jour avec la valeur de référence partout où nous les avons dessinés.\nMaintenant que le stencil buffer est mis à jour avec des 1 là où les conteneurs ont été dessinés, nous allons dessiner les conteneurs mis à l’échelle, mais cette fois avec la fonction de test appropriée et en désactivant les écritures dans le stencil buffer :\nglStencilFunc(GL_NOTEQUAL, 1, 0xFF); glStencilMask(0x00); // disable writing to the stencil buffer glDisable(GL_DEPTH_TEST); shaderSingleColor.use(); DrawTwoScaledUpContainers(); Nous définissons la fonction de stencil à GL_NOTEQUAL pour nous assurer que nous ne dessinons que les parties des conteneurs qui ne sont pas égales à 1. De cette façon, nous ne dessinons que la partie des conteneurs qui se trouve à l’extérieur des conteneurs précédemment dessinés. Notez que nous désactivons également le test de profondeur afin que les conteneurs mis à l’échelle (par exemple les bordures) ne soient pas écrasés par le sol. Veillez à réactiver le tampon de profondeur une fois que vous avez terminé.\nLa routine de contour d’objets pour notre scène ressemble à ceci :\nglEnable(GL_DEPTH_TEST); glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); glStencilMask(0x00); // make sure we don't update the stencil buffer while drawing the floor normalShader.use(); DrawFloor() glStencilFunc(GL_ALWAYS, 1, 0xFF); glStencilMask(0xFF); DrawTwoContainers(); glStencilFunc(GL_NOTEQUAL, 1, 0xFF); glStencilMask(0x00); glDisable(GL_DEPTH_TEST); shaderSingleColor.use(); DrawTwoScaledUpContainers(); glStencilMask(0xFF); glStencilFunc(GL_ALWAYS, 1, 0xFF); glEnable(GL_DEPTH_TEST); Tant que vous comprenez l’idée générale des tests de stencils, cela ne devrait pas être trop difficile à comprendre. Sinon, relisez attentivement les sections précédentes et essayez de comprendre complètement ce que fait chacune des fonctions, maintenant que vous avez vu un exemple de leur utilisation.\nLe résultat de l’algorithme de contour ressemble alors à ceci :\nConsultez le code source ici pour voir le code complet de l’algorithme de contour d’objet.\nVous pouvez voir que les contours se chevauchent entre les deux conteneurs, ce qui est généralement l’effet recherché (pensez aux jeux de stratégie dans lesquels nous voulons sélectionner 10 unités ; la fusion des contours est généralement préférée). Si vous voulez un contour complet par objet, vous devez effacer le tampon de stencil par objet et faire preuve d’un peu de créativité avec le tampon de profondeur.\n",
  "wordCount" : "2149",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/01_stencil_testing/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "hrst4's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hrst4.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hrst4.xyz/" accesskey="h" title="hrst4&#39;s blog (Alt + H)">hrst4&#39;s blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://hrst4.xyz/apropos" title="apropos">
                    <span>apropos</span>
                </a>
            </li>
            <li>
                <a href="https://hrst4.xyz/docs" title="docs">
                    <span>docs</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="stencil-testing">Stencil testing<a hidden class="anchor" aria-hidden="true" href="#stencil-testing">#</a></h1>
<p>Une fois que le shader de fragment a traité le fragment, un test de stencil est exécuté qui, tout comme le test de profondeur, a la possibilité d&rsquo;éliminer des fragments. Après cela, les fragments restants sont transmis au test de profondeur où OpenGL peut éventuellement rejeter encore plus de fragments. Le test de <strong>stencil</strong> (pochoir en français?) est basé sur le contenu d&rsquo;un autre tampon appelé tampon de stencil que nous sommes autorisés à mettre à jour pendant le rendu pour obtenir des effets intéressants.</p>
<p>Un tampon de stencil contient (généralement) 8 bits par valeur de stencil, ce qui représente un total de 256 valeurs de stencil différentes par pixel. Nous pouvons définir ces valeurs de stencil à notre convenance et nous pouvons écarter ou conserver des fragments lorsqu&rsquo;un fragment particulier a une certaine valeur de stencil.</p>
<blockquote>
<p>Chaque bibliothèque de fenêtrage doit mettre en place un tampon de stencil pour vous. GLFW le fait automatiquement, nous n&rsquo;avons donc pas besoin de lui dire d&rsquo;en créer un, mais d&rsquo;autres bibliothèques de fenêtrage peuvent ne pas créer de tampon de stencil par défaut, alors vérifiez la documentation de votre bibliothèque.</p>
</blockquote>
<p>Un exemple simple de tampon de stencil est illustré ci-dessous (les pixels ne sont pas à l&rsquo;échelle) :
<img src="/docs/LEARNOPENGL_FR/04_Advanced_OpenGL/stencil_buffer%201.png" alt="stencil_buffer 1"/>
Le stencil buffer est d&rsquo;abord vidé avec des zéros, puis un rectangle ouvert de <code>1</code> est stocké dans le stencil buffer. Les fragments de la scène ne sont alors rendus (les autres sont rejetés) que là où la valeur du stencil de ce fragment contient un <code>1</code>.</p>
<p>Les opérations sur le tampon de stencil nous permettent de fixer le tampon de stencil à des valeurs spécifiques partout où nous rendons des fragments. En changeant le contenu du tampon de stencil pendant le rendu, nous <em>écrivons</em> dans le tampon de stencil. Dans la même image (ou les suivantes), nous pouvons <em>lire</em> ces valeurs pour écarter ou passer certains fragments. Lors de l&rsquo;utilisation des tampons de stencil, vous pouvez être aussi fou que vous le souhaitez, mais les grandes lignes sont généralement les suivantes :</p>
<ul>
<li>Activer l&rsquo;écriture dans le tampon du stencil.</li>
<li>Rendre les objets, en mettant à jour le contenu de la mémoire tampon du stencil.</li>
<li>Désactiver l&rsquo;écriture dans le tampon du stencil.</li>
<li>Rendu des (autres) objets, cette fois en écartant certains fragments sur la base du contenu de la mémoire tampon du stencil.</li>
</ul>
<p>L&rsquo;utilisation de la mémoire tampon du stencil permet d&rsquo;écarter certains fragments en fonction des fragments d&rsquo;autres objets dessinés dans la scène.</p>
<p>Vous pouvez activer le test du stencil en activant <code>GL_STENCIL_TEST</code>. À partir de ce moment, tous les appels de rendu influenceront le tampon du stencil d&rsquo;une manière ou d&rsquo;une autre.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glEnable(GL_STENCIL_TEST);    
</span></span></code></pre></div><p>Notez que vous devez également effacer le tampon du stencil à chaque itération, tout comme les tampons de couleur et de profondeur :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glClear(GL_COLOR_BUFFER_BIT <span style="color:#f92672">|</span> GL_DEPTH_BUFFER_BIT <span style="color:#f92672">|</span> GL_STENCIL_BUFFER_BIT); 
</span></span></code></pre></div><p>De même, tout comme la fonction <code>glDepthMask</code> du test de profondeur, il existe une fonction équivalente pour le tampon du stencil. La fonction <code>glStencilMask</code> nous permet de définir un masque de bits qui est <em>ANDed</em> avec la valeur du stencil sur le point d&rsquo;être écrite dans le tampon. Par défaut, ce masque est constitué de tous les 1 qui n&rsquo;affectent pas la sortie, mais si nous le fixons à <code>0x00</code>, toutes les valeurs de stencil écrites dans le tampon se retrouveront sous forme de 0. C&rsquo;est l&rsquo;équivalent du masque de profondeur <code>glDepthMask(GL_FALSE)</code> du test de profondeur :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glStencilMask(<span style="color:#ae81ff">0xFF</span>); <span style="color:#75715e">// each bit is written to the stencil buffer as is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glStencilMask(<span style="color:#ae81ff">0x00</span>); <span style="color:#75715e">// each bit ends up as 0 in the stencil buffer (disabling writes)
</span></span></span></code></pre></div><p>Dans la plupart des cas, vous n&rsquo;utiliserez que <code>0x00</code> ou <code>0xFF</code> comme masque de stencil, mais il est bon de savoir qu&rsquo;il existe des options permettant de définir des masques de bits personnalisés.</p>
<h2 id="fonctions-stencil">Fonctions Stencil<a hidden class="anchor" aria-hidden="true" href="#fonctions-stencil">#</a></h2>
<p>Comme pour les tests de profondeur, nous avons un certain contrôle sur le moment où un test de stencil doit réussir ou échouer et sur la manière dont il doit affecter le tampon de stencil. Il existe au total deux fonctions que nous pouvons utiliser pour configurer les tests de stencil : <code>glStencilFunc</code> et <code>glStencilOp</code>.</p>
<p>La fonction <code>glStencilFunc(GLenum func, GLint ref, GLuint mask)</code> a trois paramètres :</p>
<ul>
<li><code>func</code> : définit la fonction de test du stencil qui détermine si un fragment est accepté ou rejeté. Cette fonction de test est appliquée à la valeur de stencil stockée et à la valeur <code>ref</code> de <code>glStencilFunc</code>. Les options possibles sont : <code>GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, GL_ALWAYS</code>. Leur signification sémantique est similaire à celle des fonctions du tampon de profondeur.</li>
<li><code>ref</code> : spécifie la valeur de référence pour le test du stencil. Le contenu de la mémoire tampon du stencil est comparé à cette valeur.</li>
<li><code>mask</code> : spécifie un masque qui est <code>ANDed</code> avec la valeur de référence et la valeur de stencil stockée avant que le test ne les compare. Initialement, toutes les valeurs sont à <code>1</code>.</li>
</ul>
<p>Ainsi, dans le cas de l&rsquo;exemple simple du stencil que nous avons montré au début, la fonction serait réglée sur :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glStencilFunc(GL_EQUAL, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0xFF</span>)
</span></span></code></pre></div><p>Cela indique à OpenGL qu&rsquo;à chaque fois que la valeur du stencil d&rsquo;un fragment est égale (<code>GL_EQUAL</code>) à la valeur de référence 1, le fragment passe le test et est dessiné, sinon il est rejeté.</p>
<p>Mais <code>glStencilFunc</code> décrit seulement si OpenGL doit accepter ou rejeter les fragments en se basant sur le contenu du tampon de stencil, mais pas comment nous pouvons réellement mettre à jour le tampon. C&rsquo;est là que <code>glStencilOp</code> entre en jeu.</p>
<p>La commande <code>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)</code> contient trois options parmi lesquelles nous pouvons spécifier pour chaque option l&rsquo;action à entreprendre :</p>
<p><code>sfail</code> : action à entreprendre si le test du stencil échoue.<br>
<code>dpfail</code> : action à entreprendre si le test du stencil réussit, mais que le test de profondeur échoue.<br>
<code>dppass</code> : action à entreprendre si le test du stencil et le test de profondeur sont tous deux réussis.</p>
<p>Ensuite, pour chacune des options, vous pouvez entreprendre l&rsquo;une des actions suivantes :</p>
<table>
<thead>
<tr>
<th>ACTION</th>
<th>DESCRIPTION</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GL_KEEP</code></td>
<td>La valeur du stencil actuellement enregistrée est conservée.</td>
</tr>
<tr>
<td><code>GL_ZERO</code></td>
<td>La valeur du stencil est fixée à 0.</td>
</tr>
<tr>
<td><code>GL_REPLACE</code></td>
<td>La valeur du stencil est remplacée par la valeur de référence définie avec glStencilFunc.</td>
</tr>
<tr>
<td><code>GL_INCR</code></td>
<td>La valeur du stencil est augmentée de 1 si elle est inférieure à la valeur maximale.</td>
</tr>
<tr>
<td><code>GL_INCR_WRAP</code></td>
<td>Identique à GL_INCR, mais le ramène à 0 dès que la valeur maximale est dépassée.</td>
</tr>
<tr>
<td><code>GL_DECR</code></td>
<td>La valeur du stencil est diminuée de 1 si elle est supérieure à la valeur minimale.</td>
</tr>
<tr>
<td><code>GL_DECR_WRAP</code></td>
<td>Identique à GL_DECR, mais l&rsquo;enveloppe à la valeur maximale si elle est inférieure à 0.</td>
</tr>
<tr>
<td><code>GL_INVERT</code></td>
<td>Inverse dans le sens des bits la valeur actuelle de la mémoire tampon du stencil.</td>
</tr>
</tbody>
</table>
<p>Par défaut, la fonction <code>glStencilOp</code> est réglée sur (<code>GL_KEEP, GL_KEEP, GL_KEEP</code>), <strong>de sorte que, quel que soit le résultat des tests, le tampon du stencil conserve ses valeurs</strong>. Le comportement par défaut ne met pas à jour le tampon du stencil, donc si vous voulez écrire dans le tampon du stencil, vous devez spécifier au moins une action différente pour chacune des options.</p>
<p>Ainsi, en utilisant <code>glStencilFunc</code> et <code>glStencilOp</code>, nous pouvons spécifier précisément quand et comment nous voulons mettre à jour le stencil buffer et quand passer ou rejeter des fragments en fonction de son contenu.</p>
<h2 id="object-outlining-contour-dobjet">Object outlining (contour d&rsquo;objet)<a hidden class="anchor" aria-hidden="true" href="#object-outlining-contour-dobjet">#</a></h2>
<p>Il est peu probable que vous ayez parfaitement compris le fonctionnement du test du stencil à partir des seules sections précédentes. Nous allons donc vous présenter une fonction particulièrement utile qui peut être mise en œuvre avec le seul test du stencil et qui s&rsquo;appelle le contour d&rsquo;objet ou <strong>object outlining</strong>.
<img src="/docs/LEARNOPENGL_FR/04_Advanced_OpenGL/stencil_object_outlining.png" alt="stencil_object_outlining"/></p>
<p>Le contournement d&rsquo;objet fait exactement ce qu&rsquo;il dit faire. Pour chaque objet (ou un seul), nous créons une petite bordure colorée autour des objets (combinés). Cet effet est particulièrement utile lorsque vous souhaitez sélectionner des unités dans un jeu de stratégie, par exemple, et que vous devez montrer à l&rsquo;utilisateur quelles unités ont été sélectionnées. La routine pour délimiter vos objets est la suivante :</p>
<ol>
<li>Activer l&rsquo;écriture au stencil.</li>
<li>Mettre l&rsquo;option stencil à <code>GL_ALWAYS</code> avant de dessiner les objets (à dessiner), en mettant à jour le tampon stencil avec des <code>1</code> chaque fois que les fragments des objets sont rendus.</li>
<li>Effectuer le rendu des objets.</li>
<li>Désactiver l&rsquo;écriture du stencil et le test de profondeur.</li>
<li>Modifiez légèrement l&rsquo;échelle de chacun des objets.</li>
<li>Utiliser un shader de fragment différent qui produit une seule couleur (de bordure).</li>
<li>Dessiner à nouveau les objets, mais seulement si les valeurs de stencil de leurs fragments ne sont pas égales à <code>1</code>.</li>
<li>Activer à nouveau le test de profondeur et restaurer la fonction stencil à <code>GL_KEEP</code>.</li>
</ol>
<p>Ce processus définit le contenu du tampon de stencil à <code>1</code> pour chacun des fragments de l&rsquo;objet et lorsqu&rsquo;il est temps de dessiner les bordures, nous dessinons des versions agrandies des objets seulement là où le test de stencil est réussi. Nous rejetons effectivement tous les fragments des versions agrandies qui font partie des fragments des objets originaux en utilisant le tampon du stencil.</p>
<p>Nous allons donc commencer par créer un fragment shader très basique qui produit une couleur de bordure. Nous définissons simplement une valeur de couleur codée en dur et appelons le shader <code>shaderSingleColor</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> vec4(<span style="color:#ae81ff">0.04</span>, <span style="color:#ae81ff">0.28</span>, <span style="color:#ae81ff">0.26</span>, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>En utilisant la scène du chapitre précédent, nous allons ajouter un contour d&rsquo;objet aux deux conteneurs, nous laisserons donc le sol en dehors de cela. Nous voulons d&rsquo;abord dessiner le sol, puis les deux conteneurs (tout en écrivant dans le tampon du stencil), et enfin dessiner les conteneurs agrandis (tout en jetant les fragments qui écrivent sur les fragments de conteneurs précédemment dessinés).</p>
<p>Nous devons d&rsquo;abord activer le test des stencil :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glEnable(GL_STENCIL_TEST);
</span></span></code></pre></div><p>Ensuite, pour chaque image, nous voulons spécifier l&rsquo;action à entreprendre lorsque l&rsquo;un des tests du stencil réussit ou échoue :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);  
</span></span></code></pre></div><p>Si l&rsquo;un des tests échoue, nous ne faisons rien ; nous conservons simplement la valeur actuellement stockée dans le tampon du stencil. Cependant, si le test du stencil et le test de profondeur réussissent, nous voulons remplacer la valeur du stencil stockée par la valeur de référence définie par <code>glStencilFunc</code>, que nous fixons ensuite à 1.</p>
<p>Au début de l&rsquo;image, la mémoire tampon du stencil est vidée et, pour les conteneurs, la mémoire tampon du stencil est mise à jour à 1 pour chaque fragment dessiné :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);  
</span></span><span style="display:flex;"><span>glStencilFunc(GL_ALWAYS, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0xFF</span>); <span style="color:#75715e">// all fragments should pass the stencil test
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glStencilMask(<span style="color:#ae81ff">0xFF</span>); <span style="color:#75715e">// enable writing to the stencil buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>normalShader.use();
</span></span><span style="display:flex;"><span>DrawTwoContainers();
</span></span></code></pre></div><p>En utilisant <code>GL_REPLACE</code> comme <code>op_function</code> du stencil, nous nous assurons que chacun des fragments des conteneurs met à jour le tampon du stencil avec une valeur de stencil de 1. Comme les fragments passent toujours le test du stencil, le tampon du stencil est mis à jour avec la valeur de référence partout où nous les avons dessinés.</p>
<p>Maintenant que le stencil buffer est mis à jour avec des 1 là où les conteneurs ont été dessinés, nous allons dessiner les conteneurs mis à l&rsquo;échelle, mais cette fois avec la fonction de test appropriée et en désactivant les écritures dans le stencil buffer :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glStencilFunc(GL_NOTEQUAL, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0xFF</span>);
</span></span><span style="display:flex;"><span>glStencilMask(<span style="color:#ae81ff">0x00</span>); <span style="color:#75715e">// disable writing to the stencil buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glDisable(GL_DEPTH_TEST);
</span></span><span style="display:flex;"><span>shaderSingleColor.use(); 
</span></span><span style="display:flex;"><span>DrawTwoScaledUpContainers();
</span></span></code></pre></div><p>Nous définissons la fonction de stencil à <code>GL_NOTEQUAL</code> pour nous assurer que nous ne dessinons que les parties des conteneurs qui ne sont pas égales à 1. De cette façon, nous ne dessinons que la partie des conteneurs qui se trouve à l&rsquo;extérieur des conteneurs précédemment dessinés. Notez que nous désactivons également le test de profondeur afin que les conteneurs mis à l&rsquo;échelle (par exemple les bordures) ne soient pas écrasés par le sol. Veillez à réactiver le tampon de profondeur une fois que vous avez terminé.</p>
<p>La routine de contour d&rsquo;objets pour notre scène ressemble à ceci :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glEnable(GL_DEPTH_TEST);
</span></span><span style="display:flex;"><span>glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>glClear(GL_COLOR_BUFFER_BIT <span style="color:#f92672">|</span> GL_DEPTH_BUFFER_BIT <span style="color:#f92672">|</span> GL_STENCIL_BUFFER_BIT); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>glStencilMask(<span style="color:#ae81ff">0x00</span>); <span style="color:#75715e">// make sure we don&#39;t update the stencil buffer while drawing the floor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>normalShader.use();
</span></span><span style="display:flex;"><span>DrawFloor()  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>glStencilFunc(GL_ALWAYS, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0xFF</span>); 
</span></span><span style="display:flex;"><span>glStencilMask(<span style="color:#ae81ff">0xFF</span>); 
</span></span><span style="display:flex;"><span>DrawTwoContainers();
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>glStencilFunc(GL_NOTEQUAL, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0xFF</span>);
</span></span><span style="display:flex;"><span>glStencilMask(<span style="color:#ae81ff">0x00</span>); 
</span></span><span style="display:flex;"><span>glDisable(GL_DEPTH_TEST);
</span></span><span style="display:flex;"><span>shaderSingleColor.use(); 
</span></span><span style="display:flex;"><span>DrawTwoScaledUpContainers();
</span></span><span style="display:flex;"><span>glStencilMask(<span style="color:#ae81ff">0xFF</span>);
</span></span><span style="display:flex;"><span>glStencilFunc(GL_ALWAYS, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0xFF</span>);   
</span></span><span style="display:flex;"><span>glEnable(GL_DEPTH_TEST);  
</span></span></code></pre></div><p>Tant que vous comprenez l&rsquo;idée générale des tests de stencils, cela ne devrait pas être trop difficile à comprendre. Sinon, relisez attentivement les sections précédentes et essayez de comprendre complètement ce que fait chacune des fonctions, maintenant que vous avez vu un exemple de leur utilisation.</p>
<p>Le résultat de l&rsquo;algorithme de contour ressemble alors à ceci :</p>
<p><img src="/docs/LEARNOPENGL_FR/04_Advanced_OpenGL/stencil_scene_outlined%201.png" alt="stencil_scene_outlined 1"/>
Consultez le code source <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/2.stencil_testing/stencil_testing.cpp">ici</a> pour voir le code complet de l&rsquo;algorithme de contour d&rsquo;objet.</p>
<p>Vous pouvez voir que les contours se chevauchent entre les deux conteneurs, ce qui est généralement l&rsquo;effet recherché (pensez aux jeux de stratégie dans lesquels nous voulons sélectionner 10 unités ; la fusion des contours est généralement préférée). Si vous voulez un contour complet par objet, vous devez effacer le tampon de stencil par objet et faire preuve d&rsquo;un peu de créativité avec le tampon de profondeur.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hrst4.xyz/">hrst4&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
