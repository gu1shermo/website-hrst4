<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>hrst4&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="GLSL avancé Ce chapitre ne vous montrera pas vraiment de nouvelles fonctionnalités super avancées qui donneront un énorme coup de pouce à la qualité visuelle de votre scène. Ce chapitre aborde plus ou moins des aspects intéressants de GLSL et des astuces qui peuvent vous aider dans vos projets futurs. En gros, quelques bonnes choses à savoir et des fonctionnalités qui peuvent vous faciliter la vie lorsque vous créez des applications OpenGL en combinaison avec GLSL.">
<meta name="author" content="">
<link rel="canonical" href="https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/07_advanced_glsl/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://hrst4.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hrst4.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hrst4.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hrst4.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://hrst4.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="GLSL avancé Ce chapitre ne vous montrera pas vraiment de nouvelles fonctionnalités super avancées qui donneront un énorme coup de pouce à la qualité visuelle de votre scène. Ce chapitre aborde plus ou moins des aspects intéressants de GLSL et des astuces qui peuvent vous aider dans vos projets futurs. En gros, quelques bonnes choses à savoir et des fonctionnalités qui peuvent vous faciliter la vie lorsque vous créez des applications OpenGL en combinaison avec GLSL." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/07_advanced_glsl/" /><meta property="article:section" content="docs" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="GLSL avancé Ce chapitre ne vous montrera pas vraiment de nouvelles fonctionnalités super avancées qui donneront un énorme coup de pouce à la qualité visuelle de votre scène. Ce chapitre aborde plus ou moins des aspects intéressants de GLSL et des astuces qui peuvent vous aider dans vos projets futurs. En gros, quelques bonnes choses à savoir et des fonctionnalités qui peuvent vous faciliter la vie lorsque vous créez des applications OpenGL en combinaison avec GLSL."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "",
      "item": "https://hrst4.xyz/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/07_advanced_glsl/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "GLSL avancé Ce chapitre ne vous montrera pas vraiment de nouvelles fonctionnalités super avancées qui donneront un énorme coup de pouce à la qualité visuelle de votre scène. Ce chapitre aborde plus ou moins des aspects intéressants de GLSL et des astuces qui peuvent vous aider dans vos projets futurs. En gros, quelques bonnes choses à savoir et des fonctionnalités qui peuvent vous faciliter la vie lorsque vous créez des applications OpenGL en combinaison avec GLSL.",
  "keywords": [
    
  ],
  "articleBody": "GLSL avancé Ce chapitre ne vous montrera pas vraiment de nouvelles fonctionnalités super avancées qui donneront un énorme coup de pouce à la qualité visuelle de votre scène. Ce chapitre aborde plus ou moins des aspects intéressants de GLSL et des astuces qui peuvent vous aider dans vos projets futurs. En gros, quelques bonnes choses à savoir et des fonctionnalités qui peuvent vous faciliter la vie lorsque vous créez des applications OpenGL en combinaison avec GLSL.\nNous discuterons de quelques variables intégrées intéressantes, de nouvelles façons d’organiser l’entrée et la sortie des shaders, et d’un outil très utile appelé objets tampons uniformes.\nLes variables intégrées de GLSL (built-in variables) Les shaders sont très complexes, et si nous avons besoin de données provenant d’une autre source que le shader en cours, nous devrons les faire circuler. Nous avons appris à le faire via les attributs de vertex, les uniformes et les samplers. Il existe cependant quelques variables supplémentaires définies par GLSL et préfixées par gl_ qui nous donnent un moyen supplémentaire de collecter et/ou d’écrire des données. Nous en avons déjà vu deux dans les chapitres précédents : gl_Position qui est le vecteur de sortie du vertex shader, et gl_FragCoord du fragment shader.\nNous allons discuter de quelques variables d’entrée et de sortie intégrées intéressantes qui sont intégrées dans GLSL et expliquer comment elles peuvent nous être utiles. Notez que nous ne parlerons pas de toutes les variables intégrées qui existent dans GLSL, donc si vous voulez voir toutes les variables intégrées, vous pouvez consulter le wiki d’OpenGL.\nVariables du vertex shader Nous avons déjà vu gl_Position qui est le vecteur de position de sortie de l’espace-clip du vertex shader. Définir gl_Position dans le vertex shader est une exigence stricte si vous voulez rendre quoi que ce soit à l’écran. Rien que nous n’ayons déjà vu auparavant.\ngl_PointSize L’une des primitives de rendu que nous pouvons choisir est GL_POINTS. Dans ce cas, chaque vertex est une primitive et est rendu comme un point. Il est possible de définir la taille des points rendus via la fonction glPointSize d’OpenGL, mais nous pouvons également influencer cette valeur dans le shader de vertex.\nUne variable de sortie définie par GLSL est appelée gl_PointSize. Il s’agit d’une variable flottante dans laquelle vous pouvez définir la largeur et la hauteur du point en pixels. En définissant la taille du point dans le shader de sommets, nous obtenons un contrôle par sommet sur les dimensions de ce point.\nL’influence sur la taille des points dans le vertex shader est désactivée par défaut, mais si vous souhaitez l’activer, vous devez activer la fonction GL_PROGRAM_POINT_SIZE d’OpenGL :\nglEnable(GL_PROGRAM_POINT_SIZE); Un exemple simple d’influence sur la taille des points consiste à définir une taille de point égale à la valeur z de la position de l’espace-clip, qui est égale à la distance du sommet par rapport à l’observateur. La taille du point devrait alors augmenter au fur et à mesure que l’on s’éloigne des sommets de l’observateur.\nvoid main() { gl_Position = projection * view * model * vec4(aPos, 1.0); gl_PointSize = gl_Position.z; } Le résultat est que les points que nous avons dessinés sont rendus plus grands au fur et à mesure que nous nous en éloignons : Vous pouvez imaginer que la variation de la taille des points par vertex est intéressante pour des techniques telles que la génération de particules.\ngl_VertexID Les variables gl_Position et gl_PointSize sont des variables de sortie puisque leur valeur est lue par le vertex shader ; nous pouvons influencer le résultat en y écrivant. Le vertex shader nous fournit également une variable d’entrée intéressante, que nous ne pouvons que lire, appelée gl_VertexID.\nLa variable entière gl_VertexID contient l’identifiant actuel du sommet que nous sommes en train de dessiner. Lors d’un rendu indexé (avec glDrawElements), cette variable contient l’index actuel du sommet que nous dessinons. Lors d’un dessin sans index (via glDrawArrays), cette variable contient le numéro du sommet en cours de traitement depuis le début de l’appel au rendu.\nVariables du fragment shader Dans le fragment shader, nous avons également accès à quelques variables intéressantes. GLSL nous donne deux variables d’entrée intéressantes appelées gl_FragCoord et gl_FrontFacing.\ngl_FragCoord Nous avons déjà vu le vecteur gl_FragCoord à plusieurs reprises au cours de la discussion sur les tests de profondeur, car la composante z du vecteur gl_FragCoord est égale à la valeur de profondeur de ce fragment particulier. Cependant, nous pouvons également utiliser les composantes x et y de ce vecteur pour obtenir des effets intéressants.\nLes composantes x et y du vecteur gl_FragCoord sont les coordonnées du fragment dans l’espace de la fenêtre ou de l’écran, à partir de la partie inférieure gauche de la fenêtre. Nous avons spécifié une fenêtre de rendu de 800x600 avec glViewport, de sorte que les coordonnées de l’espace-écran du fragment auront des valeurs x comprises entre 0 et 800, et des valeurs y comprises entre 0 et 600.\nEn utilisant le shader de fragment, nous pouvons calculer une valeur de couleur différente en fonction des coordonnées d’écran du fragment. La variable gl_FragCoord est couramment utilisée pour comparer les résultats visuels de différents calculs de fragments, comme on le voit généralement dans les démonstrations techniques. Nous pourrions par exemple diviser l’écran en deux en rendant une sortie sur le côté gauche de la fenêtre et une autre sur le côté droit de la fenêtre. Un exemple de shader de fragment qui produit une couleur différente en fonction des coordonnées du fragment à l’écran est donné ci-dessous :\nvoid main() { if(gl_FragCoord.x \u003c 400) FragColor = vec4(1.0, 0.0, 0.0, 1.0); else FragColor = vec4(0.0, 1.0, 0.0, 1.0); } Comme la largeur de la fenêtre est égale à 800, chaque fois que la coordonnée x d’un pixel est inférieure à 400, il doit se trouver à gauche de la fenêtre et nous donnerons à ce fragment une couleur différente.\nNous pouvons maintenant calculer deux résultats de fragment shader complètement différents et les afficher chacun d’un côté différent de la fenêtre. C’est idéal pour tester différentes techniques d’éclairage, par exemple.\n``gl_FrontFacing` Une autre variable d’entrée intéressante dans le fragment shader est la variable gl_FrontFacing. Dans le chapitre sur l’élimination des faces, nous avons mentionné qu’OpenGL est capable de déterminer si une face est une face avant ou arrière en raison de l’ordre d’enroulement des sommets. La variable gl_FrontFacing nous indique si le fragment courant fait partie d’une face avant ou arrière. Nous pourrions, par exemple, décider de produire des couleurs différentes pour toutes les faces arrière.\nLa variable gl_FrontFacing est un bool qui vaut true si le fragment fait partie d’une face avant et false dans le cas contraire. Nous pouvons créer un cube de cette manière avec une texture différente à l’intérieur et à l’extérieur :\n#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D frontTexture; uniform sampler2D backTexture; void main() { if(gl_FrontFacing) FragColor = texture(frontTexture, TexCoords); else FragColor = texture(backTexture, TexCoords); } Si nous jetons un coup d’œil à l’intérieur du conteneur, nous constatons qu’une texture différente est utilisée. Notez que si vous avez activé l’élimination des faces, vous ne pourrez pas voir les faces à l’intérieur du conteneur et l’utilisation de gl_FrontFacing serait alors inutile.\ngl_FragDepth La variable d’entrée gl_FragCoord est une variable d’entrée qui nous permet de lire les coordonnées de l’espace-écran et d’obtenir la valeur de la profondeur du fragment actuel, mais il s’agit d’une variable en lecture seule. Nous ne pouvons pas influencer les coordonnées de l’espace-écran du fragment, mais il est possible de définir la valeur de la profondeur du fragment. GLSL nous donne une variable de sortie appelée gl_FragDepth que nous pouvons utiliser pour définir manuellement la valeur de profondeur du fragment dans le shader.\nPour définir la valeur de la profondeur dans le shader, nous écrivons n’importe quelle valeur entre 0,0 et 1,0 dans la variable de sortie :\ngl_FragDepth = 0.0; // this fragment now has a depth value of 0.0 Si le shader n’écrit rien dans gl_FragDepth, la variable prendra automatiquement sa valeur dans gl_FragCoord.z.\nDéfinir manuellement la valeur de la profondeur présente cependant un inconvénient majeur. En effet, OpenGL désactive le test de profondeur anticipé (tel que discuté dans le chapitre sur le test de profondeur) dès que nous écrivons dans gl_FragDepth dans le fragment shader. Il est désactivé parce qu’OpenGL ne peut pas savoir quelle valeur de profondeur aura le fragment avant de lancer le shader de fragment, puisque le shader de fragment peut en fait changer cette valeur.\nEn écrivant dans gl_FragDepth, vous devez prendre en compte cette pénalité de performance. A partir d’OpenGL 4.2 cependant, nous pouvons encore faire une sorte de médiation entre les deux côtés en redéclarant la variable gl_FragDepth au début du fragment shader avec une condition de profondeur :\nlayout (depth_\u003ccondition\u003e) out float gl_FragDepth; Cette condition peut prendre les valeurs suivantes :\nCondition Description any Valeur par défaut. Le test de profondeur précoce est désactivé. greater Vous pouvez seulement augmenter la valeur de la profondeur par rapport à gl_FragCoord.z. less Vous ne pouvez que réduire la valeur de la profondeur par rapport à gl_FragCoord.z. unchanged Si vous écrivez dans gl_FragDepth, vous écrirez exactement gl_FragCoord.z. En spécifiant supérieur ou inférieur comme condition de profondeur, OpenGL peut supposer que vous n’écrirez que des valeurs de profondeur plus grandes ou plus petites que la valeur de profondeur du fragment. De cette manière, OpenGL est toujours capable de tester la profondeur lorsque la valeur du tampon de profondeur fait partie de l’autre direction de gl_FragCoord.z. Un exemple où nous augmentons la valeur de profondeur dans le fragment shader, mais où nous voulons encore préserver une partie du test de profondeur précoce est montré dans le fragment shader ci-dessous :\n#version 420 core // note the GLSL version! out vec4 FragColor; layout (depth_greater) out float gl_FragDepth; void main() { FragColor = vec4(1.0); gl_FragDepth = gl_FragCoord.z + 0.1; } Notez que cette fonctionnalité n’est disponible qu’à partir de la version 4.2 d’OpenGL.\nBlocs d’interface Nous utilisons OpenGL depuis un certain temps maintenant et avons appris quelques trucs sympas, mais aussi quelques désagréments. Par exemple, lorsque nous utilisons plus d’un shader, nous devons continuellement définir des variables uniformes dont la plupart sont exactement les mêmes pour chaque shader.\nOpenGL nous offre un outil appelé objets tampons uniformes (uniform buffer objects) qui nous permet de déclarer un ensemble de variables uniformes globales qui restent les mêmes quel que soit le nombre de programmes de shaders. En utilisant les objets tampons uniformes, nous définissons les uniformes pertinents une seule fois dans la mémoire fixe du GPU. Il reste cependant nécessaire de définir manuellement les uniformes qui sont uniques pour chaque shader. La création et la configuration d’un objet tampon uniforme nécessitent toutefois un peu de travail.\nParce qu’un objet tampon uniforme est un tampon comme les autres, nous pouvons en créer un via glGenBuffers, le lier à la cible tampon GL_UNIFORM_BUFFER et stocker toutes les données uniformes pertinentes dans le tampon. Il existe certaines règles quant à la manière dont les données des objets tampons uniformes doivent être stockées, nous y reviendrons plus tard. Tout d’abord, nous allons prendre un simple vertex shader et stocker notre projection et notre matrice de vue dans ce que l’on appelle un bloc uniforme :\n#version 330 core layout (location = 0) in vec3 aPos; layout (std140) uniform Matrices { mat4 projection; mat4 view; }; uniform mat4 model; void main() { gl_Position = projection * view * model * vec4(aPos, 1.0); } Dans la plupart de nos exemples, nous définissons une matrice uniforme de projection et de vue à chaque image pour chaque shader que nous utilisons. C’est un exemple parfait de l’utilité des objets tampons uniformes puisque nous n’avons plus qu’à stocker ces matrices une seule fois.\nIci, nous avons déclaré un bloc uniforme appelé Matrices qui stocke deux matrices 4x4. Les variables d’un bloc uniforme sont directement accessibles sans le nom du bloc comme préfixe. Ensuite, nous stockons ces valeurs de matrices dans un tampon quelque part dans le code OpenGL et chaque shader qui déclare ce bloc uniforme a accès aux matrices.\nVous vous demandez probablement ce que signifie l’énoncé layout (std140). Cela signifie que le bloc uniforme actuellement défini utilise une disposition de mémoire spécifique pour son contenu ; cette déclaration définit la disposition du bloc uniforme.\nDisposition uniforme des blocs Le contenu d’un bloc uniforme est stocké dans un objet tampon, qui n’est rien d’autre qu’un morceau réservé de la mémoire globale du GPU. Parce que ce morceau de mémoire ne contient aucune information sur le type de données qu’il contient, nous devons dire à OpenGL quelles parties de la mémoire correspondent à quelles variables uniformes dans le shader.\nImaginez le bloc uniforme suivant dans un shader :\nlayout (std140) uniform ExampleBlock { float value; vec3 vector; mat4 matrix; float values[3]; bool boolean; int integer; }; Ce que nous voulons savoir, c’est la taille (en octets) et le décalage (depuis le début du bloc) de chacune de ces variables afin de pouvoir les placer dans le tampon dans leur ordre respectif. La taille de chacun des éléments est clairement indiquée dans OpenGL et correspond directement aux types de données C++ ; les vecteurs et les matrices étant de (grands) tableaux de flottants. Ce qu’OpenGL n’indique pas clairement, c’est l’espacement entre les variables. Cela permet au matériel de positionner ou de remplir les variables comme il l’entend. Le matériel est capable de placer un vec3 à côté d’un float par exemple. Tous les matériels ne peuvent pas gérer cela et remplacent le vec3 par un tableau de 4 flottants avant d’ajouter le flottant. C’est une fonctionnalité intéressante, mais peu pratique pour nous.\nPar défaut, GLSL utilise une disposition uniforme de la mémoire appelée disposition partagée (shared layout)- partagée parce qu’une fois que les décalages sont définis par le matériel, ils sont partagés de manière cohérente entre plusieurs programmes. Avec une disposition partagée, GLSL est autorisé à repositionner les variables uniformes à des fins d’optimisation, tant que l’ordre des variables reste intact. Comme nous ne savons pas à quel décalage chaque variable uniforme se trouvera, nous ne savons pas comment remplir précisément notre tampon uniforme. Nous pouvons interroger cette information avec des fonctions comme glGetUniformIndices, mais ce n’est pas l’approche que nous allons adopter dans ce chapitre.\nBien qu’une disposition partagée nous permette d’économiser de l’espace, nous devrions interroger l’offset pour chaque variable uniforme, ce qui représente beaucoup de travail. La pratique générale consiste cependant à ne pas utiliser la disposition partagée, mais à utiliser la disposition std140. La disposition std140 indique explicitement la disposition de la mémoire pour chaque type de variable en normalisant leurs décalages respectifs régis par un ensemble de règles. Puisque cette disposition est normalisée, nous pouvons déterminer manuellement les décalages pour chaque variable.\nChaque variable a un alignement de base égal à l’espace qu’une variable prend (y compris le remplissage) dans un bloc uniforme en utilisant les règles de disposition std140. Pour chaque variable, nous calculons son décalage aligné : le décalage en octets d’une variable par rapport au début du bloc. Le décalage d’octet aligné d’une variable doit être égal à un multiple de son alignement de base. C’est un peu compliqué, mais nous verrons bientôt des exemples pour clarifier les choses.\nLes règles exactes de mise en page peuvent être trouvées dans la spécification de tampon uniforme d’OpenGL ici, mais nous allons énumérer les règles les plus courantes ci-dessous. Chaque type de variable en GLSL, comme int, float et bool, est défini comme une quantité de quatre octets, chaque entité de 4 octets étant représentée par N.\nType Règle de Layout Scalaire (int ou float) Chaque scalaire a un alignement de base de N. Vector Soit 2N, soit 4N. Cela signifie qu’un vec3 a un alignement de base de 4N. Tableau de scalaires ou de Vectors Chaque élément a un alignement de base égal à celui d’un vec4. Matrices Stocké sous la forme d’un grand tableau de vecteurs de colonnes, où chacun de ces vecteurs a un alignement de base de vec4. Struct Égale à la taille calculée de ses éléments selon les règles précédentes, mais remplie d’un multiple de la taille d’un vec4. Comme la plupart des spécifications d’OpenGL, il est plus facile de comprendre avec un exemple. Nous prenons le bloc uniforme appelé ExampleBlock que nous avons présenté plus tôt et nous calculons le décalage aligné pour chacun de ses membres en utilisant la disposition std140 : layout (std140) uniform ExampleBlock { // base alignment // aligned offset float value; // 4 // 0 vec3 vector; // 16 // 16 (offset must be multiple of 16 so 4-\u003e16) mat4 matrix; // 16 // 32 (column 0) // 16 // 48 (column 1) // 16 // 64 (column 2) // 16 // 80 (column 3) float values[3]; // 16 // 96 (values[0]) // 16 // 112 (values[1]) // 16 // 128 (values[2]) bool boolean; // 4 // 144 int integer; // 4 // 148 }; À titre d’exercice, essayez de calculer vous-même les valeurs de décalage et comparez-les à ce tableau. Avec ces valeurs de décalage calculées, basées sur les règles de la disposition std140, nous pouvons remplir le tampon avec des données aux décalages appropriés en utilisant des fonctions comme glBufferSubData. Bien qu’elle ne soit pas la plus efficace, la disposition std140 nous garantit que la disposition de la mémoire reste la même pour chaque programme qui a déclaré ce bloc uniforme.\nEn ajoutant la déclaration layout (std140) dans la définition du bloc uniforme, nous indiquons à OpenGL que ce bloc uniforme utilise la disposition std140. Il y a deux autres dispositions à choisir qui nous obligent à interroger chaque décalage avant de remplir les tampons. Nous avons déjà vu la disposition partagée, l’autre disposition restante étant emballée (packed). Lorsque l’on utilise le layout packed, il n’y a aucune garantie que le layout reste le même entre les programmes (non partagé) car il permet au compilateur d’optimiser les variables uniformes loin du bloc uniforme qui peut être différent pour chaque shader.\nUtilisation de tampons uniformes Nous avons défini les blocs uniformes et spécifié leur disposition en mémoire, mais nous n’avons pas encore discuté de la manière de les utiliser.\nTout d’abord, nous devons créer un objet tampon uniforme, ce qui se fait via le familier glGenBuffers. Une fois que nous avons un objet tampon, nous le lions à la cible GL_UNIFORM_BUFFER et allouons suffisamment de mémoire en appelant glBufferData.\nunsigned int uboExampleBlock; glGenBuffers(1, \u0026uboExampleBlock); glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock); glBufferData(GL_UNIFORM_BUFFER, 152, NULL, GL_STATIC_DRAW); // allocate 152 bytes of memory glBindBuffer(GL_UNIFORM_BUFFER, 0); Maintenant, chaque fois que nous voulons mettre à jour ou insérer des données dans le tampon, nous nous lions à uboExampleBlock et utilisons glBufferSubData pour mettre à jour sa mémoire. Nous n’avons à mettre à jour ce tampon uniforme qu’une seule fois, et tous les shaders qui utilisent ce tampon utilisent maintenant ses données mises à jour. Mais comment OpenGL sait-il quels tampons uniformes correspondent à quels blocs uniformes ?\nDans le contexte OpenGL, il y a un certain nombre de points de liaison définis auxquels nous pouvons lier un tampon uniforme. Une fois que nous avons créé un tampon uniforme, nous le lions à l’un de ces points de liaison et nous lions également le bloc uniforme dans le shader au même point de liaison, les liant ainsi ensemble. Le diagramme suivant illustre ce processus : Comme vous pouvez le voir, nous pouvons lier plusieurs tampons uniformes à différents points de liaison. Comme le shader A et le shader B ont tous deux un bloc uniforme lié au même point de liaison 0, leurs blocs uniformes partagent les mêmes données uniformes trouvées dans uboMatrices ; la condition étant que les deux shader définissent le même bloc uniforme Matrices.\nPour définir un bloc uniforme de shader à un point de liaison spécifique, nous appelons glUniformBlockBinding qui prend un objet de programme, un index de bloc uniforme et le point de liaison à lier. L’indice du bloc uniforme est un indice d’emplacement du bloc uniforme défini dans le shader. Il peut être récupéré via un appel à glGetUniformBlockIndex qui accepte un objet programme et le nom du bloc uniforme. Nous pouvons placer le bloc uniforme Lights du diagramme au point de liaison 2 de la manière suivante :\nunsigned int lights_index = glGetUniformBlockIndex(shaderA.ID, \"Lights\"); glUniformBlockBinding(shaderA.ID, lights_index, 2); Notez que nous devons répéter ce processus pour chaque shader.\nÀ partir de la version 4.2 d’OpenGL, il est également possible de stocker le point de liaison d’un bloc uniforme explicitement dans le shader en ajoutant un autre spécificateur de disposition, ce qui nous évite d’appeler glGetUniformBlockIndex et glUniformBlockBinding. Le code suivant définit explicitement le point de liaison du bloc uniforme Lights :\nlayout(std140, binding = 2) uniform Lights { ... }; Nous devons ensuite lier l’objet tampon uniforme au même point de liaison, ce qui peut être réalisé avec glBindBufferBase ou glBindBufferRange.\nglBindBufferBase(GL_UNIFORM_BUFFER, 2, uboExampleBlock); // or glBindBufferRange(GL_UNIFORM_BUFFER, 2, uboExampleBlock, 0, 152); La fonction glBindbufferBase attend une cible, un index de point de liaison et un objet tampon uniforme. Cette fonction lie uboExampleBlock au point de liaison 2 ; à partir de ce point, les deux côtés du point de liaison sont liés. Vous pouvez également utiliser glBindBufferRange qui attend un paramètre supplémentaire de décalage et de taille - de cette façon, vous pouvez lier uniquement une plage spécifique du tampon uniforme à un point de liaison. En utilisant glBindBufferRange, vous pouvez avoir plusieurs blocs uniformes différents liés à un seul objet tampon uniforme.\nMaintenant que tout est en place, nous pouvons commencer à ajouter des données au tampon uniforme. Nous pouvons ajouter toutes les données sous la forme d’un tableau d’octets, ou mettre à jour des parties du tampon lorsque nous le souhaitons en utilisant glBufferSubData. Pour mettre à jour la variable uniforme booléenne, nous pouvons mettre à jour l’objet tampon uniforme comme suit :\nglBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock); int b = true; // bools in GLSL are represented as 4 bytes, so we store it in an integer glBufferSubData(GL_UNIFORM_BUFFER, 144, 4, \u0026b); glBindBuffer(GL_UNIFORM_BUFFER, 0); La même procédure s’applique à toutes les autres variables uniformes à l’intérieur du bloc uniforme, mais avec des arguments de portée différents.\nUn exemple simple Prenons donc un exemple concret d’objets tampons uniformes. Si nous regardons tous les exemples de code précédents, nous avons continuellement utilisé trois matrices : la matrice de projection, la matrice de vue et la matrice de modèle. De toutes ces matrices, seule la matrice de modèle change fréquemment. Si nous avons plusieurs shaders qui utilisent ce même ensemble de matrices, nous ferions mieux d’utiliser des objets tampons uniformes.\nNous allons stocker les matrices de projection et de vue dans un bloc uniforme appelé Matrices. Nous n’allons pas y stocker la matrice du modèle, car celle-ci a tendance à changer fréquemment d’un shader à l’autre, de sorte que nous n’aurions pas vraiment intérêt à utiliser des objets tampons uniformes.\n#version 330 core layout (location = 0) in vec3 aPos; layout (std140) uniform Matrices { mat4 projection; mat4 view; }; uniform mat4 model; void main() { gl_Position = projection * view * model * vec4(aPos, 1.0); } Il ne se passe pas grand-chose ici, si ce n’est que nous utilisons maintenant un bloc uniforme avec une disposition std140. Ce que nous allons faire dans notre exemple d’application est d’afficher 4 cubes où chaque cube est affiché avec un programme de shader différent. Chacun des 4 programmes de shaders utilise le même vertex shader, mais possède un fragment shader unique qui ne produit qu’une seule couleur différente pour chaque shader.\nTout d’abord, nous réglons le bloc uniforme des shaders de sommets sur le point de liaison 0. Notez que nous devons effectuer cette opération pour chaque shader :\nunsigned int uniformBlockIndexRed = glGetUniformBlockIndex(shaderRed.ID, \"Matrices\"); unsigned int uniformBlockIndexGreen = glGetUniformBlockIndex(shaderGreen.ID, \"Matrices\"); unsigned int uniformBlockIndexBlue = glGetUniformBlockIndex(shaderBlue.ID, \"Matrices\"); unsigned int uniformBlockIndexYellow = glGetUniformBlockIndex(shaderYellow.ID, \"Matrices\"); glUniformBlockBinding(shaderRed.ID, uniformBlockIndexRed, 0); glUniformBlockBinding(shaderGreen.ID, uniformBlockIndexGreen, 0); glUniformBlockBinding(shaderBlue.ID, uniformBlockIndexBlue, 0); glUniformBlockBinding(shaderYellow.ID, uniformBlockIndexYellow, 0); Ensuite, nous créons l’objet tampon uniforme proprement dit et le lions au point de liaison 0 :\nunsigned int uboMatrices glGenBuffers(1, \u0026uboMatrices); glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices); glBufferData(GL_UNIFORM_BUFFER, 2 * sizeof(glm::mat4), NULL, GL_STATIC_DRAW); glBindBuffer(GL_UNIFORM_BUFFER, 0); glBindBufferRange(GL_UNIFORM_BUFFER, 0, uboMatrices, 0, 2 * sizeof(glm::mat4)); Tout d’abord, nous allouons suffisamment de mémoire pour notre tampon qui est égal à 2 fois la taille de glm::mat4. La taille des matrices GLM correspond directement à mat4 en GLSL. Ensuite, nous lions une plage spécifique du tampon, dans ce cas le tampon entier, au point de liaison 0.\nIl ne reste plus qu’à remplir le tampon. Si nous maintenons constante la valeur du champ de vision de la matrice de projection (donc plus de zoom de la caméra), nous ne devons la mettre à jour qu’une seule fois dans notre application - ce qui signifie que nous ne devons l’insérer dans le tampon qu’une seule fois également. Comme nous avons déjà alloué suffisamment de mémoire à l’objet tampon, nous pouvons utiliser glBufferSubData pour stocker la matrice de projection avant d’entrer dans la boucle de rendu :\nglm::mat4 projection = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f); glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices); glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4), glm::value_ptr(projection)); glBindBuffer(GL_UNIFORM_BUFFER, 0); Ici, nous stockons la première moitié du tampon uniforme avec la matrice de projection. Ensuite, avant de rendre les objets à chaque image, nous mettons à jour la seconde moitié de la mémoire tampon avec la matrice de visualisation :\nglm::mat4 view = camera.GetViewMatrix();\tglBindBuffer(GL_UNIFORM_BUFFER, uboMatrices); glBufferSubData(GL_UNIFORM_BUFFER, sizeof(glm::mat4), sizeof(glm::mat4), glm::value_ptr(view)); glBindBuffer(GL_UNIFORM_BUFFER, 0); Et c’est tout pour les objets tampons uniformes. Chaque vertex shader qui contient un bloc uniforme Matrices contiendra désormais les données stockées dans uboMatrices. Ainsi, si nous dessinons 4 cubes en utilisant 4 shaders différents, leur projection et leur matrice de vue devraient être identiques :\nglBindVertexArray(cubeVAO); shaderRed.use(); glm::mat4 model = glm::mat4(1.0f); model = glm::translate(model, glm::vec3(-0.75f, 0.75f, 0.0f));\t// move top-left shaderRed.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); // ... draw Green Cube // ... draw Blue Cube // ... draw Yellow Cube\tLe seul uniforme que nous devons encore définir est l’uniforme du modèle. L’utilisation d’objets tampons uniformes dans un scénario comme celui-ci nous permet d’éviter un certain nombre d’appels d’uniformes par shader. Le résultat ressemble à ceci : Chacun des cubes est déplacé d’un côté de la fenêtre par translation de la matrice du modèle et, grâce aux différents shaders de fragment, leurs couleurs diffèrent selon l’objet. Il s’agit d’un scénario relativement simple d’utilisation des objets tampons uniformes, mais toute grande application de rendu peut avoir des centaines de programmes de shaders actifs, et c’est là que les objets tampons uniformes commencent vraiment à briller.\nVous pouvez trouver le code source complet de l’exemple d’application uniforme ici.\nLes objets tampons uniformes présentent plusieurs avantages par rapport aux uniformes individuels. Tout d’abord, il est plus rapide de définir un grand nombre d’uniformes à la fois que de définir plusieurs uniformes un par un. Deuxièmement, si vous voulez changer le même uniforme sur plusieurs shaders, il est beaucoup plus facile de changer un uniforme une fois dans un tampon d’uniformes. Un dernier avantage qui n’est pas immédiatement apparent est que vous pouvez utiliser beaucoup plus d’uniformes dans les shaders en utilisant des objets tampons uniformes. OpenGL a une limite à la quantité de données d’uniformes qu’il peut gérer, qui peut être interrogée avec GL_MAX_VERTEX_UNIFORM_COMPONENTS. Lorsque l’on utilise des objets tampons uniformes, cette limite est beaucoup plus élevée. Ainsi, lorsque vous atteignez un nombre maximum d’uniformes (lors d’une animation squelettique par exemple), il y a toujours des objets tampons uniformes.\n",
  "wordCount" : "4563",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hrst4.xyz/docs/learnopengl_fr/04_advanced_opengl/07_advanced_glsl/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "hrst4's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hrst4.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hrst4.xyz/" accesskey="h" title="hrst4&#39;s blog (Alt + H)">hrst4&#39;s blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://hrst4.xyz/apropos" title="apropos">
                    <span>apropos</span>
                </a>
            </li>
            <li>
                <a href="https://hrst4.xyz/docs" title="docs">
                    <span>docs</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="glsl-avancé">GLSL avancé<a hidden class="anchor" aria-hidden="true" href="#glsl-avancé">#</a></h1>
<p>Ce chapitre ne vous montrera pas vraiment de nouvelles fonctionnalités super avancées qui donneront un énorme coup de pouce à la qualité visuelle de votre scène. Ce chapitre aborde plus ou moins des aspects intéressants de GLSL et des astuces qui peuvent vous aider dans vos projets futurs. En gros, quelques bonnes choses à savoir et des fonctionnalités qui peuvent vous faciliter la vie lorsque vous créez des applications OpenGL en combinaison avec GLSL.</p>
<p>Nous discuterons de quelques variables intégrées intéressantes, de nouvelles façons d&rsquo;organiser l&rsquo;entrée et la sortie des shaders, et d&rsquo;un outil très utile appelé <strong>objets tampons uniformes.</strong></p>
<h2 id="les-variables-intégrées-de-glsl-built-in-variables">Les variables intégrées de GLSL (built-in variables)<a hidden class="anchor" aria-hidden="true" href="#les-variables-intégrées-de-glsl-built-in-variables">#</a></h2>
<p>Les shaders sont très complexes, et si nous avons besoin de données provenant d&rsquo;une autre source que le shader en cours, nous devrons les faire circuler. Nous avons appris à le faire via les attributs de vertex, les uniformes et les samplers. Il existe cependant quelques variables supplémentaires définies par GLSL et préfixées par <code>gl_</code> qui nous donnent un moyen supplémentaire de collecter et/ou d&rsquo;écrire des données. Nous en avons déjà vu deux dans les chapitres précédents : <code>gl_Position</code> qui est le vecteur de sortie du vertex shader, et <code>gl_FragCoord</code> du fragment shader.</p>
<p>Nous allons discuter de quelques variables d&rsquo;entrée et de sortie intégrées intéressantes qui sont intégrées dans GLSL et expliquer comment elles peuvent nous être utiles. Notez que nous ne parlerons pas de toutes les variables intégrées qui existent dans GLSL, donc si vous voulez voir toutes les variables intégrées, vous pouvez consulter le <a href="https://www.khronos.org/opengl/wiki/Built-in_Variable_%28GLSL%29">wiki</a> d&rsquo;OpenGL.</p>
<h2 id="variables-du-vertex-shader">Variables du vertex shader<a hidden class="anchor" aria-hidden="true" href="#variables-du-vertex-shader">#</a></h2>
<p>Nous avons déjà vu <code>gl_Position</code> qui est le vecteur de position de sortie de l&rsquo;espace-clip du vertex shader. Définir <code>gl_Position</code> dans le vertex shader est une exigence stricte si vous voulez rendre quoi que ce soit à l&rsquo;écran. Rien que nous n&rsquo;ayons déjà vu auparavant.</p>
<h4 id="gl_pointsize"><code>gl_PointSize</code><a hidden class="anchor" aria-hidden="true" href="#gl_pointsize">#</a></h4>
<p>L&rsquo;une des primitives de rendu que nous pouvons choisir est <code>GL_POINTS</code>. Dans ce cas, chaque vertex est une primitive et est rendu comme un point. Il est possible de définir la taille des points rendus via la fonction <code>glPointSize</code> d&rsquo;OpenGL, mais nous pouvons également influencer cette valeur dans le shader de vertex.</p>
<p>Une variable de sortie définie par GLSL est appelée <code>gl_PointSize</code>. <strong>Il s&rsquo;agit d&rsquo;une variable flottante dans laquelle vous pouvez définir la largeur et la hauteur du point en pixels.</strong> En définissant la taille du point dans le shader de sommets, nous obtenons un contrôle par sommet sur les dimensions de ce point.</p>
<p>L&rsquo;influence sur la taille des points dans le vertex shader est désactivée par défaut, mais si vous souhaitez l&rsquo;activer, vous devez activer la fonction <code>GL_PROGRAM_POINT_SIZE</code> d&rsquo;OpenGL :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glEnable(GL_PROGRAM_POINT_SIZE);  
</span></span></code></pre></div><p>Un exemple simple d&rsquo;influence sur la taille des points consiste à définir une taille de point égale à la valeur z de la position de l&rsquo;espace-clip, qui est égale à la distance du sommet par rapport à l&rsquo;observateur. La taille du point devrait alors augmenter au fur et à mesure que l&rsquo;on s&rsquo;éloigne des sommets de l&rsquo;observateur.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    gl_Position <span style="color:#f92672">=</span> projection <span style="color:#f92672">*</span> view <span style="color:#f92672">*</span> model <span style="color:#f92672">*</span> vec4(aPos, <span style="color:#ae81ff">1.0</span>);    
</span></span><span style="display:flex;"><span>    gl_PointSize <span style="color:#f92672">=</span> gl_Position.z;    
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Le résultat est que les points que nous avons dessinés sont rendus plus grands au fur et à mesure que nous nous en éloignons :
<img src="/docs/LEARNOPENGL_FR/04_Advanced_OpenGL/advanced_glsl_pointsize.png" alt="advanced_glsl_pointsize"/>
Vous pouvez imaginer que la variation de la taille des points par vertex est intéressante pour des techniques telles que la génération de particules.</p>
<h4 id="gl_vertexid"><code>gl_VertexID</code><a hidden class="anchor" aria-hidden="true" href="#gl_vertexid">#</a></h4>
<p>Les variables <code>gl_Position</code> et <code>gl_PointSize</code> sont des variables de sortie puisque leur valeur est lue par le vertex shader ; nous pouvons influencer le résultat en y écrivant. Le vertex shader nous fournit également une variable d&rsquo;entrée intéressante, que nous ne pouvons que lire, appelée <code>gl_VertexID</code>.</p>
<p>La variable entière <code>gl_VertexID</code> contient l&rsquo;identifiant actuel du sommet que nous sommes en train de dessiner. Lors d&rsquo;un rendu indexé (avec <code>glDrawElements</code>), cette variable contient l&rsquo;index actuel du sommet que nous dessinons. Lors d&rsquo;un dessin sans index (via <code>glDrawArrays</code>), cette variable contient le numéro du sommet en cours de traitement depuis le début de l&rsquo;appel au rendu.</p>
<h2 id="variables-du-fragment-shader">Variables du fragment shader<a hidden class="anchor" aria-hidden="true" href="#variables-du-fragment-shader">#</a></h2>
<p>Dans le fragment shader, nous avons également accès à quelques variables intéressantes. GLSL nous donne deux variables d&rsquo;entrée intéressantes appelées <code>gl_FragCoord</code> et <code>gl_FrontFacing</code>.</p>
<h3 id="gl_fragcoord"><code>gl_FragCoord</code><a hidden class="anchor" aria-hidden="true" href="#gl_fragcoord">#</a></h3>
<p>Nous avons déjà vu le vecteur <code>gl_FragCoord</code> à plusieurs reprises au cours de la discussion sur les tests de profondeur, car la composante z du vecteur <code>gl_FragCoord</code> est égale à la valeur de profondeur de ce fragment particulier. Cependant, nous pouvons également utiliser les composantes x et y de ce vecteur pour obtenir des effets intéressants.</p>
<p>Les composantes x et y du vecteur <code>gl_FragCoord</code> sont les coordonnées du fragment dans l&rsquo;espace de la fenêtre ou de l&rsquo;écran, à partir de la partie inférieure gauche de la fenêtre. Nous avons spécifié une fenêtre de rendu de 800x600 avec <code>glViewport</code>, de sorte que les coordonnées de l&rsquo;espace-écran du fragment auront des valeurs x comprises entre 0 et 800, et des valeurs y comprises entre 0 et 600.</p>
<p>En utilisant le shader de fragment, nous pouvons calculer une valeur de couleur différente en fonction des coordonnées d&rsquo;écran du fragment. La variable <code>gl_FragCoord</code> est couramment utilisée pour comparer les résultats visuels de différents calculs de fragments, comme on le voit généralement dans les démonstrations techniques. Nous pourrions par exemple diviser l&rsquo;écran en deux en rendant une sortie sur le côté gauche de la fenêtre et une autre sur le côté droit de la fenêtre. Un exemple de shader de fragment qui produit une couleur différente en fonction des coordonnées du fragment à l&rsquo;écran est donné ci-dessous :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{             
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(gl_FragCoord.x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">400</span>)
</span></span><span style="display:flex;"><span>        FragColor <span style="color:#f92672">=</span> vec4(<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        FragColor <span style="color:#f92672">=</span> vec4(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>);        
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Comme la largeur de la fenêtre est égale à 800, chaque fois que la coordonnée x d&rsquo;un pixel est inférieure à 400, il doit se trouver à gauche de la fenêtre et nous donnerons à ce fragment une couleur différente.</p>
<p><img src="/docs/LEARNOPENGL_FR/04_Advanced_OpenGL/advanced_glsl_fragcoord.png" alt="advanced_glsl_fragcoord"/></p>
<p>Nous pouvons maintenant calculer deux résultats de fragment shader complètement différents et les afficher chacun d&rsquo;un côté différent de la fenêtre. C&rsquo;est idéal pour tester différentes techniques d&rsquo;éclairage, par exemple.</p>
<h3 id="gl_frontfacing">``gl_FrontFacing`<a hidden class="anchor" aria-hidden="true" href="#gl_frontfacing">#</a></h3>
<p>Une autre variable d&rsquo;entrée intéressante dans le fragment shader est la variable <code>gl_FrontFacing</code>. <strong>Dans le chapitre sur l&rsquo;élimination des faces, nous avons mentionné qu&rsquo;OpenGL est capable de déterminer si une face est une face avant ou arrière en raison de l&rsquo;ordre d&rsquo;enroulement des sommets</strong>. La variable <code>gl_FrontFacing</code> nous indique si le fragment courant fait partie d&rsquo;une face avant ou arrière. Nous pourrions, par exemple, décider de produire des couleurs différentes pour toutes les faces arrière.</p>
<p><strong>La variable <code>gl_FrontFacing</code> est un bool qui vaut true si le fragment fait partie d&rsquo;une face avant et false dans le cas contraire.</strong> Nous pouvons créer un cube de cette manière avec une texture différente à l&rsquo;intérieur et à l&rsquo;extérieur :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>out vec4 FragColor;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>in vec2 TexCoords;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform sampler2D frontTexture;
</span></span><span style="display:flex;"><span>uniform sampler2D backTexture;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{             
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(gl_FrontFacing)
</span></span><span style="display:flex;"><span>        FragColor <span style="color:#f92672">=</span> texture(frontTexture, TexCoords);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        FragColor <span style="color:#f92672">=</span> texture(backTexture, TexCoords);
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Si nous jetons un coup d&rsquo;œil à l&rsquo;intérieur du conteneur, nous constatons qu&rsquo;une texture différente est utilisée.
<img src="/docs/LEARNOPENGL_FR/04_Advanced_OpenGL/advanced_glsl_frontfacing.png" alt="advanced_glsl_frontfacing"/>
Notez que si vous avez activé l&rsquo;élimination des faces, vous ne pourrez pas voir les faces à l&rsquo;intérieur du conteneur et l&rsquo;utilisation de <code>gl_FrontFacing</code> serait alors inutile.</p>
<h3 id="gl_fragdepth"><code>gl_FragDepth</code><a hidden class="anchor" aria-hidden="true" href="#gl_fragdepth">#</a></h3>
<p>La variable d&rsquo;entrée <code>gl_FragCoord</code> est une variable d&rsquo;entrée qui nous permet de lire les coordonnées de l&rsquo;espace-écran et d&rsquo;obtenir la valeur de la profondeur du fragment actuel, mais il s&rsquo;agit d&rsquo;une variable en lecture seule. Nous ne pouvons pas influencer les coordonnées de l&rsquo;espace-écran du fragment, <strong>mais il est possible de définir la valeur de la profondeur du fragment</strong>. GLSL nous donne une variable de sortie appelée <code>gl_FragDepth</code> que nous pouvons utiliser pour définir manuellement la valeur de profondeur du fragment dans le shader.</p>
<p>Pour définir la valeur de la profondeur dans le shader, nous écrivons n&rsquo;importe quelle valeur entre 0,0 et 1,0 dans la variable de sortie :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>gl_FragDepth <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>; <span style="color:#75715e">// this fragment now has a depth value of 0.0
</span></span></span></code></pre></div><p>Si le shader n&rsquo;écrit rien dans <code>gl_FragDepth</code>, la variable prendra automatiquement sa valeur dans <code>gl_FragCoord.z</code>.</p>
<p><strong>Définir manuellement la valeur de la profondeur présente cependant un inconvénient majeur</strong>. En effet, OpenGL désactive le test de profondeur anticipé (tel que discuté dans le chapitre sur le test de profondeur) dès que nous écrivons dans <code>gl_FragDepth</code> dans le fragment shader. Il est désactivé parce qu&rsquo;OpenGL ne peut pas savoir quelle valeur de profondeur aura le fragment avant de lancer le shader de fragment, puisque le shader de fragment peut en fait changer cette valeur.</p>
<p>En écrivant dans <code>gl_FragDepth</code>, vous devez prendre en compte cette pénalité de performance. A partir d&rsquo;OpenGL 4.2 cependant, nous pouvons encore faire une sorte de médiation entre les deux côtés en redéclarant la variable <code>gl_FragDepth</code> au début du fragment shader avec une condition de profondeur :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>layout (depth_<span style="color:#f92672">&lt;</span>condition<span style="color:#f92672">&gt;</span>) out <span style="color:#66d9ef">float</span> gl_FragDepth;
</span></span></code></pre></div><p>Cette condition peut prendre les valeurs suivantes :</p>
<table>
<thead>
<tr>
<th>Condition</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>any</td>
<td>Valeur par défaut. Le test de profondeur précoce est désactivé.</td>
</tr>
<tr>
<td>greater</td>
<td>Vous pouvez seulement augmenter la valeur de la profondeur par rapport à <code>gl_FragCoord.z</code>.</td>
</tr>
<tr>
<td>less</td>
<td>Vous ne pouvez que réduire la valeur de la profondeur par rapport à <code>gl_FragCoord.z</code>.</td>
</tr>
<tr>
<td>unchanged</td>
<td>Si vous écrivez dans <code>gl_FragDepth</code>, vous écrirez exactement <code>gl_FragCoord.z</code>.</td>
</tr>
<tr>
<td>En spécifiant supérieur ou inférieur comme condition de profondeur, OpenGL peut supposer que vous n&rsquo;écrirez que des valeurs de profondeur plus grandes ou plus petites que la valeur de profondeur du fragment. De cette manière, OpenGL est toujours capable de tester la profondeur lorsque la valeur du tampon de profondeur fait partie de l&rsquo;autre direction de <code>gl_FragCoord.z</code>.</td>
<td></td>
</tr>
</tbody>
</table>
<p>Un exemple où nous augmentons la valeur de profondeur dans le fragment shader, mais où nous voulons encore préserver une partie du test de profondeur précoce est montré dans le fragment shader ci-dessous :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 420 core </span><span style="color:#75715e">// note the GLSL version!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>out vec4 FragColor;
</span></span><span style="display:flex;"><span>layout (depth_greater) out <span style="color:#66d9ef">float</span> gl_FragDepth;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{             
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> vec4(<span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>    gl_FragDepth <span style="color:#f92672">=</span> gl_FragCoord.z <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.1</span>;
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Notez que cette fonctionnalité n&rsquo;est disponible qu&rsquo;à partir de la version 4.2 d&rsquo;OpenGL.</p>
<h2 id="blocs-dinterface">Blocs d&rsquo;interface<a hidden class="anchor" aria-hidden="true" href="#blocs-dinterface">#</a></h2>
<p>Nous utilisons OpenGL depuis un certain temps maintenant et avons appris quelques trucs sympas, mais aussi quelques désagréments. Par exemple, lorsque nous utilisons plus d&rsquo;un shader, nous devons continuellement définir des variables uniformes dont la plupart sont exactement les mêmes pour chaque shader.</p>
<p>OpenGL nous offre un outil appelé objets tampons uniformes (uniform buffer objects) qui nous permet de déclarer un ensemble de variables uniformes globales qui restent les mêmes quel que soit le nombre de programmes de shaders. <strong>En utilisant les objets tampons uniformes, nous définissons les uniformes pertinents une seule fois dans la mémoire fixe du GPU</strong>. Il reste cependant nécessaire de définir manuellement les uniformes qui sont uniques pour chaque shader. La création et la configuration d&rsquo;un objet tampon uniforme nécessitent toutefois un peu de travail.</p>
<p>Parce qu&rsquo;un objet tampon uniforme est un tampon comme les autres, nous pouvons en créer un via <code>glGenBuffers</code>, le lier à la cible tampon <code>GL_UNIFORM_BUFFER</code> et stocker toutes les données uniformes pertinentes dans le tampon. Il existe certaines règles quant à la manière dont les données des objets tampons uniformes doivent être stockées, nous y reviendrons plus tard. Tout d&rsquo;abord, nous allons prendre un simple vertex shader et stocker notre projection et notre matrice de vue dans ce que l&rsquo;on appelle un bloc uniforme :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) in vec3 aPos;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>layout (std140) uniform Matrices
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    mat4 projection;
</span></span><span style="display:flex;"><span>    mat4 view;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform mat4 model;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    gl_Position <span style="color:#f92672">=</span> projection <span style="color:#f92672">*</span> view <span style="color:#f92672">*</span> model <span style="color:#f92672">*</span> vec4(aPos, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Dans la plupart de nos exemples, nous définissons une matrice uniforme de projection et de vue à chaque image pour chaque shader que nous utilisons. C&rsquo;est un exemple parfait de l&rsquo;utilité des objets tampons uniformes puisque nous n&rsquo;avons plus qu&rsquo;à stocker ces matrices une seule fois.</p>
<p>Ici, nous avons déclaré un bloc uniforme appelé Matrices qui stocke deux matrices 4x4. Les variables d&rsquo;un bloc uniforme sont directement accessibles sans le nom du bloc comme préfixe. Ensuite, nous stockons ces valeurs de matrices dans un tampon quelque part dans le code OpenGL et chaque shader qui déclare ce bloc uniforme a accès aux matrices.</p>
<p>Vous vous demandez probablement ce que signifie l&rsquo;énoncé <code>layout (std140)</code>. Cela signifie que le bloc uniforme actuellement défini utilise une disposition de mémoire spécifique pour son contenu ; cette déclaration définit la disposition du bloc uniforme.</p>
<h2 id="disposition-uniforme-des-blocs">Disposition uniforme des blocs<a hidden class="anchor" aria-hidden="true" href="#disposition-uniforme-des-blocs">#</a></h2>
<p>Le contenu d&rsquo;un bloc uniforme est stocké dans un objet tampon, qui n&rsquo;est rien d&rsquo;autre qu&rsquo;un morceau réservé de la mémoire globale du GPU. Parce que ce morceau de mémoire ne contient aucune information sur le type de données qu&rsquo;il contient, nous devons dire à OpenGL quelles parties de la mémoire correspondent à quelles variables uniformes dans le shader.</p>
<p>Imaginez le bloc uniforme suivant dans un shader :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>layout (std140) uniform ExampleBlock
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> value;
</span></span><span style="display:flex;"><span>    vec3  vector;
</span></span><span style="display:flex;"><span>    mat4  matrix;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> values[<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span>  boolean;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>   integer;
</span></span><span style="display:flex;"><span>};  
</span></span></code></pre></div><p>Ce que nous voulons savoir, c&rsquo;est la taille (en octets) et le décalage (depuis le début du bloc) de chacune de ces variables afin de pouvoir les placer dans le tampon dans leur ordre respectif. La taille de chacun des éléments est clairement indiquée dans OpenGL et correspond directement aux types de données C++ ; les vecteurs et les matrices étant de (grands) tableaux de flottants. <strong>Ce qu&rsquo;OpenGL n&rsquo;indique pas clairement, c&rsquo;est l&rsquo;espacement entre les variables</strong>. Cela permet au matériel de positionner ou de remplir les variables comme il l&rsquo;entend. Le matériel est capable de placer un <code>vec3</code> à côté d&rsquo;un <code>float</code> par exemple. Tous les matériels ne peuvent pas gérer cela et remplacent le <code>vec3</code> par un tableau de 4 flottants avant d&rsquo;ajouter le flottant. C&rsquo;est une fonctionnalité intéressante, mais peu pratique pour nous.</p>
<p>Par défaut, GLSL utilise une disposition uniforme de la mémoire appelée disposition partagée (shared layout)- partagée parce qu&rsquo;une fois que les décalages sont définis par le matériel, ils sont partagés de manière cohérente entre plusieurs programmes. Avec une disposition partagée, GLSL est autorisé à repositionner les variables uniformes à des fins d&rsquo;optimisation, tant que l&rsquo;ordre des variables reste intact. Comme nous ne savons pas à quel décalage chaque variable uniforme se trouvera, nous ne savons pas comment remplir précisément notre tampon uniforme. Nous pouvons interroger cette information avec des fonctions comme <code>glGetUniformIndices</code>, mais ce n&rsquo;est pas l&rsquo;approche que nous allons adopter dans ce chapitre.</p>
<p>Bien qu&rsquo;une disposition partagée nous permette d&rsquo;économiser de l&rsquo;espace, nous devrions interroger l&rsquo;offset pour chaque variable uniforme, ce qui représente beaucoup de travail. La pratique générale consiste cependant à ne pas utiliser la disposition partagée, mais à utiliser la disposition <code>std140</code>. La disposition <code>std140</code> indique explicitement la disposition de la mémoire pour chaque type de variable en normalisant leurs décalages respectifs régis par un ensemble de règles. Puisque cette disposition est normalisée, nous pouvons déterminer manuellement les décalages pour chaque variable.</p>
<p>Chaque variable a un alignement de base égal à l&rsquo;espace qu&rsquo;une variable prend (y compris le remplissage) dans un bloc uniforme en utilisant les règles de disposition <code>std140</code>. Pour chaque variable, nous calculons son décalage aligné : le décalage en octets d&rsquo;une variable par rapport au début du bloc. Le décalage d&rsquo;octet aligné d&rsquo;une variable doit être égal à un multiple de son alignement de base. C&rsquo;est un peu compliqué, mais nous verrons bientôt des exemples pour clarifier les choses.</p>
<p>Les règles exactes de mise en page peuvent être trouvées dans la spécification de tampon uniforme d&rsquo;OpenGL <a href="http://www.opengl.org/registry/specs/ARB/uniform_buffer_object.txt">ici</a>, mais nous allons énumérer les règles les plus courantes ci-dessous. Chaque type de variable en GLSL, comme int, float et bool, est défini comme une quantité de quatre octets, chaque entité de 4 octets étant représentée par N.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Règle de Layout</th>
</tr>
</thead>
<tbody>
<tr>
<td>Scalaire (int ou float)</td>
<td>Chaque scalaire a un alignement de base de N.</td>
</tr>
<tr>
<td>Vector</td>
<td>Soit 2N, soit 4N. Cela signifie qu&rsquo;un vec3 a un alignement de base de 4N.</td>
</tr>
<tr>
<td>Tableau de scalaires ou de Vectors</td>
<td>Chaque élément a un alignement de base égal à celui d&rsquo;un vec4.</td>
</tr>
<tr>
<td>Matrices</td>
<td>Stocké sous la forme d&rsquo;un grand tableau de vecteurs de colonnes, où chacun de ces vecteurs a un alignement de base de vec4.</td>
</tr>
<tr>
<td>Struct</td>
<td>Égale à la taille calculée de ses éléments selon les règles précédentes, mais remplie d&rsquo;un multiple de la taille d&rsquo;un vec4.</td>
</tr>
<tr>
<td>Comme la plupart des spécifications d&rsquo;OpenGL, il est plus facile de comprendre avec un exemple. Nous prenons le bloc uniforme appelé <code>ExampleBlock</code> que nous avons présenté plus tôt et nous calculons le décalage aligné pour chacun de ses membres en utilisant la disposition <code>std140</code> :</td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>layout (std140) uniform ExampleBlock
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>                     <span style="color:#75715e">// base alignment  // aligned offset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> value;     <span style="color:#75715e">// 4               // 0 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 vector;     <span style="color:#75715e">// 16              // 16  (offset must be multiple of 16 so 4-&gt;16)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    mat4 matrix;     <span style="color:#75715e">// 16              // 32  (column 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                     <span style="color:#75715e">// 16              // 48  (column 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                     <span style="color:#75715e">// 16              // 64  (column 2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                     <span style="color:#75715e">// 16              // 80  (column 3)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> values[<span style="color:#ae81ff">3</span>]; <span style="color:#75715e">// 16              // 96  (values[0])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                     <span style="color:#75715e">// 16              // 112 (values[1])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                     <span style="color:#75715e">// 16              // 128 (values[2])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> boolean;    <span style="color:#75715e">// 4               // 144
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> integer;     <span style="color:#75715e">// 4               // 148
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}; 
</span></span></code></pre></div><p>À titre d&rsquo;exercice, essayez de calculer vous-même les valeurs de décalage et comparez-les à ce tableau. Avec ces valeurs de décalage calculées, basées sur les règles de la disposition <code>std140</code>, nous pouvons remplir le tampon avec des données aux décalages appropriés en utilisant des fonctions comme <code>glBufferSubData</code>. Bien qu&rsquo;elle ne soit pas la plus efficace, la disposition <code>std140</code> nous garantit que la disposition de la mémoire reste la même pour chaque programme qui a déclaré ce bloc uniforme.</p>
<p>En ajoutant la déclaration <code>layout (std140)</code> dans la définition du bloc uniforme, nous indiquons à OpenGL que ce bloc uniforme utilise la disposition <code>std140</code>. Il y a deux autres dispositions à choisir qui nous obligent à interroger chaque décalage avant de remplir les tampons. Nous avons déjà vu la disposition partagée, l&rsquo;autre disposition restante étant emballée (packed). Lorsque l&rsquo;on utilise le <code>layout packed</code>, il n&rsquo;y a aucune garantie que le layout reste le même entre les programmes (non partagé) car il permet au compilateur d&rsquo;optimiser les variables uniformes loin du bloc uniforme qui peut être différent pour chaque shader.</p>
<h2 id="utilisation-de-tampons-uniformes">Utilisation de tampons uniformes<a hidden class="anchor" aria-hidden="true" href="#utilisation-de-tampons-uniformes">#</a></h2>
<p>Nous avons défini les blocs uniformes et spécifié leur disposition en mémoire, mais nous n&rsquo;avons pas encore discuté de la manière de les utiliser.</p>
<p>Tout d&rsquo;abord, nous devons créer un objet tampon uniforme, ce qui se fait via le familier <code>glGenBuffers</code>. Une fois que nous avons un objet tampon, nous le lions à la cible <code>GL_UNIFORM_BUFFER</code> et allouons suffisamment de mémoire en appelant <code>glBufferData</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> uboExampleBlock;
</span></span><span style="display:flex;"><span>glGenBuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>uboExampleBlock);
</span></span><span style="display:flex;"><span>glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);
</span></span><span style="display:flex;"><span>glBufferData(GL_UNIFORM_BUFFER, <span style="color:#ae81ff">152</span>, NULL, GL_STATIC_DRAW); <span style="color:#75715e">// allocate 152 bytes of memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glBindBuffer(GL_UNIFORM_BUFFER, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>Maintenant, chaque fois que nous voulons mettre à jour ou insérer des données dans le tampon, nous nous lions à <code>uboExampleBlock</code> et utilisons <code>glBufferSubData</code> pour mettre à jour sa mémoire. Nous n&rsquo;avons à mettre à jour ce tampon uniforme qu&rsquo;une seule fois, et tous les shaders qui utilisent ce tampon utilisent maintenant ses données mises à jour. Mais comment OpenGL sait-il quels tampons uniformes correspondent à quels blocs uniformes ?</p>
<p>Dans le contexte OpenGL, il y a un certain nombre de points de liaison définis auxquels nous pouvons lier un tampon uniforme. Une fois que nous avons créé un tampon uniforme, nous le lions à l&rsquo;un de ces points de liaison et nous lions également le bloc uniforme dans le shader au même point de liaison, les liant ainsi ensemble. Le diagramme suivant illustre ce processus :
<img src="/docs/LEARNOPENGL_FR/04_Advanced_OpenGL/advanced_glsl_binding_points.png" alt="advanced_glsl_binding_points"/></p>
<p>Comme vous pouvez le voir, nous pouvons lier plusieurs tampons uniformes à différents points de liaison. Comme le shader A et le shader B ont tous deux un bloc uniforme lié au même point de liaison 0, leurs blocs uniformes partagent les mêmes données uniformes trouvées dans <code>uboMatrices</code> ; la condition étant que les deux shader définissent le même bloc uniforme Matrices.</p>
<p>Pour définir un bloc uniforme de shader à un point de liaison spécifique, nous appelons <code>glUniformBlockBinding</code> qui prend un objet de programme, un index de bloc uniforme et le point de liaison à lier. L&rsquo;indice du bloc uniforme est un indice d&rsquo;emplacement du bloc uniforme défini dans le shader. Il peut être récupéré via un appel à <code>glGetUniformBlockIndex</code> qui accepte un objet programme et le nom du bloc uniforme. Nous pouvons placer le bloc uniforme <code>Lights</code> du diagramme au point de liaison 2 de la manière suivante :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> lights_index <span style="color:#f92672">=</span> glGetUniformBlockIndex(shaderA.ID, <span style="color:#e6db74">&#34;Lights&#34;</span>);   
</span></span><span style="display:flex;"><span>glUniformBlockBinding(shaderA.ID, lights_index, <span style="color:#ae81ff">2</span>);
</span></span></code></pre></div><p>Notez que nous devons répéter ce processus pour chaque shader.</p>
<blockquote>
<p>À partir de la version 4.2 d&rsquo;OpenGL, il est également possible de stocker le point de liaison d&rsquo;un bloc uniforme explicitement dans le shader en ajoutant un autre spécificateur de disposition, ce qui nous évite d&rsquo;appeler <code>glGetUniformBlockIndex</code> et <code>glUniformBlockBinding</code>. Le code suivant définit explicitement le point de liaison du bloc uniforme Lights :</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>layout(std140, binding <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>) uniform Lights { ... };
</span></span></code></pre></div><p>Nous devons ensuite lier l&rsquo;objet tampon uniforme au même point de liaison, ce qui peut être réalisé avec <code>glBindBufferBase</code> ou <code>glBindBufferRange</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glBindBufferBase(GL_UNIFORM_BUFFER, <span style="color:#ae81ff">2</span>, uboExampleBlock); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glBindBufferRange(GL_UNIFORM_BUFFER, <span style="color:#ae81ff">2</span>, uboExampleBlock, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">152</span>);
</span></span></code></pre></div><p>La fonction <code>glBindbufferBase</code> attend une cible, un index de point de liaison et un objet tampon uniforme. Cette fonction lie <code>uboExampleBlock</code> au point de liaison 2 ; à partir de ce point, les deux côtés du point de liaison sont liés. Vous pouvez également utiliser <code>glBindBufferRange</code> qui attend un paramètre supplémentaire de décalage et de taille - de cette façon, vous pouvez lier uniquement une plage spécifique du tampon uniforme à un point de liaison. En utilisant <code>glBindBufferRange</code>, vous pouvez avoir plusieurs blocs uniformes différents liés à un seul objet tampon uniforme.</p>
<p>Maintenant que tout est en place, nous pouvons commencer à ajouter des données au tampon uniforme. Nous pouvons ajouter toutes les données sous la forme d&rsquo;un tableau d&rsquo;octets, ou mettre à jour des parties du tampon lorsque nous le souhaitons en utilisant <code>glBufferSubData</code>. Pour mettre à jour la variable uniforme booléenne, nous pouvons mettre à jour l&rsquo;objet tampon uniforme comme suit :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> true; <span style="color:#75715e">// bools in GLSL are represented as 4 bytes, so we store it in an integer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glBufferSubData(GL_UNIFORM_BUFFER, <span style="color:#ae81ff">144</span>, <span style="color:#ae81ff">4</span>, <span style="color:#f92672">&amp;</span>b); 
</span></span><span style="display:flex;"><span>glBindBuffer(GL_UNIFORM_BUFFER, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>La même procédure s&rsquo;applique à toutes les autres variables uniformes à l&rsquo;intérieur du bloc uniforme, mais avec des arguments de portée différents.</p>
<h2 id="un-exemple-simple">Un exemple simple<a hidden class="anchor" aria-hidden="true" href="#un-exemple-simple">#</a></h2>
<p>Prenons donc un exemple concret d&rsquo;objets tampons uniformes. Si nous regardons tous les exemples de code précédents, nous avons continuellement utilisé trois matrices : la matrice de projection, la matrice de vue et la matrice de modèle. De toutes ces matrices, seule la matrice de modèle change fréquemment. Si nous avons plusieurs shaders qui utilisent ce même ensemble de matrices, nous ferions mieux d&rsquo;utiliser des objets tampons uniformes.</p>
<p>Nous allons stocker les matrices de projection et de vue dans un bloc uniforme appelé <code>Matrices</code>. Nous n&rsquo;allons pas y stocker la matrice du modèle, car celle-ci a tendance à changer fréquemment d&rsquo;un shader à l&rsquo;autre, de sorte que nous n&rsquo;aurions pas vraiment intérêt à utiliser des objets tampons uniformes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) in vec3 aPos;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>layout (std140) uniform Matrices
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    mat4 projection;
</span></span><span style="display:flex;"><span>    mat4 view;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>uniform mat4 model;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    gl_Position <span style="color:#f92672">=</span> projection <span style="color:#f92672">*</span> view <span style="color:#f92672">*</span> model <span style="color:#f92672">*</span> vec4(aPos, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Il ne se passe pas grand-chose ici, si ce n&rsquo;est que nous utilisons maintenant un bloc uniforme avec une disposition <code>std140</code>. Ce que nous allons faire dans notre exemple d&rsquo;application est d&rsquo;afficher 4 cubes où chaque cube est affiché avec un programme de shader différent. Chacun des 4 programmes de shaders utilise le même vertex shader, mais possède un fragment shader unique qui ne produit qu&rsquo;une seule couleur différente pour chaque shader.</p>
<p>Tout d&rsquo;abord, nous réglons le bloc uniforme des shaders de sommets sur le point de liaison 0. Notez que nous devons effectuer cette opération pour chaque shader :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> uniformBlockIndexRed    <span style="color:#f92672">=</span> glGetUniformBlockIndex(shaderRed.ID, <span style="color:#e6db74">&#34;Matrices&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> uniformBlockIndexGreen  <span style="color:#f92672">=</span> glGetUniformBlockIndex(shaderGreen.ID, <span style="color:#e6db74">&#34;Matrices&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> uniformBlockIndexBlue   <span style="color:#f92672">=</span> glGetUniformBlockIndex(shaderBlue.ID, <span style="color:#e6db74">&#34;Matrices&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> uniformBlockIndexYellow <span style="color:#f92672">=</span> glGetUniformBlockIndex(shaderYellow.ID, <span style="color:#e6db74">&#34;Matrices&#34;</span>);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>glUniformBlockBinding(shaderRed.ID,    uniformBlockIndexRed, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>glUniformBlockBinding(shaderGreen.ID,  uniformBlockIndexGreen, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>glUniformBlockBinding(shaderBlue.ID,   uniformBlockIndexBlue, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>glUniformBlockBinding(shaderYellow.ID, uniformBlockIndexYellow, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>Ensuite, nous créons l&rsquo;objet tampon uniforme proprement dit et le lions au point de liaison 0 :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> uboMatrices
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">glGenBuffers</span>(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>uboMatrices);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);
</span></span><span style="display:flex;"><span>glBufferData(GL_UNIFORM_BUFFER, <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(glm<span style="color:#f92672">::</span>mat4), NULL, GL_STATIC_DRAW);
</span></span><span style="display:flex;"><span>glBindBuffer(GL_UNIFORM_BUFFER, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>glBindBufferRange(GL_UNIFORM_BUFFER, <span style="color:#ae81ff">0</span>, uboMatrices, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(glm<span style="color:#f92672">::</span>mat4));
</span></span></code></pre></div><p>Tout d&rsquo;abord, nous allouons suffisamment de mémoire pour notre tampon qui est égal à 2 fois la taille de <code>glm::mat4</code>. La taille des matrices GLM correspond directement à <code>mat4</code> en GLSL. Ensuite, nous lions une plage spécifique du tampon, dans ce cas le tampon entier, au point de liaison 0.</p>
<p>Il ne reste plus qu&rsquo;à remplir le tampon. Si nous maintenons constante la valeur du champ de vision de la matrice de projection (donc plus de zoom de la caméra), nous ne devons la mettre à jour qu&rsquo;une seule fois dans notre application - ce qui signifie que nous ne devons l&rsquo;insérer dans le tampon qu&rsquo;une seule fois également. Comme nous avons déjà alloué suffisamment de mémoire à l&rsquo;objet tampon, nous pouvons utiliser <code>glBufferSubData</code> pour stocker la matrice de projection avant d&rsquo;entrer dans la boucle de rendu :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glm<span style="color:#f92672">::</span>mat4 projection <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>perspective(glm<span style="color:#f92672">::</span>radians(<span style="color:#ae81ff">45.0f</span>), (<span style="color:#66d9ef">float</span>)width<span style="color:#f92672">/</span>(<span style="color:#66d9ef">float</span>)height, <span style="color:#ae81ff">0.1f</span>, <span style="color:#ae81ff">100.0f</span>);
</span></span><span style="display:flex;"><span>glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);
</span></span><span style="display:flex;"><span>glBufferSubData(GL_UNIFORM_BUFFER, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(glm<span style="color:#f92672">::</span>mat4), glm<span style="color:#f92672">::</span>value_ptr(projection));
</span></span><span style="display:flex;"><span>glBindBuffer(GL_UNIFORM_BUFFER, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>Ici, nous stockons la première moitié du tampon uniforme avec la matrice de projection. Ensuite, avant de rendre les objets à chaque image, nous mettons à jour la seconde moitié de la mémoire tampon avec la matrice de visualisation :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glm<span style="color:#f92672">::</span>mat4 view <span style="color:#f92672">=</span> camera.GetViewMatrix();	       
</span></span><span style="display:flex;"><span>glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);
</span></span><span style="display:flex;"><span>glBufferSubData(GL_UNIFORM_BUFFER, <span style="color:#66d9ef">sizeof</span>(glm<span style="color:#f92672">::</span>mat4), <span style="color:#66d9ef">sizeof</span>(glm<span style="color:#f92672">::</span>mat4), glm<span style="color:#f92672">::</span>value_ptr(view));
</span></span><span style="display:flex;"><span>glBindBuffer(GL_UNIFORM_BUFFER, <span style="color:#ae81ff">0</span>);  
</span></span></code></pre></div><p>Et c&rsquo;est tout pour les objets tampons uniformes. Chaque vertex shader qui contient un bloc uniforme Matrices contiendra désormais les données stockées dans <code>uboMatrices</code>. Ainsi, si nous dessinons 4 cubes en utilisant 4 shaders différents, leur projection et leur matrice de vue devraient être identiques :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glBindVertexArray(cubeVAO);
</span></span><span style="display:flex;"><span>shaderRed.use();
</span></span><span style="display:flex;"><span>glm<span style="color:#f92672">::</span>mat4 model <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>mat4(<span style="color:#ae81ff">1.0f</span>);
</span></span><span style="display:flex;"><span>model <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>translate(model, glm<span style="color:#f92672">::</span>vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">0.75f</span>, <span style="color:#ae81ff">0.75f</span>, <span style="color:#ae81ff">0.0f</span>));	<span style="color:#75715e">// move top-left
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>shaderRed.setMat4(<span style="color:#e6db74">&#34;model&#34;</span>, model);
</span></span><span style="display:flex;"><span>glDrawArrays(GL_TRIANGLES, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">36</span>);        
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ... draw Green Cube
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ... draw Blue Cube
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ... draw Yellow Cube	
</span></span></span></code></pre></div><p>Le seul uniforme que nous devons encore définir est l&rsquo;uniforme du modèle. L&rsquo;utilisation d&rsquo;objets tampons uniformes dans un scénario comme celui-ci nous permet d&rsquo;éviter un certain nombre d&rsquo;appels d&rsquo;uniformes par shader. Le résultat ressemble à ceci :
<img src="/docs/LEARNOPENGL_FR/04_Advanced_OpenGL/advanced_glsl_uniform_buffer_objects.png" alt="advanced_glsl_uniform_buffer_objects"/>
Chacun des cubes est déplacé d&rsquo;un côté de la fenêtre par translation de la matrice du modèle et, grâce aux différents shaders de fragment, leurs couleurs diffèrent selon l&rsquo;objet. Il s&rsquo;agit d&rsquo;un scénario relativement simple d&rsquo;utilisation des objets tampons uniformes, mais toute grande application de rendu peut avoir des centaines de programmes de shaders actifs, et c&rsquo;est là que les objets tampons uniformes commencent vraiment à briller.</p>
<p>Vous pouvez trouver le code source complet de l&rsquo;exemple d&rsquo;application uniforme <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/8.advanced_glsl_ubo/advanced_glsl_ubo.cpp">ici</a>.</p>
<p>Les objets tampons uniformes présentent plusieurs avantages par rapport aux uniformes individuels. Tout d&rsquo;abord, il est plus rapide de définir un grand nombre d&rsquo;uniformes à la fois que de définir plusieurs uniformes un par un. Deuxièmement, si vous voulez changer le même uniforme sur plusieurs shaders, il est beaucoup plus facile de changer un uniforme une fois dans un tampon d&rsquo;uniformes. Un dernier avantage qui n&rsquo;est pas immédiatement apparent est que vous pouvez utiliser beaucoup plus d&rsquo;uniformes dans les shaders en utilisant des objets tampons uniformes. OpenGL a une limite à la quantité de données d&rsquo;uniformes qu&rsquo;il peut gérer, qui peut être interrogée avec <code>GL_MAX_VERTEX_UNIFORM_COMPONENTS</code>. Lorsque l&rsquo;on utilise des objets tampons uniformes, cette limite est beaucoup plus élevée. Ainsi, lorsque vous atteignez un nombre maximum d&rsquo;uniformes (lors d&rsquo;une animation squelettique par exemple), il y a toujours des objets tampons uniformes.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hrst4.xyz/">hrst4&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
