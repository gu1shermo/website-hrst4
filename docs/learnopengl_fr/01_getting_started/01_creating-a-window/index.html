<!DOCTYPE html>
<html lang="en-us"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<body><header>
    <nav class="navbar" role="navigation">
        <div class="container">
            <div class="navbar-brand">
                <a href="/" title="home" class="navbar-item">
                    <span class="logo"><h1>hrst4&#39;s blog</h1></span>
                </a>
                
                <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                </a>
            </div>

            <div class="navbar-menu">
                <div class="navbar-start">
                    
                    <a href="/apropos" class="navbar-item">apropos</a>
                    
                    <a href="/docs" class="navbar-item">docs</a>
                    
                </div>
                <div class="navbar-end">
                    
                </div>
            </div>

        </div>
    </nav>
    <script>
        $(document).ready(function () {
            $(".navbar-burger").click(function () {
                $(".navbar-burger").toggleClass("is-active");
                $(".navbar-menu").toggleClass("is-active");
            })
        })
    </script>
</header><main>

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="créer-une-fenêtre">Créer une fenêtre<a hidden class="anchor" aria-hidden="true" href="#créer-une-fenêtre">#</a></h1>
<p>La première chose à faire avant de commencer à créer des graphiques étonnants est de créer un contexte OpenGL et une fenêtre d&rsquo;application pour dessiner. Cependant, ces opérations sont spécifiques à chaque système d&rsquo;exploitation et OpenGL essaie délibérément de s&rsquo;abstraire de ces opérations. Cela signifie que nous devons créer une fenêtre, définir un contexte et gérer l&rsquo;entrée de l&rsquo;utilisateur par nous-mêmes.</p>
<p>Heureusement, il existe de nombreuses bibliothèques qui fournissent les fonctionnalités que nous recherchons, dont certaines sont spécifiquement destinées à OpenGL. Ces bibliothèques nous épargnent tout le travail spécifique au système d&rsquo;exploitation et nous donnent une fenêtre et un contexte OpenGL pour effectuer le rendu. Certaines des bibliothèques les plus populaires sont <strong>GLUT</strong>, <strong>SDL</strong>, <strong>SFML</strong> et <strong>GLFW</strong>. Sur LearnOpenGL, nous utiliserons GLFW. N&rsquo;hésitez pas à utiliser n&rsquo;importe quelle autre bibliothèque, la configuration de la plupart d&rsquo;entre elles est similaire à celle de GLFW.</p>
<h2 id="glfw">GLFW<a hidden class="anchor" aria-hidden="true" href="#glfw">#</a></h2>
<p>GLFW est une bibliothèque, écrite en C, spécifiquement destinée à OpenGL. GLFW nous fournit le strict nécessaire pour le rendu de goodies à l&rsquo;écran. <strong>Il nous permet de créer un contexte OpenGL, de définir les paramètres de la fenêtre, et de gérer les entrées utilisateur, ce qui est largement suffisant pour nos besoins.</strong></p>
<p>L&rsquo;objectif de ce chapitre et du suivant est de faire fonctionner GLFW, en s&rsquo;assurant qu&rsquo;il crée correctement un contexte OpenGL et qu&rsquo;il affiche une fenêtre simple dans laquelle nous pourrons nous amuser. Ce chapitre adopte une approche étape par étape pour récupérer, construire et lier la bibliothèque GLFW. Nous utiliserons l&rsquo;IDE Microsoft Visual Studio 2019 à partir de cet écrit (notez que le processus est le même sur les versions plus récentes de Visual Studio). Si vous n&rsquo;utilisez pas Visual Studio (ou une version plus ancienne), ne vous inquiétez pas, le processus sera similaire sur la plupart des autres IDE.</p>
<h2 id="construction-build-de-glfw">Construction (build) de GLFW<a hidden class="anchor" aria-hidden="true" href="#construction-build-de-glfw">#</a></h2>
<p>GLFW peut être obtenu à partir de la page de <a href="http://www.glfw.org/download.html">téléchargement</a> de leur site web. GLFW dispose déjà de binaires précompilés et de fichiers d&rsquo;en-tête pour Visual Studio 2012 jusqu&rsquo;à 2019, mais par souci d&rsquo;exhaustivité, nous allons compiler GLFW nous-mêmes à partir du code source. Ceci afin de vous donner une idée du processus de compilation des bibliothèques open-source, car toutes les bibliothèques ne disposent pas de binaires précompilés. Téléchargeons donc le paquet source.</p>
<blockquote>
<p>Nous compilerons toutes les bibliothèques sous forme de binaires 64 bits. Assurez-vous donc d&rsquo;obtenir les binaires 64 bits si vous utilisez leurs binaires précompilés.</p>
</blockquote>
<p>Une fois que vous avez téléchargé le paquet source, extrayez-le et ouvrez son contenu. Seuls quelques éléments nous intéressent :</p>
<ul>
<li>La bibliothèque résultant de la compilation.</li>
<li>Le dossier include.</li>
</ul>
<p>La compilation de la bibliothèque à partir du code source garantit que la bibliothèque résultante est parfaitement adaptée à votre CPU/OS, un luxe que les binaires précompilés n&rsquo;offrent pas toujours (parfois, les binaires précompilés ne sont pas disponibles pour votre système). Le problème avec la mise à disposition du code source dans le monde ouvert est que tout le monde n&rsquo;utilise pas le même IDE ou le même système de construction pour développer son application, ce qui signifie que les fichiers de projet/solution fournis peuvent ne pas être compatibles avec la configuration d&rsquo;autres personnes. Les utilisateurs doivent alors configurer leur propre projet/solution avec les fichiers .c/.cpp et .h/.hpp fournis, ce qui est fastidieux. C&rsquo;est précisément pour ces raisons qu&rsquo;il existe un outil appelé <strong>CMake</strong>.</p>
<h2 id="cmake">CMake<a hidden class="anchor" aria-hidden="true" href="#cmake">#</a></h2>
<p>CMake est un outil qui peut générer des fichiers de projet/solution au choix de l&rsquo;utilisateur (par exemple Visual Studio, Code::Blocks, Eclipse) à partir d&rsquo;une collection de fichiers de code source en utilisant des scripts CMake prédéfinis. Cela nous permet de générer un fichier de projet Visual Studio 2019 à partir du paquetage source de GLFW que nous pouvons utiliser pour compiler la bibliothèque. Tout d&rsquo;abord, nous devons télécharger et installer CMake qui peut être téléchargé sur leur page de <a href="http://www.cmake.org/cmake/resources/software.html">téléchargement</a>.</p>
<p>Une fois CMake installé, vous pouvez choisir d&rsquo;exécuter CMake à partir de la ligne de commande ou via leur interface graphique. Comme nous n&rsquo;essayons pas de compliquer les choses, nous allons utiliser l&rsquo;interface graphique. CMake nécessite un dossier de code source et un dossier de destination pour les binaires. Pour le dossier du code source, nous allons choisir le dossier racine du paquetage source GLFW téléchargé et pour le dossier de build, nous allons créer un nouveau répertoire build et sélectionner ce répertoire.
<img src="/docs/LEARNOPENGL_FR/01_Getting_Started/img/window1.png" alt="window1"/>
Une fois les dossiers source et destination définis, cliquez sur le bouton Configure pour que CMake puisse lire les paramètres requis et le code source. Nous devons ensuite choisir le générateur du projet et comme nous utilisons Visual Studio 2019, nous choisirons l&rsquo;option Visual Studio 16 (<strong>Visual Studio 2019 est également connu sous le nom de Visual Studio 16</strong>). CMake affichera alors les options de construction possibles pour configurer la bibliothèque résultante. Nous pouvons les laisser à leurs valeurs par défaut et cliquer à nouveau sur Configure pour enregistrer les paramètres. Une fois les paramètres définis, nous cliquons sur Generate et les fichiers de projet résultants seront générés dans votre dossier de construction.</p>
<h2 id="compilation">Compilation<a hidden class="anchor" aria-hidden="true" href="#compilation">#</a></h2>
<p>Dans le dossier de build, un fichier nommé <code>GLFW.sln</code> peut maintenant être trouvé et nous l&rsquo;ouvrons avec Visual Studio 2019. Puisque CMake a généré un fichier de projet qui contient déjà les paramètres de configuration appropriés, nous n&rsquo;avons plus qu&rsquo;à construire la solution. CMake devrait avoir automatiquement configuré la solution pour qu&rsquo;elle se compile en une bibliothèque 64 bits ; maintenant, appuyez sur build solution. Cela nous donnera un fichier de bibliothèque compilé qui peut être trouvé dans build/src/Debug nommé <code>glfw3.lib</code>.</p>
<p>Une fois la bibliothèque générée, nous devons nous assurer que l&rsquo;IDE sait où trouver la bibliothèque et les fichiers d&rsquo;inclusion pour notre programme OpenGL. Il y a deux approches communes pour faire cela :</p>
<ol>
<li>Nous trouvons les dossiers <code>/lib</code> et <code>/include</code> de l&rsquo;IDE/compilateur et ajoutons le contenu du dossier <code>include</code> de GLFW au dossier <code>/include</code> de l&rsquo;IDE et ajoutons de la même manière <code>glfw3.lib</code> au dossier <code>/lib</code> de l&rsquo;IDE. Cela fonctionne, mais ce n&rsquo;est pas l&rsquo;approche recommandée. Il est difficile de garder une trace de votre bibliothèque et des fichiers inclus et une nouvelle installation de votre IDE/compilateur vous oblige à recommencer ce processus.</li>
<li>Une autre approche (recommandée) consiste à créer un nouvel ensemble de répertoires à l&rsquo;emplacement de votre choix, contenant tous les fichiers d&rsquo;en-tête/librairies de tiers auxquels vous pouvez vous référer à partir de votre IDE/compilateur. Vous pouvez, par exemple, créer un seul dossier qui contient un dossier <code>Libs</code> et <code>Include</code> où nous stockons toutes nos bibliothèques et fichiers d&rsquo;en-tête respectivement pour les projets OpenGL. Maintenant, toutes les bibliothèques tierces sont organisées en un seul endroit (qui peut être partagé entre plusieurs ordinateurs). Cependant, à chaque fois que nous créons un nouveau projet, nous devons indiquer à l&rsquo;IDE où trouver ces répertoires.</li>
</ol>
<p>Une fois que les fichiers nécessaires sont stockés à l&rsquo;emplacement de votre choix, nous pouvons commencer à créer notre premier projet OpenGL GLFW.</p>
<h2 id="notre-premier-projet">Notre premier projet<a hidden class="anchor" aria-hidden="true" href="#notre-premier-projet">#</a></h2>
<p>Tout d&rsquo;abord, ouvrons Visual Studio et créons un nouveau projet. Choisissez C++ si plusieurs options sont proposées et prenez le projet vide (n&rsquo;oubliez pas de donner un nom approprié à votre projet). Comme nous allons tout faire en 64 bits et que le projet est par défaut en 32 bits, nous devrons changer la liste déroulante en haut à côté de Debug de x86 à x64 :
<img src="/docs/LEARNOPENGL_FR/01_Getting_Started/img/window2.png" alt="window2"/>
Une fois cela fait, nous avons maintenant un espace de travail pour créer notre toute première application OpenGL !</p>
<h2 id="linking-création-de-liens">Linking (création de liens)<a hidden class="anchor" aria-hidden="true" href="#linking-création-de-liens">#</a></h2>
<p>Pour que le projet puisse utiliser GLFW, nous devons lier la bibliothèque à notre projet. Cela peut être fait en spécifiant que nous voulons utiliser <code>glfw3.lib</code> dans les paramètres de l&rsquo;éditeur de liens, mais notre projet ne sait pas encore où trouver <code>glfw3.lib</code> puisque nous stockons nos bibliothèques tierces dans un répertoire différent. Nous devons donc d&rsquo;abord ajouter ce répertoire au projet.</p>
<p>Nous pouvons dire à l&rsquo;IDE de prendre en compte ce répertoire lorsqu&rsquo;il doit rechercher des fichiers de bibliothèque et d&rsquo;inclusion. Cliquez avec le bouton droit de la souris sur le nom du projet dans l&rsquo;explorateur de solutions et allez ensuite dans VC++ Directories comme le montre l&rsquo;image ci-dessous :
<img src="/docs/LEARNOPENGL_FR/01_Getting_Started/img/window3.png" alt="window3"/>
À partir de là, vous pouvez ajouter vos propres répertoires pour indiquer au projet où chercher. Vous pouvez le faire en l&rsquo;insérant manuellement dans le texte ou en cliquant sur la chaîne de caractères appropriée et en sélectionnant l&rsquo;option <code>&lt;Editer..&gt;</code>. Procédez de la même manière pour les répertoires <code>Library</code> et <code>Include</code> :
<img src="/docs/LEARNOPENGL_FR/01_Getting_Started/img/window4.png" alt="window4"/>
Ici, vous pouvez ajouter autant de répertoires supplémentaires que vous le souhaitez et à partir de ce moment, l&rsquo;IDE recherchera également ces répertoires lors de la recherche de bibliothèques et de fichiers d&rsquo;en-tête. Dès que votre dossier Include de GLFW est inclus, vous pourrez trouver tous les fichiers d&rsquo;en-tête pour GLFW en incluant . Il en va de même pour les répertoires de bibliothèques.</p>
<p>Puisque VS peut maintenant trouver tous les fichiers nécessaires, nous pouvons enfin lier GLFW au projet en allant dans l&rsquo;onglet <code>Linker</code> et <code>Input</code> :
<img src="/docs/LEARNOPENGL_FR/01_Getting_Started/img/window5.png" alt="window5"/>
Pour lier à une bibliothèque, il faut spécifier le nom de la bibliothèque à l&rsquo;éditeur de liens. Puisque le nom de la bibliothèque est <code>glfw3.lib</code>, nous l&rsquo;ajoutons au champ Dépendances supplémentaires (soit manuellement, soit en utilisant l&rsquo;option ) et à partir de là, GLFW sera lié lors de la compilation. En plus de GLFW, nous devrions également ajouter une entrée de lien vers la bibliothèque OpenGL, mais cela peut différer d&rsquo;un système d&rsquo;exploitation à l&rsquo;autre :</p>
<h3 id="bibliothèque-opengl-sous-windows">Bibliothèque OpenGL sous Windows<a hidden class="anchor" aria-hidden="true" href="#bibliothèque-opengl-sous-windows">#</a></h3>
<p>Si vous êtes sous Windows, la bibliothèque OpenGL <code>opengl32.lib</code> est fournie avec le SDK de Microsoft, qui est installé par défaut lorsque vous installez Visual Studio. Puisque ce chapitre utilise le compilateur VS et est sous Windows, nous ajoutons <code>opengl32.lib</code> aux paramètres de l&rsquo;éditeur de liens. Notez que l&rsquo;équivalent 64 bits de la bibliothèque OpenGL s&rsquo;appelle <code>opengl32.lib</code>, tout comme l&rsquo;équivalent 32 bits, ce qui est un nom un peu malheureux.</p>
<h3 id="bibliothèque-opengl-sous-linux">Bibliothèque OpenGL sous Linux<a hidden class="anchor" aria-hidden="true" href="#bibliothèque-opengl-sous-linux">#</a></h3>
<p>Sur les systèmes Linux, vous devez vous lier à la bibliothèque <code>libGL.so</code> en ajoutant <code>-lGL</code> aux paramètres de votre éditeur de liens. Si vous ne trouvez pas cette bibliothèque, vous devez probablement installer l&rsquo;un des paquets de développement Mesa, NVidia ou AMD.</p>
<p>Ensuite, une fois que vous avez ajouté les bibliothèques GLFW et OpenGL aux paramètres de l&rsquo;éditeur de liens, vous pouvez inclure les fichiers d&rsquo;en-tête pour GLFW comme suit :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;GLFW/glfw3.h&gt;</span><span style="color:#75715e">
</span></span></span></code></pre></div><blockquote>
<p>Pour les utilisateurs de Linux qui compilent avec GCC, les options de ligne de commande suivantes peuvent vous aider à compiler le projet : -lglfw3 -lGL -lX11 -lpthread -lXrandr -lXi -ldl. Le fait de ne pas lier correctement les bibliothèques correspondantes générera de nombreuses erreurs de référence non définie.</p>
</blockquote>
<p>Ceci conclut l&rsquo;installation et la configuration de GLFW.</p>
<h2 id="glad">GLAD<a hidden class="anchor" aria-hidden="true" href="#glad">#</a></h2>
<p>Nous ne sommes pas encore tout à fait au point, car il reste encore une chose à faire. Parce qu&rsquo;OpenGL n&rsquo;est qu&rsquo;une norme/spécification, c&rsquo;est au fabricant du pilote d&rsquo;implémenter la spécification dans un pilote que la carte graphique supporte. Comme il existe de nombreuses versions différentes des pilotes OpenGL, l&rsquo;emplacement de la plupart de ses fonctions n&rsquo;est pas connu à la compilation et doit être interrogé à l&rsquo;exécution. Il incombe alors au développeur de récupérer l&rsquo;emplacement des fonctions dont il a besoin et de les stocker dans des pointeurs de fonction pour une utilisation ultérieure. La récupération de ces emplacements est spécifique au système d&rsquo;exploitation. Sous Windows, cela ressemble à quelque chose comme ceci :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// define the function&#39;s prototype
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span> (<span style="color:#f92672">*</span>GL_GENBUFFERS) (GLsizei, GLuint<span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// find the function and assign it to a function pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>GL_GENBUFFERS glGenBuffers  <span style="color:#f92672">=</span> (GL_GENBUFFERS)wglGetProcAddress(<span style="color:#e6db74">&#34;glGenBuffers&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// function can now be called as normal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> buffer;
</span></span><span style="display:flex;"><span>glGenBuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>buffer);
</span></span></code></pre></div><p>Comme vous pouvez le constater, le code est complexe et il est fastidieux de le faire pour chaque fonction dont vous pourriez avoir besoin et qui n&rsquo;est pas encore déclarée. Heureusement, il existe des bibliothèques à cet effet, dont GLAD, qui est une bibliothèque populaire et à jour.</p>
<h3 id="paramétrer-glad">Paramétrer GLAD<a hidden class="anchor" aria-hidden="true" href="#paramétrer-glad">#</a></h3>
<p>GLAD est une bibliothèque open source qui gère tout ce travail fastidieux dont nous avons parlé. GLAD a une configuration légèrement différente de la plupart des bibliothèques open source. GLAD utilise un service web qui permet d&rsquo;indiquer à GLAD la version d&rsquo;OpenGL que l&rsquo;on souhaite définir et de charger toutes les fonctions OpenGL pertinentes en fonction de cette version.</p>
<p>Allez sur le <a href="http://glad.dav1d.de/">service web</a> GLAD, assurez-vous que le langage est défini sur C++, et dans la section API sélectionnez une version d&rsquo;OpenGL d&rsquo;au moins 3.3 (c&rsquo;est ce que nous utiliserons ; des versions plus élevées sont également acceptables). Assurez-vous également que le profil est défini sur Core et que l&rsquo;option <em>Generate a loader</em> est cochée. Ignorez les extensions (pour l&rsquo;instant) et cliquez sur <em>Generate</em> pour produire les fichiers de bibliothèque résultants.</p>
<p>GLAD devrait maintenant vous avoir fourni un fichier zip contenant deux dossiers include, et un seul fichier <code>glad.c</code>. Copiez les deux dossiers <code>include</code> (<code>glad</code> et <code>KHR</code>) dans votre répertoire include(s) (ou ajoutez un élément supplémentaire pointant vers ces dossiers), et ajoutez le fichier <code>glad.c</code> à votre projet.</p>
<p>Après les étapes précédentes, vous devriez être en mesure d&rsquo;ajouter la directive include suivante au-dessus de votre fichier :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;glad/glad.h&gt; </span><span style="color:#75715e">
</span></span></span></code></pre></div><p>En appuyant sur le bouton de compilation, vous ne devriez pas avoir d&rsquo;erreurs, et nous sommes prêts pour le prochain chapitre où nous verrons comment utiliser GLFW et GLAD pour configurer un contexte OpenGL et faire apparaître une fenêtre. Assurez-vous que tous vos répertoires include et library sont corrects et que les noms des librairies dans les paramètres de l&rsquo;éditeur de liens correspondent aux librairies correspondantes.</p>
<h2 id="ressources-supplémentaires">Ressources supplémentaires<a hidden class="anchor" aria-hidden="true" href="#ressources-supplémentaires">#</a></h2>
<ul>
<li>GLFW : <a href="http://www.glfw.org/docs/latest/window_guide.html">Window Guide</a> : guide officiel de GLFW sur la mise en place et la configuration d&rsquo;une fenêtre GLFW.</li>
<li><a href="http://www.opengl-tutorial.org/miscellaneous/building-your-own-c-application/">Building applications</a> : fournit d&rsquo;excellentes informations sur le processus de compilation/liaison de votre application, ainsi qu&rsquo;une longue liste d&rsquo;erreurs possibles (avec leurs solutions).</li>
<li><a href="http://wiki.codeblocks.org/index.php?title=Using_GLFW_with_Code::Blocks">GLFW avec Code::Blocks</a> : construction de GLFW dans l&rsquo;IDE Code::Blocks.</li>
<li><a href="http://www.cmake.org/runningcmake/">Running CMake</a> : bref aperçu de l&rsquo;exécution de CMake sous Windows et Linux.</li>
<li><a href="https://learnopengl.com/demo/autotools_tutorial.txt">Writing a build system under Linux</a> : un tutoriel autotools par Wouter Verholst sur la façon d&rsquo;écrire un système de compilation sous Linux.</li>
<li><a href="https://github.com/Polytonic/Glitter">Polytonic/Glitter</a> : un simple projet de base qui est préconfiguré avec toutes les bibliothèques pertinentes ; idéal si vous voulez un exemple de projet sans avoir à compiler toutes les bibliothèques vous-même.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://hrst4.xyz/tags/cg/">cg</a></li>
      <li><a href="https://hrst4.xyz/tags/opengl/">opengl</a></li>
      <li><a href="https://hrst4.xyz/tags/computer-graphics/">computer graphics</a></li>
      <li><a href="https://hrst4.xyz/tags/cpp/">cpp</a></li>
    </ul>
  </footer>
</article>
        </main>
<footer class="footer">
    <span>&copy; 2023 <a href="https://hrst4.xyz/">hrst4&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>
</html>