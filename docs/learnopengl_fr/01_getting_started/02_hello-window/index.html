<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>hrst4&#39;s blog</title>
<meta name="keywords" content="cg, opengl, computer graphics, cpp">
<meta name="description" content="Hello Window Voyons si nous pouvons faire fonctionner GLFW. Tout d&rsquo;abord, créez un fichier .cpp et ajoutez les inclusions suivantes au début de votre fichier nouvellement créé.
#include &lt;glad/glad.h&gt; #include &lt;GLFW/glfw3.h&gt; Assurez-vous d&rsquo;inclure GLAD avant GLFW. Le fichier include de GLAD inclut les en-têtes OpenGL nécessaires dans les coulisses (comme GL/gl.h). Il faut donc s&rsquo;assurer d&rsquo;inclure GLAD avant les autres fichiers d&rsquo;en-tête qui nécessitent OpenGL (comme GLFW).
Ensuite, nous créons la fonction principale dans laquelle nous allons instancier la fenêtre GLFW:">
<meta name="author" content="">
<link rel="canonical" href="https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/02_hello-window/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://hrst4.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hrst4.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hrst4.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hrst4.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://hrst4.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="Hello Window Voyons si nous pouvons faire fonctionner GLFW. Tout d&rsquo;abord, créez un fichier .cpp et ajoutez les inclusions suivantes au début de votre fichier nouvellement créé.
#include &lt;glad/glad.h&gt; #include &lt;GLFW/glfw3.h&gt; Assurez-vous d&rsquo;inclure GLAD avant GLFW. Le fichier include de GLAD inclut les en-têtes OpenGL nécessaires dans les coulisses (comme GL/gl.h). Il faut donc s&rsquo;assurer d&rsquo;inclure GLAD avant les autres fichiers d&rsquo;en-tête qui nécessitent OpenGL (comme GLFW).
Ensuite, nous créons la fonction principale dans laquelle nous allons instancier la fenêtre GLFW:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/02_hello-window/" /><meta property="article:section" content="docs" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Hello Window Voyons si nous pouvons faire fonctionner GLFW. Tout d&rsquo;abord, créez un fichier .cpp et ajoutez les inclusions suivantes au début de votre fichier nouvellement créé.
#include &lt;glad/glad.h&gt; #include &lt;GLFW/glfw3.h&gt; Assurez-vous d&rsquo;inclure GLAD avant GLFW. Le fichier include de GLAD inclut les en-têtes OpenGL nécessaires dans les coulisses (comme GL/gl.h). Il faut donc s&rsquo;assurer d&rsquo;inclure GLAD avant les autres fichiers d&rsquo;en-tête qui nécessitent OpenGL (comme GLFW).
Ensuite, nous créons la fonction principale dans laquelle nous allons instancier la fenêtre GLFW:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Docs",
      "item": "https://hrst4.xyz/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/02_hello-window/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "Hello Window Voyons si nous pouvons faire fonctionner GLFW. Tout d\u0026rsquo;abord, créez un fichier .cpp et ajoutez les inclusions suivantes au début de votre fichier nouvellement créé.\n#include \u0026lt;glad/glad.h\u0026gt; #include \u0026lt;GLFW/glfw3.h\u0026gt; Assurez-vous d\u0026rsquo;inclure GLAD avant GLFW. Le fichier include de GLAD inclut les en-têtes OpenGL nécessaires dans les coulisses (comme GL/gl.h). Il faut donc s\u0026rsquo;assurer d\u0026rsquo;inclure GLAD avant les autres fichiers d\u0026rsquo;en-tête qui nécessitent OpenGL (comme GLFW).\nEnsuite, nous créons la fonction principale dans laquelle nous allons instancier la fenêtre GLFW:",
  "keywords": [
    "cg", "opengl", "computer graphics", "cpp"
  ],
  "articleBody": "Hello Window Voyons si nous pouvons faire fonctionner GLFW. Tout d’abord, créez un fichier .cpp et ajoutez les inclusions suivantes au début de votre fichier nouvellement créé.\n#include #include Assurez-vous d’inclure GLAD avant GLFW. Le fichier include de GLAD inclut les en-têtes OpenGL nécessaires dans les coulisses (comme GL/gl.h). Il faut donc s’assurer d’inclure GLAD avant les autres fichiers d’en-tête qui nécessitent OpenGL (comme GLFW).\nEnsuite, nous créons la fonction principale dans laquelle nous allons instancier la fenêtre GLFW:\nint main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); return 0; } Dans la fonction principale, nous commençons par initialiser GLFW avec glfwInit, après quoi nous pouvons configurer GLFW en utilisant glfwWindowHint. Le premier argument de glfwWindowHint nous indique l’option que nous voulons configurer, où nous pouvons sélectionner l’option à partir d’une grande liste d’options possibles préfixées par GLFW_. Le deuxième argument est un entier qui définit la valeur de notre option. Une liste de toutes les options possibles et de leurs valeurs correspondantes peut être trouvée dans la documentation sur la gestion des fenêtres de GLFW. Si vous essayez d’exécuter l’application maintenant et qu’elle produit un grand nombre d’erreurs de références non définies, cela signifie que vous n’avez pas réussi à lier la bibliothèque GLFW.\nPuisque ce livre se concentre sur la version 3.3 d’OpenGL, nous aimerions dire à GLFW que la version 3.3 est la version d’OpenGL que nous voulons utiliser. De cette manière, GLFW peut prendre les dispositions nécessaires lors de la création du contexte OpenGL. Cela permet de s’assurer que lorsqu’un utilisateur n’a pas la bonne version d’OpenGL, GLFW ne s’exécute pas. Nous fixons la version majeure et mineure à 3. Nous indiquons également à GLFW que nous voulons utiliser explicitement le core-profile. Dire à GLFW que nous voulons utiliser le core-profile signifie que nous aurons accès à un sous-ensemble plus petit de fonctionnalités OpenGL sans fonctionnalités rétrocompatibles dont nous n’avons plus besoin. Notez que sous Mac OS X, vous devez ajouter glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE) ; à votre code d’initialisation pour que cela fonctionne.\nAssurez-vous que les versions 3.3 ou plus d’OpenGL sont installées sur votre système/matériel, sinon l’application plantera ou affichera un comportement indéfini. Pour connaître la version d’OpenGL sur votre machine, appelez glxinfo sur les machines Linux ou utilisez un utilitaire comme OpenGL Extension Viewer pour Windows. Si la version supportée est inférieure, essayez de vérifier si votre carte vidéo supporte OpenGL 3.3+ (sinon elle est vraiment vieille) et/ou mettez à jour vos pilotes.\nEnsuite, nous devons créer un objet fenêtre. Cet objet contient toutes les données de fenêtrage et est nécessaire à la plupart des autres fonctions de GLFW.\nGLFWwindow* window = glfwCreateWindow(800, 600, \"LearnOpenGL\", NULL, NULL); if (window == NULL) { std::cout \u003c\u003c \"Failed to create GLFW window\" \u003c\u003c std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); La fonction glfwCreateWindow requiert la largeur et la hauteur de la fenêtre comme ses deux premiers arguments respectivement. Le troisième argument nous permet de créer un nom pour la fenêtre ; pour l’instant nous l’appelons “LearnOpenGL” mais vous êtes autorisés à lui donner le nom que vous voulez. Nous pouvons ignorer les deux derniers paramètres. La fonction renvoie un objet GLFWwindow dont nous aurons besoin plus tard pour d’autres opérations de GLFW. Après cela, nous demandons à GLFW de faire du contexte de notre fenêtre le contexte principal du thread courant.\nGLAD Dans le chapitre précédent, nous avons mentionné que GLAD gère les pointeurs de fonction pour OpenGL, nous voulons donc initialiser GLAD avant d’appeler une fonction OpenGL :\nif (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout \u003c\u003c \"Failed to initialize GLAD\" \u003c\u003c std::endl; return -1; } Nous passons à GLAD la fonction pour charger l’adresse des pointeurs de fonction OpenGL qui est spécifique au système d’exploitation. GLFW nous fournit glfwGetProcAddress qui définit la fonction correcte en fonction du système d’exploitation pour lequel nous compilons.\nViewport Avant de commencer le rendu, nous devons faire une dernière chose. Nous devons indiquer à OpenGL la taille de la fenêtre de rendu afin qu’OpenGL sache comment nous voulons afficher les données et les coordonnées par rapport à la fenêtre. Nous pouvons définir ces dimensions via la fonction glViewport :\nglViewport(0, 0, 800, 600); Les deux premiers paramètres de glViewport définissent l’emplacement du coin inférieur gauche de la fenêtre. Les troisième et quatrième paramètres définissent la largeur et la hauteur de la fenêtre de rendu en pixels, que nous fixons à la taille de la fenêtre de GLFW.\n**Nous pourrions en fait fixer les dimensions de la fenêtre à des valeurs inférieures à celles de GLFW **; ainsi, tout le rendu OpenGL serait affiché dans une fenêtre plus petite et nous pourrions, par exemple, afficher d’autres éléments en dehors de la fenêtre OpenGL.\nEn coulisses, OpenGL utilise les données spécifiées par glViewport pour transformer les coordonnées 2D qu’il a traitées en coordonnées sur votre écran. Par exemple, un point traité de la position (-0.5,0.5) serait (comme sa transformation finale) mappé à (200,450) en coordonnées d’écran. Notez que les coordonnées traitées dans OpenGL sont comprises entre -1 et 1, de sorte que nous mappons effectivement de l’intervalle (-1 à 1) à (0, 800) et (0, 600).\nCependant, lorsque l’utilisateur redimensionne la fenêtre, la fenêtre de visualisation doit également être ajustée. Nous pouvons enregistrer une fonction de rappel sur la fenêtre qui est appelée chaque fois que la fenêtre est redimensionnée. Cette fonction de rappel de redimensionnement a le prototype suivant :\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height); La fonction framebuffer_size_callback prend une fenêtre GLFW comme premier argument et deux entiers indiquant les nouvelles dimensions de la fenêtre. Chaque fois que la taille de la fenêtre change, GLFW appelle cette fonction et remplit les arguments appropriés pour que vous puissiez les traiter.\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height) { glViewport(0, 0, width, height); } Nous devons indiquer à GLFW que nous voulons appeler cette fonction à chaque redimensionnement de fenêtre en l’enregistrant :\nglfwSetFramebufferSizeCallback(window, framebuffer_size_callback); Lorsque la fenêtre est affichée pour la première fois, framebuffer_size_callback est également appelé avec les dimensions résultantes de la fenêtre. Pour les écrans Rétina, la largeur et la hauteur seront significativement plus élevées que les valeurs d’origine.\nIl existe de nombreuses fonctions de rappel que nous pouvons définir pour enregistrer nos propres fonctions. Par exemple, nous pouvons créer une fonction de rappel pour traiter les changements d’entrée du joystick, traiter les messages d’erreur, etc. Nous enregistrons les fonctions de rappel après avoir créé la fenêtre et avant que la boucle de rendu ne soit lancée.\nPréparez vos moteurs Nous ne voulons pas que l’application dessine une seule image, puis qu’elle quitte immédiatement et ferme la fenêtre. Nous voulons que l’application continue à dessiner des images et à gérer les entrées de l’utilisateur jusqu’à ce que le programme reçoive l’ordre explicite de s’arrêter. Pour cette raison, nous devons créer une boucle while, que nous appelons maintenant boucle de rendu, qui continue à fonctionner jusqu’à ce que nous demandions à GLFW de s’arrêter. Le code suivant montre une boucle de rendu très simple :\nwhile(!glfwWindowShouldClose(window)) { glfwSwapBuffers(window); glfwPollEvents(); } La fonction glfwWindowShouldClose vérifie au début de chaque itération de la boucle si GLFW a reçu l’ordre de se fermer. Si c’est le cas, la fonction renvoie vrai et la boucle de rendu s’arrête, après quoi nous pouvons fermer l’application.\nLa fonction glfwPollEvents vérifie si des événements sont déclenchés (comme des entrées clavier ou des mouvements de souris), met à jour l’état de la fenêtre et appelle les fonctions correspondantes (que nous pouvons enregistrer via des méthodes de rappel). La fonction glfwSwapBuffer va permuter le color buffer (un grand tampon 2D qui contient les valeurs de couleur pour chaque pixel de la fenêtre de GLFW) qui est utilisé pour le rendu pendant cette itération de rendu et l’afficher en sortie à l’écran.\nDouble buffer\nLorsqu’une application dessine dans une seule mémoire tampon, l’image résultante peut présenter des problèmes de scintillement. En effet, l’image résultante n’est pas dessinée en un instant, mais pixel par pixel, généralement de gauche à droite et de haut en bas. Comme cette image n’est pas affichée instantanément à l’utilisateur tout en étant rendue, le résultat peut contenir des artefacts. Pour contourner ces problèmes, les applications de fenêtrage utilisent une double mémoire tampon pour le rendu. La mémoire tampon avant (front buffer) contient l’image de sortie finale qui est affichée à l’écran, tandis que toutes les commandes de rendu dessinent dans la mémoire tampon arrière (back buffer). Dès que toutes les commandes de rendu sont terminées, le tampon arrière est remplacé par le tampon avant, de sorte que l’image peut être affichée sans être en train d’être rendue, ce qui supprime tous les artefacts susmentionnés.\nUne dernière chose Dès que nous sortons de la boucle de rendu, nous souhaitons nettoyer/supprimer correctement toutes les ressources de GLFW qui ont été allouées. Nous pouvons le faire via la fonction glfwTerminate que nous appelons à la fin de la fonction principale.\nglfwTerminate(); return 0; Ceci nettoiera toutes les ressources et quittera correctement l’application. Essayez maintenant de compiler votre application et si tout s’est bien passé, vous devriez voir la sortie suivante : Si c’est une image noire très terne et ennuyeuse, c’est que vous avez bien fait les choses ! Si vous n’avez pas obtenu la bonne image ou si vous ne savez pas comment tout s’articule, consultez le code source complet ici (et si des couleurs différentes ont commencé à clignoter, continuez à lire).\nSi vous avez des problèmes pour compiler l’application, assurez-vous d’abord que toutes les options de votre linker sont correctement réglées et que vous avez inclus les bons répertoires dans votre IDE (comme expliqué dans le chapitre précédent). Assurez-vous également que votre code est correct ; vous pouvez le vérifier en le comparant avec le code source complet.\nInput (entrée) Nous souhaitons également disposer d’une forme de contrôle des entrées dans GLFW et nous pouvons y parvenir grâce à plusieurs fonctions d’entrée de GLFW. Nous utiliserons la fonction glfwGetKey de GLFW qui prend la fenêtre en entrée ainsi qu’une touche. La fonction retourne si cette touche est actuellement pressée. Nous créons une fonction processInput pour organiser l’ensemble du code d’entrée :\nvoid processInput(GLFWwindow *window) { if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); } Nous vérifions ici si l’utilisateur a appuyé sur la touche d’échappement (si ce n’est pas le cas, glfwGetKey renvoie GLFW_RELEASE). Si l’utilisateur a appuyé sur la touche d’échappement, nous fermons GLFW en définissant sa propriété WindowShouldCloseà true à l’aide de glfwSetwindowShouldClose. La vérification de la condition suivante de la boucle while principale échoue alors et l’application se ferme.\nNous appelons ensuite processInput à chaque itération de la boucle de rendu :\nwhile (!glfwWindowShouldClose(window)) { processInput(window); glfwSwapBuffers(window); glfwPollEvents(); } Nous disposons ainsi d’un moyen simple de vérifier la présence de touches spécifiques et de réagir en conséquence à chaque image. Une itération de la boucle de rendu est plus communément appelée une image.\nRendering (le rendu) Nous voulons placer toutes les commandes de rendu dans la boucle de rendu, puisque nous voulons exécuter toutes les commandes de rendu à chaque itération ou image de la boucle. Cela ressemblerait un peu à ceci :\n// render loop while(!glfwWindowShouldClose(window)) { // input processInput(window); // rendering commands here ... // check and call events and swap the buffers glfwPollEvents(); glfwSwapBuffers(window); } Juste pour tester si les choses fonctionnent réellement, nous voulons effacer l’écran avec une couleur de notre choix. Au début de l’image, nous voulons effacer l’écran. Sinon, nous verrions toujours les résultats de l’image précédente (cela pourrait être l’effet recherché, mais en général ce n’est pas le cas). Nous pouvons effacer le tampon de couleur (color buffer) de l’écran en utilisant glClear où nous passons des bits de tampon (buffer bits) pour spécifier le tampon que nous voulons effacer. Les bits possibles sont GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT et GL_STENCIL_BUFFER_BIT. Pour l’instant, nous ne nous intéressons qu’aux valeurs de couleur et nous n’effaçons donc que le tampon de couleur.\nglClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); Notez que nous spécifions également la couleur à utiliser pour effacer l’écran à l’aide de glClearColor. Chaque fois que nous appelons glClear et que nous vidons le tampon de couleurs, celui-ci est entièrement rempli avec la couleur configurée par glClearColor. Il en résultera une couleur vert foncé-bleuâtre.\nComme vous vous en souvenez peut-être dans le chapitre sur OpenGL, la fonction glClearColor est une fonction de définition d’état et glClear est une fonction d’utilisation d’état en ce sens qu’elle utilise l’état actuel pour récupérer la couleur d’effacement.\nLe code source complet de l’application est disponible ici.\nNous avons maintenant tout ce qu’il faut pour remplir la boucle de rendu avec de nombreux appels de rendu, mais c’est pour le prochain chapitre. Je pense que nous avons assez divagué ici.\n",
  "wordCount" : "2112",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hrst4.xyz/docs/learnopengl_fr/01_getting_started/02_hello-window/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "hrst4's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hrst4.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hrst4.xyz/" accesskey="h" title="hrst4&#39;s blog (Alt + H)">hrst4&#39;s blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="hello-window">Hello Window<a hidden class="anchor" aria-hidden="true" href="#hello-window">#</a></h1>
<p>Voyons si nous pouvons faire fonctionner GLFW. Tout d&rsquo;abord, créez un fichier .cpp et ajoutez les inclusions suivantes au début de votre fichier nouvellement créé.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;glad/glad.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;GLFW/glfw3.h&gt;</span><span style="color:#75715e">
</span></span></span></code></pre></div><blockquote>
<p>Assurez-vous d&rsquo;inclure GLAD avant GLFW. Le fichier include de GLAD inclut les en-têtes OpenGL nécessaires dans les coulisses (comme <code>GL/gl.h</code>). Il faut donc s&rsquo;assurer d&rsquo;inclure GLAD avant les autres fichiers d&rsquo;en-tête qui nécessitent OpenGL (comme GLFW).</p>
</blockquote>
<p>Ensuite, nous créons la fonction principale dans laquelle nous allons instancier la fenêtre GLFW:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>   glfwInit();
</span></span><span style="display:flex;"><span>   glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>   glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>   glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Dans la fonction principale, nous commençons par initialiser GLFW avec <code>glfwInit</code>, après quoi nous pouvons configurer GLFW en utilisant <code>glfwWindowHint</code>.
Le premier argument de <code>glfwWindowHint</code> nous indique l&rsquo;option que nous voulons configurer, où nous pouvons sélectionner l&rsquo;option à partir d&rsquo;une grande liste d&rsquo;options possibles préfixées par <code>GLFW_</code>.
Le deuxième argument est un entier qui définit la valeur de notre option. Une liste de toutes les options possibles et de leurs valeurs correspondantes peut être trouvée dans la documentation sur la gestion des fenêtres de GLFW.
Si vous essayez d&rsquo;exécuter l&rsquo;application maintenant et qu&rsquo;elle produit un grand nombre d&rsquo;erreurs de références non définies, cela signifie que vous n&rsquo;avez pas réussi à lier la bibliothèque GLFW.</p>
<p>Puisque ce livre se concentre sur la version 3.3 d&rsquo;OpenGL, nous aimerions dire à GLFW que la version 3.3 est la version d&rsquo;OpenGL que nous voulons utiliser. De cette manière, GLFW peut prendre les dispositions nécessaires lors de la création du contexte OpenGL. Cela permet de s&rsquo;assurer que lorsqu&rsquo;un utilisateur n&rsquo;a pas la bonne version d&rsquo;OpenGL, GLFW ne s&rsquo;exécute pas. Nous fixons la version majeure et mineure à 3. Nous indiquons également à GLFW que nous voulons utiliser explicitement le core-profile. Dire à GLFW que nous voulons utiliser le core-profile signifie que nous aurons accès à un sous-ensemble plus petit de fonctionnalités OpenGL sans fonctionnalités rétrocompatibles dont nous n&rsquo;avons plus besoin.
<strong>Notez que sous Mac OS X</strong>, vous devez ajouter <code>glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)</code> ; à votre code d&rsquo;initialisation pour que cela fonctionne.</p>
<blockquote>
<p>Assurez-vous que les versions 3.3 ou plus d&rsquo;OpenGL sont installées sur votre système/matériel, sinon l&rsquo;application plantera ou affichera un comportement indéfini. Pour connaître la version d&rsquo;OpenGL sur votre machine, appelez <code>glxinfo</code> sur les machines Linux ou utilisez un utilitaire comme <em>OpenGL Extension Viewer</em> pour Windows. Si la version supportée est inférieure, essayez de vérifier si votre carte vidéo supporte OpenGL 3.3+ (sinon elle est vraiment vieille) et/ou mettez à jour vos pilotes.</p>
</blockquote>
<p>Ensuite, nous devons créer un objet fenêtre. Cet objet contient toutes les données de fenêtrage et est nécessaire à la plupart des autres fonctions de GLFW.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>GLFWwindow<span style="color:#f92672">*</span> window <span style="color:#f92672">=</span> glfwCreateWindow(<span style="color:#ae81ff">800</span>, <span style="color:#ae81ff">600</span>, <span style="color:#e6db74">&#34;LearnOpenGL&#34;</span>, NULL, NULL);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (window <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Failed to create GLFW window&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    glfwTerminate();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>glfwMakeContextCurrent(window);
</span></span></code></pre></div><p>La fonction <code>glfwCreateWindow</code> requiert la largeur et la hauteur de la fenêtre comme ses deux premiers arguments respectivement.
Le troisième argument nous permet de créer un nom pour la fenêtre ; pour l&rsquo;instant nous l&rsquo;appelons &ldquo;LearnOpenGL&rdquo; mais vous êtes autorisés à lui donner le nom que vous voulez.
Nous pouvons ignorer les deux derniers paramètres. La fonction renvoie un objet <code>GLFWwindow</code> dont nous aurons besoin plus tard pour d&rsquo;autres opérations de GLFW. Après cela, nous demandons à GLFW de faire du contexte de notre fenêtre le contexte principal du thread courant.</p>
<h2 id="glad">GLAD<a hidden class="anchor" aria-hidden="true" href="#glad">#</a></h2>
<p>Dans le chapitre précédent, nous avons mentionné que GLAD gère les pointeurs de fonction pour OpenGL, nous voulons donc initialiser GLAD avant d&rsquo;appeler une fonction OpenGL :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Failed to initialize GLAD&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}   
</span></span></code></pre></div><p>Nous passons à GLAD la fonction pour charger l&rsquo;adresse des pointeurs de fonction OpenGL qui est spécifique au système d&rsquo;exploitation. GLFW nous fournit <code>glfwGetProcAddress</code> qui définit la fonction correcte en fonction du système d&rsquo;exploitation pour lequel nous compilons.</p>
<h2 id="viewport">Viewport<a hidden class="anchor" aria-hidden="true" href="#viewport">#</a></h2>
<p>Avant de commencer le rendu, nous devons faire une dernière chose. Nous devons indiquer à OpenGL la taille de la fenêtre de rendu afin qu&rsquo;OpenGL sache comment nous voulons afficher les données et les coordonnées par rapport à la fenêtre. Nous pouvons définir ces dimensions via la fonction <code>glViewport</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glViewport(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">800</span>, <span style="color:#ae81ff">600</span>);
</span></span></code></pre></div><p>Les deux premiers paramètres de <code>glViewport</code> définissent l&rsquo;emplacement du coin inférieur gauche de la fenêtre. Les troisième et quatrième paramètres définissent la largeur et la hauteur de la fenêtre de rendu en pixels, que nous fixons à la taille de la fenêtre de GLFW.</p>
<p>**Nous pourrions en fait fixer les dimensions de la fenêtre à des valeurs inférieures à celles de GLFW **; ainsi, tout le rendu OpenGL serait affiché dans une fenêtre plus petite et nous pourrions, par exemple, afficher d&rsquo;autres éléments en dehors de la fenêtre OpenGL.</p>
<blockquote>
<p>En coulisses, OpenGL utilise les données spécifiées par <code>glViewport</code> pour transformer les coordonnées 2D qu&rsquo;il a traitées en coordonnées sur votre écran. Par exemple, un point traité de la position (-0.5,0.5) serait (comme sa transformation finale) mappé à (200,450) en coordonnées d&rsquo;écran. Notez que les coordonnées traitées dans OpenGL sont comprises entre -1 et 1, de sorte que nous mappons effectivement de l&rsquo;intervalle (-1 à 1) à (0, 800) et (0, 600).</p>
</blockquote>
<p>Cependant, lorsque l&rsquo;utilisateur redimensionne la fenêtre, la fenêtre de visualisation doit également être ajustée. Nous pouvons enregistrer une fonction de rappel sur la fenêtre qui est appelée chaque fois que la fenêtre est redimensionnée. Cette fonction de rappel de redimensionnement a le prototype suivant :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">framebuffer_size_callback</span>(GLFWwindow<span style="color:#f92672">*</span> window, <span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> height);  
</span></span></code></pre></div><p>La fonction <code>framebuffer_size_callback</code> prend une fenêtre GLFW comme premier argument et deux entiers indiquant les nouvelles dimensions de la fenêtre. Chaque fois que la taille de la fenêtre change, GLFW appelle cette fonction et remplit les arguments appropriés pour que vous puissiez les traiter.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">framebuffer_size_callback</span>(GLFWwindow<span style="color:#f92672">*</span> window, <span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> height)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    glViewport(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, width, height);
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>Nous devons indiquer à GLFW que nous voulons appeler cette fonction à chaque redimensionnement de fenêtre en l&rsquo;enregistrant :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);  
</span></span></code></pre></div><p>Lorsque la fenêtre est affichée pour la première fois, <code>framebuffer_size_callback</code> est également appelé avec les dimensions résultantes de la fenêtre. Pour les écrans Rétina, la largeur et la hauteur seront significativement plus élevées que les valeurs d&rsquo;origine.</p>
<p>Il existe de nombreuses fonctions de rappel que nous pouvons définir pour enregistrer nos propres fonctions. Par exemple, nous pouvons créer une fonction de rappel pour traiter les changements d&rsquo;entrée du joystick, traiter les messages d&rsquo;erreur, etc. Nous enregistrons les fonctions de rappel après avoir créé la fenêtre et avant que la boucle de rendu ne soit lancée.</p>
<h2 id="préparez-vos-moteurs">Préparez vos moteurs<a hidden class="anchor" aria-hidden="true" href="#préparez-vos-moteurs">#</a></h2>
<p>Nous ne voulons pas que l&rsquo;application dessine une seule image, puis qu&rsquo;elle quitte immédiatement et ferme la fenêtre. Nous voulons que l&rsquo;application continue à dessiner des images et à gérer les entrées de l&rsquo;utilisateur jusqu&rsquo;à ce que le programme reçoive l&rsquo;ordre explicite de s&rsquo;arrêter. <strong>Pour cette raison, nous devons créer une boucle while,</strong> que nous appelons maintenant <strong>boucle de rendu</strong>, qui continue à fonctionner jusqu&rsquo;à ce que nous demandions à GLFW de s&rsquo;arrêter. Le code suivant montre une boucle de rendu très simple :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>glfwWindowShouldClose(window))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    glfwSwapBuffers(window);
</span></span><span style="display:flex;"><span>    glfwPollEvents();    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>La fonction <code>glfwWindowShouldClose</code> vérifie au début de chaque itération de la boucle si GLFW a reçu l&rsquo;ordre de se fermer. Si c&rsquo;est le cas, la fonction renvoie vrai et la boucle de rendu s&rsquo;arrête, après quoi nous pouvons fermer l&rsquo;application.</p>
<p>La fonction <code>glfwPollEvents</code> vérifie si des événements sont déclenchés (comme des entrées clavier ou des mouvements de souris), met à jour l&rsquo;état de la fenêtre et appelle les fonctions correspondantes (que nous pouvons enregistrer via des méthodes de rappel). La fonction <code>glfwSwapBuffer</code> va permuter le color buffer (un grand tampon 2D qui contient les valeurs de couleur pour chaque pixel de la fenêtre de GLFW) qui est utilisé pour le rendu pendant cette itération de rendu et l&rsquo;afficher en sortie à l&rsquo;écran.</p>
<blockquote>
<p>Double buffer<br>
Lorsqu&rsquo;une application dessine dans une seule mémoire tampon, l&rsquo;image résultante peut présenter des problèmes de scintillement. <strong>En effet, l&rsquo;image résultante n&rsquo;est pas dessinée en un instant, mais pixel par pixel, généralement de gauche à droite et de haut en bas</strong>. Comme cette image n&rsquo;est pas affichée instantanément à l&rsquo;utilisateur tout en étant rendue, le résultat peut contenir des artefacts. <strong>Pour contourner ces problèmes, les applications de fenêtrage utilisent une double mémoire tampon pour le rendu</strong>. La mémoire tampon avant (front buffer) contient l&rsquo;image de sortie finale qui est affichée à l&rsquo;écran, tandis que toutes les commandes de rendu dessinent dans la mémoire tampon arrière (back buffer). Dès que toutes les commandes de rendu sont terminées, le tampon arrière est remplacé par le tampon avant, de sorte que l&rsquo;image peut être affichée sans être en train d&rsquo;être rendue, ce qui supprime tous les artefacts susmentionnés.</p>
</blockquote>
<h2 id="une-dernière-chose">Une dernière chose<a hidden class="anchor" aria-hidden="true" href="#une-dernière-chose">#</a></h2>
<p>Dès que nous sortons de la boucle de rendu, nous souhaitons nettoyer/supprimer correctement toutes les ressources de GLFW qui ont été allouées. Nous pouvons le faire via la fonction <code>glfwTerminate</code> que nous appelons à la fin de la fonction principale.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glfwTerminate();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span></code></pre></div><p>Ceci nettoiera toutes les ressources et quittera correctement l&rsquo;application. Essayez maintenant de compiler votre application et si tout s&rsquo;est bien passé, vous devriez voir la sortie suivante :
<img src="/docs/LEARNOPENGL_FR/01_Getting_Started/img/window6.png" alt="window6"/>
Si c&rsquo;est une image noire très terne et ennuyeuse, c&rsquo;est que vous avez bien fait les choses ! Si vous n&rsquo;avez pas obtenu la bonne image ou si vous ne savez pas comment tout s&rsquo;articule, consultez le code source complet <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/1.1.hello_window/hello_window.cpp">ici</a> (et si des couleurs différentes ont commencé à clignoter, continuez à lire).</p>
<p>Si vous avez des problèmes pour compiler l&rsquo;application, assurez-vous d&rsquo;abord que toutes les options de votre linker sont correctement réglées et que vous avez inclus les bons répertoires dans votre IDE (comme expliqué dans le chapitre précédent). Assurez-vous également que votre code est correct ; vous pouvez le vérifier en le comparant avec le code source complet.</p>
<h2 id="input-entrée">Input (entrée)<a hidden class="anchor" aria-hidden="true" href="#input-entrée">#</a></h2>
<p>Nous souhaitons également disposer d&rsquo;une forme de contrôle des entrées dans GLFW et nous pouvons y parvenir grâce à plusieurs fonctions d&rsquo;entrée de GLFW. Nous utiliserons la fonction <code>glfwGetKey</code> de GLFW qui prend la fenêtre en entrée ainsi qu&rsquo;une touche. La fonction retourne si cette touche est actuellement pressée. Nous créons une fonction <code>processInput</code> pour organiser l&rsquo;ensemble du code d&rsquo;entrée :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processInput</span>(GLFWwindow <span style="color:#f92672">*</span>window)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(glfwGetKey(window, GLFW_KEY_ESCAPE) <span style="color:#f92672">==</span> GLFW_PRESS)
</span></span><span style="display:flex;"><span>        glfwSetWindowShouldClose(window, true);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Nous vérifions ici si l&rsquo;utilisateur a appuyé sur la touche d&rsquo;échappement (si ce n&rsquo;est pas le cas, <code>glfwGetKey</code> renvoie <code>GLFW_RELEASE</code>). Si l&rsquo;utilisateur a appuyé sur la touche d&rsquo;échappement, nous fermons GLFW en définissant sa propriété <code>WindowShouldClose</code>à true à l&rsquo;aide de <code>glfwSetwindowShouldClose</code>. La vérification de la condition suivante de la boucle while principale échoue alors et l&rsquo;application se ferme.</p>
<p>Nous appelons ensuite <code>processInput</code> à chaque itération de la boucle de rendu :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>glfwWindowShouldClose(window))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    processInput(window);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    glfwSwapBuffers(window);
</span></span><span style="display:flex;"><span>    glfwPollEvents();
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Nous disposons ainsi d&rsquo;un moyen simple de vérifier la présence de touches spécifiques et de réagir en conséquence à chaque image. <strong>Une itération de la boucle de rendu est plus communément appelée une image</strong>.</p>
<h2 id="rendering-le-rendu">Rendering (le rendu)<a hidden class="anchor" aria-hidden="true" href="#rendering-le-rendu">#</a></h2>
<p>Nous voulons placer toutes les commandes de rendu dans la boucle de rendu, puisque nous voulons exécuter toutes les commandes de rendu à chaque itération ou image de la boucle. Cela ressemblerait un peu à ceci :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// render loop
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>glfwWindowShouldClose(window))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// input
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    processInput(window);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// rendering commands here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// check and call events and swap the buffers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    glfwPollEvents();
</span></span><span style="display:flex;"><span>    glfwSwapBuffers(window);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Juste pour tester si les choses fonctionnent réellement, nous voulons effacer l&rsquo;écran avec une couleur de notre choix. <strong>Au début de l&rsquo;image, nous voulons effacer l&rsquo;écran. Sinon, nous verrions toujours les résultats de l&rsquo;image précédente (cela pourrait être l&rsquo;effet recherché, mais en général ce n&rsquo;est pas le cas)</strong>. Nous pouvons effacer le tampon de couleur (color buffer) de l&rsquo;écran en utilisant <code>glClear</code> où nous passons des bits de tampon (buffer bits) pour spécifier le tampon que nous voulons effacer. Les bits possibles sont <code>GL_COLOR_BUFFER_BIT</code>, <code>GL_DEPTH_BUFFER_BIT</code> et <code>GL_STENCIL_BUFFER_BIT</code>. Pour l&rsquo;instant, nous ne nous intéressons qu&rsquo;aux valeurs de couleur et nous n&rsquo;effaçons donc que le tampon de couleur.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glClearColor(<span style="color:#ae81ff">0.2f</span>, <span style="color:#ae81ff">0.3f</span>, <span style="color:#ae81ff">0.3f</span>, <span style="color:#ae81ff">1.0f</span>);
</span></span><span style="display:flex;"><span>glClear(GL_COLOR_BUFFER_BIT);
</span></span></code></pre></div><p>Notez que nous spécifions également la couleur à utiliser pour effacer l&rsquo;écran à l&rsquo;aide de <code>glClearColor</code>. Chaque fois que nous appelons <code>glClear</code> et que nous vidons le tampon de couleurs, celui-ci est entièrement rempli avec la couleur configurée par <code>glClearColor</code>. Il en résultera une couleur vert foncé-bleuâtre.</p>
<blockquote>
<p>Comme vous vous en souvenez peut-être dans le chapitre sur OpenGL, la fonction <code>glClearColor</code> <strong>est une fonction de définition d&rsquo;état</strong> et <code>glClear</code> <strong>est une fonction d&rsquo;utilisation d&rsquo;état en ce sens qu&rsquo;elle utilise l&rsquo;état actuel pour récupérer la couleur d&rsquo;effacement.</strong></p>
</blockquote>
<p><img src="/docs/LEARNOPENGL_FR/01_Getting_Started/img/window7.png" alt="window7"/>
Le code source complet de l&rsquo;application est disponible <a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/1.2.hello_window_clear/hello_window_clear.cpp">ici</a>.</p>
<p>Nous avons maintenant tout ce qu&rsquo;il faut pour remplir la boucle de rendu avec de nombreux appels de rendu, mais c&rsquo;est pour le prochain chapitre. Je pense que nous avons assez divagué ici.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://hrst4.xyz/tags/cg/">cg</a></li>
      <li><a href="https://hrst4.xyz/tags/opengl/">opengl</a></li>
      <li><a href="https://hrst4.xyz/tags/computer-graphics/">computer graphics</a></li>
      <li><a href="https://hrst4.xyz/tags/cpp/">cpp</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hrst4.xyz/">hrst4&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
