<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>hrst4&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Ombres ponctuelles Dans le dernier chapitre, nous avons appris à créer des ombres dynamiques avec le shadow mapping. Cette méthode fonctionne très bien, mais elle est surtout adaptée aux lumières directionnelles (ou ponctuelles), car les ombres ne sont générées que dans la direction de la source lumineuse. C&rsquo;est pourquoi elle est également connue sous le nom de mapping directionnel des ombres, car la map de profondeur (ou d&rsquo;ombres) est générée uniquement dans la direction vers laquelle la lumière regarde.">
<meta name="author" content="">
<link rel="canonical" href="https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/02b_point_shadows/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://hrst4.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hrst4.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hrst4.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hrst4.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://hrst4.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="Ombres ponctuelles Dans le dernier chapitre, nous avons appris à créer des ombres dynamiques avec le shadow mapping. Cette méthode fonctionne très bien, mais elle est surtout adaptée aux lumières directionnelles (ou ponctuelles), car les ombres ne sont générées que dans la direction de la source lumineuse. C&rsquo;est pourquoi elle est également connue sous le nom de mapping directionnel des ombres, car la map de profondeur (ou d&rsquo;ombres) est générée uniquement dans la direction vers laquelle la lumière regarde." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/02b_point_shadows/" /><meta property="article:section" content="docs" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Ombres ponctuelles Dans le dernier chapitre, nous avons appris à créer des ombres dynamiques avec le shadow mapping. Cette méthode fonctionne très bien, mais elle est surtout adaptée aux lumières directionnelles (ou ponctuelles), car les ombres ne sont générées que dans la direction de la source lumineuse. C&rsquo;est pourquoi elle est également connue sous le nom de mapping directionnel des ombres, car la map de profondeur (ou d&rsquo;ombres) est générée uniquement dans la direction vers laquelle la lumière regarde."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Docs",
      "item": "https://hrst4.xyz/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/02b_point_shadows/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "Ombres ponctuelles Dans le dernier chapitre, nous avons appris à créer des ombres dynamiques avec le shadow mapping. Cette méthode fonctionne très bien, mais elle est surtout adaptée aux lumières directionnelles (ou ponctuelles), car les ombres ne sont générées que dans la direction de la source lumineuse. C\u0026rsquo;est pourquoi elle est également connue sous le nom de mapping directionnel des ombres, car la map de profondeur (ou d\u0026rsquo;ombres) est générée uniquement dans la direction vers laquelle la lumière regarde.",
  "keywords": [
    
  ],
  "articleBody": "Ombres ponctuelles Dans le dernier chapitre, nous avons appris à créer des ombres dynamiques avec le shadow mapping. Cette méthode fonctionne très bien, mais elle est surtout adaptée aux lumières directionnelles (ou ponctuelles), car les ombres ne sont générées que dans la direction de la source lumineuse. C’est pourquoi elle est également connue sous le nom de mapping directionnel des ombres, car la map de profondeur (ou d’ombres) est générée uniquement dans la direction vers laquelle la lumière regarde.\nCe chapitre se concentre sur la génération d’ombres dynamiques dans toutes les directions environnantes. La technique que nous utilisons est parfaite pour les lumières ponctuelles, car une vraie lumière ponctuelle projetterait des ombres dans toutes les directions. Cette technique est connue sous le nom d’ombres ponctuelles (lumière) ou plus anciennement sous le nom de maps d’ombres omnidirectionnelles.\nCe chapitre s’appuie sur le chapitre précédent consacré au mapping des ombres. Par conséquent, si vous n’êtes pas familiarisé avec le mapping des ombres traditionnel, il est conseillé de lire d’abord le chapitre consacré au mapping des ombres.\nLa technique est essentiellement similaire au mapping directionnel des ombres : nous générons une map de profondeur à partir de la ou des perspectives de la lumière, nous échantillonnons la map de profondeur en fonction de la position actuelle du fragment et nous comparons chaque fragment à la valeur de profondeur stockée pour voir s’il se trouve dans l’ombre. La principale différence entre le mappage directionnel des ombres et le mappage omnidirectionnel des ombres est la carte de profondeur utilisée.\nLa carte de profondeur dont nous avons besoin nécessite le rendu d’une scène à partir de toutes les directions environnantes d’une lumière ponctuelle et, de ce fait, une map de profondeur 2D normale ne fonctionnera pas ; et si nous utilisions une cubemap à la place ? Comme une cubemap peut stocker des données d’environnement complètes avec seulement 6 faces, il est possible de rendre la scène entière sur chacune des faces d’une cubemap et de les échantillonner comme les valeurs de profondeur environnantes de la lumière ponctuelle. Le cubemap de profondeur généré est ensuite transmis au shader de fragment d’éclairage qui échantillonne le cubemap avec un vecteur de direction pour obtenir la profondeur la plus proche (du point de vue de la lumière) de ce fragment. La plupart des choses compliquées ont déjà été abordées dans le chapitre sur le shadow mapping. Ce qui rend cette technique un peu plus difficile est la génération du cubemap de profondeur.\nGénérer la cubemap de profondeur Pour créer une cubemap des valeurs de profondeur environnantes d’une lumière, nous devons effectuer le rendu de la scène 6 fois : une fois pour chaque face. Une façon (assez évidente) de le faire est de rendre la scène 6 fois avec 6 matrices de vue différentes, en attachant à chaque fois une face cubemap différente à l’objet framebuffer. Cela ressemblerait à quelque chose comme ceci :\nfor(unsigned int i = 0; i \u003c 6; i++) { GLenum face = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i; glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, face, depthCubemap, 0); BindViewMatrix(lightViewMatrices[i]); RenderScene(); } Cependant, cela peut s’avérer assez coûteux car de nombreux appels de rendu sont nécessaires pour cette seule map de profondeur. Dans ce chapitre, nous allons utiliser une approche alternative (plus organisée) en utilisant une petite astuce dans le shader géométrique qui nous permet de construire le cubemap de profondeur avec une seule passe de rendu.\nTout d’abord, nous devons créer une cubemap :\nunsigned int depthCubemap; glGenTextures(1, \u0026depthCubemap); Et attribuer à chacune des faces du cubemap une image de texture 2D évaluée en fonction de la profondeur :\nconst unsigned int SHADOW_WIDTH = 1024, SHADOW_HEIGHT = 1024; glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap); for (unsigned int i = 0; i \u003c 6; ++i) glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_DEPTH_COMPONENT, SHADOW_WIDTH, SHADOW_HEIGHT, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL); N’oubliez pas de définir les paramètres de texture :\nglTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); Normalement, nous attacherions une seule face d’une texture cubemap à l’objet framebuffer et rendrions la scène 6 fois, en changeant à chaque fois la cible du tampon de profondeur du framebuffer pour une face cubemap différente. Puisque nous allons utiliser un shader géométrique, qui nous permet d’effectuer le rendu sur toutes les faces en un seul passage, nous pouvons directement attacher la texture cubemap à l’objet framebuffer avec glFramebufferTexture :\nglBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO); glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthCubemap, 0); glDrawBuffer(GL_NONE); glReadBuffer(GL_NONE); glBindFramebuffer(GL_FRAMEBUFFER, 0); Encore une fois, notez l’appel à glDrawBuffer et glReadBuffer : nous ne nous intéressons qu’aux valeurs de profondeur lors de la génération d’un cubemap de profondeur, nous devons donc explicitement indiquer à OpenGL que cet objet framebuffer n’effectue pas de rendu vers un tampon de couleur.\nAvec les maps d’ombres omnidirectionnelles, nous avons deux passes de rendu : premièrement, nous générons la cubemap de profondeur et deuxièmement, nous utilisons la cubemap de profondeur dans la passe de rendu normale pour ajouter des ombres à la scène. Ce processus ressemble un peu à ceci :\n// 1. first render to depth cubemap glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT); glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO); glClear(GL_DEPTH_BUFFER_BIT); ConfigureShaderAndMatrices(); RenderScene(); glBindFramebuffer(GL_FRAMEBUFFER, 0); // 2. then render scene as normal with shadow mapping (using depth cubemap) glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); ConfigureShaderAndMatrices(); glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap); RenderScene(); Le processus est exactement le même que pour le mappage d’ombres par défaut, bien que cette fois-ci nous effectuions le rendu et utilisions une texture de profondeur cubemap au lieu d’une texture de profondeur 2D.\nLight space transform Avec le framebuffer et le cubemap définis, nous avons besoin d’un moyen de transformer toute la géométrie de la scène vers les espaces de lumière pertinents dans les 6 directions de la lumière. Tout comme pour le chapitre sur le shadow mapping, nous allons avoir besoin d’une matrice de transformation de l’espace de lumière $T$ mais cette fois-ci une pour chaque face.\nChaque matrice de transformation de l’espace lumière contient à la fois une matrice de projection et une matrice de vue. Pour la matrice de projection, nous allons utiliser une matrice de projection en perspective ; la source lumineuse représente un point dans l’espace et la projection en perspective est donc la plus logique. Chaque matrice de transformation de l’espace lumière utilise la même matrice de projection :\nfloat aspect = (float)SHADOW_WIDTH/(float)SHADOW_HEIGHT; float near = 1.0f; float far = 25.0f; glm::mat4 shadowProj = glm::perspective(glm::radians(90.0f), aspect, near, far); Il est important de noter que le paramètre de champ de vision de glm::perspective est fixé à 90 degrés. En fixant ce paramètre à 90 degrés, nous nous assurons que le champ de vision est exactement assez grand pour remplir une seule face de la cubemap, de sorte que toutes les faces s’alignent correctement les unes sur les autres au niveau des bords.\nComme la matrice de projection ne change pas en fonction de la direction, nous pouvons la réutiliser pour chacune des 6 matrices de transformation. Nous avons besoin d’une matrice de vue différente pour chaque direction. Avec glm::lookAt, nous créons 6 directions de vue, chacune regardant une direction de face du cubemap dans l’ordre suivant : droite, gauche, haut, bas, près et loin.\nstd::vector\u003cglm::mat4\u003e shadowTransforms; shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3( 1.0, 0.0, 0.0), glm::vec3(0.0,-1.0, 0.0)); shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3(-1.0, 0.0, 0.0), glm::vec3(0.0,-1.0, 0.0)); shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3( 0.0, 1.0, 0.0), glm::vec3(0.0, 0.0, 1.0)); shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3( 0.0,-1.0, 0.0), glm::vec3(0.0, 0.0,-1.0)); shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3( 0.0, 0.0, 1.0), glm::vec3(0.0,-1.0, 0.0)); shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3( 0.0, 0.0,-1.0), glm::vec3(0.0,-1.0, 0.0)); Ici, nous créons 6 matrices de vue et les multiplions avec la matrice de projection pour obtenir un total de 6 matrices de transformation de l’espace lumière différentes. Le paramètre cible de glm::lookAt regarde chacun dans la direction d’une seule face du cubemap.\nCes matrices de transformation sont envoyées aux shaders qui rendent la profondeur dans le cubemap.\nShaders de profondeur (depth shaders) Pour rendre les valeurs de profondeur dans un cubemap de profondeur, nous aurons besoin de trois shaders au total : un vertex et un fragment shader, et un geometry shader entre les deux.\nLe shader de géométrie sera le shader responsable de la transformation de tous les sommets de l’espace monde (world space) en 6 espaces de lumière différents. Par conséquent, le shader de sommets transforme simplement les sommets dans l’espace-monde et les dirige vers le shader de géométrie :\n#version 330 core layout (location = 0) in vec3 aPos; uniform mat4 model; void main() { gl_Position = model * vec4(aPos, 1.0); } Le shader géométrique prend en entrée 3 sommets de triangle et un tableau uniforme de matrices de transformation de l’espace lumineux. Le shader géométrique est responsable de la transformation des sommets en espaces de lumière ; c’est là que les choses deviennent intéressantes.\nLe shader géométrique possède une variable intégrée appelée gl_Layer qui spécifie la face du cubemap vers laquelle émettre une primitive. Lorsqu’il est laissé à lui-même, le shader de géométrie envoie simplement ses primitives le long du pipeline comme d’habitude, mais lorsque nous mettons à jour cette variable, nous pouvons contrôler vers quelle face du cubemap nous effectuons le rendu pour chaque primitive. Bien sûr, cela ne fonctionne que lorsque nous avons une texture cubemap attachée au framebuffer actif.\n#version 330 core layout (triangles) in; layout (triangle_strip, max_vertices=18) out; uniform mat4 shadowMatrices[6]; out vec4 FragPos; // FragPos from GS (output per emitvertex) void main() { for(int face = 0; face \u003c 6; ++face) { gl_Layer = face; // built-in variable that specifies to which face we render. for(int i = 0; i \u003c 3; ++i) // for each triangle vertex { FragPos = gl_in[i].gl_Position; gl_Position = shadowMatrices[face] * FragPos; EmitVertex(); } EndPrimitive(); } } Ce shader géométrique est relativement simple. Nous prenons en entrée un triangle, et sortons un total de 6 triangles (6 * 3 égale 18 sommets). Dans la fonction principale, nous itérons sur 6 faces de cubemap où nous spécifions chaque face comme face de sortie en stockant l’entier de la face dans gl_Layer. Nous générons ensuite les triangles de sortie en transformant chaque sommet d’entrée de l’espace-monde dans l’espace-lumière approprié en multipliant FragPos avec la matrice de transformation de l’espace-lumière de la face. Notez que nous avons également envoyé la variable FragPos résultante au shader de fragments dont nous aurons besoin pour calculer une valeur de profondeur.\nDans le chapitre précédent, nous avons utilisé un fragment shader vide et laissé OpenGL calculer les valeurs de profondeur de la map de profondeur. Cette fois-ci, nous allons calculer notre propre profondeur (linéaire) comme la distance linéaire entre chaque position de fragment la plus proche et la position de la source lumineuse. Le calcul de nos propres valeurs de profondeur rend les calculs d’ombres ultérieurs un peu plus intuitifs.\n#version 330 core in vec4 FragPos; uniform vec3 lightPos; uniform float far_plane; void main() { // get distance between fragment and light source float lightDistance = length(FragPos.xyz - lightPos); // map to [0;1] range by dividing by far_plane lightDistance = lightDistance / far_plane; // write this as modified depth gl_FragDepth = lightDistance; } Le fragment shader prend en entrée le FragPos du geometry shader, le vecteur de position de la lumière, et la valeur du plan lointain du frustum. Ici, nous prenons la distance entre le fragment et la source lumineuse, nous l’inscrivons dans l’intervalle $[0,1]$ et nous l’écrivons en tant que valeur de profondeur du fragment.\nLe rendu de la scène avec ces shaders et l’objet framebuffer attaché au cubemap actif devrait vous donner un cubemap de profondeur complètement rempli pour les calculs d’ombres de la deuxième passe.\nMap d’ombres omnidirectionnelles Une fois que tout est en place, il est temps de rendre les ombres omnidirectionnelles. La procédure est similaire à celle du chapitre sur le mappage directionnel des ombres, bien que cette fois nous lions une texture cubemap au lieu d’une texture 2D et que nous transmettions également la variable du plan éloigné de la projection lumineuse aux shaders.\nglViewport(0, 0, SCR_WIDTH, SCR_HEIGHT); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); shader.use(); // ... send uniforms to shader (including light's far_plane value) glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap); // ... bind other textures RenderScene(); Ici, la fonction renderScene rend quelques cubes dans une grande pièce cubique dispersés autour d’une source lumineuse au centre de la scène.\nLes shaders de sommets et de fragments sont pour la plupart similaires aux shader de shadow mapping originaux : la différence étant que le shader de fragments n’a plus besoin d’une position de fragment dans l’espace lumière puisque nous pouvons maintenant échantillonner les valeurs de profondeur avec un vecteur de direction.\nDe ce fait, le vertex shader n’a pas besoin de transformer ses vecteurs de position dans l’espace lumière et nous pouvons donc supprimer la variable FragPosLightSpace :\n#version 330 core layout (location = 0) in vec3 aPos; layout (location = 1) in vec3 aNormal; layout (location = 2) in vec2 aTexCoords; out vec2 TexCoords; out VS_OUT { vec3 FragPos; vec3 Normal; vec2 TexCoords; } vs_out; uniform mat4 projection; uniform mat4 view; uniform mat4 model; void main() { vs_out.FragPos = vec3(model * vec4(aPos, 1.0)); vs_out.Normal = transpose(inverse(mat3(model))) * aNormal; vs_out.TexCoords = aTexCoords; gl_Position = projection * view * model * vec4(aPos, 1.0); } Le code d’éclairage Blinn-Phong du fragment shader est exactement le même que celui que nous avions auparavant, avec une multiplication de l’ombre à la fin :\n#version 330 core out vec4 FragColor; in VS_OUT { vec3 FragPos; vec3 Normal; vec2 TexCoords; } fs_in; uniform sampler2D diffuseTexture; uniform samplerCube depthMap; uniform vec3 lightPos; uniform vec3 viewPos; uniform float far_plane; float ShadowCalculation(vec3 fragPos) { [...] } void main() { vec3 color = texture(diffuseTexture, fs_in.TexCoords).rgb; vec3 normal = normalize(fs_in.Normal); vec3 lightColor = vec3(0.3); // ambient vec3 ambient = 0.3 * color; // diffuse vec3 lightDir = normalize(lightPos - fs_in.FragPos); float diff = max(dot(lightDir, normal), 0.0); vec3 diffuse = diff * lightColor; // specular vec3 viewDir = normalize(viewPos - fs_in.FragPos); vec3 reflectDir = reflect(-lightDir, normal); float spec = 0.0; vec3 halfwayDir = normalize(lightDir + viewDir); spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0); vec3 specular = spec * lightColor; // calculate shadow float shadow = ShadowCalculation(fs_in.FragPos); vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color; FragColor = vec4(lighting, 1.0); } Il y a quelques différences subtiles : le code d’éclairage est le même, mais nous avons maintenant un uniforme samplerCube et la fonction ShadowCalculation prend la position du fragment actuel comme argument au lieu de la position du fragment dans l’espace lumière. Nous incluons également la valeur far_plane du frustum de lumière dont nous aurons besoin plus tard.\nLa plus grande différence se trouve dans le contenu de la fonction ShadowCalculation qui échantillonne maintenant les valeurs de profondeur à partir d’un cubemap au lieu d’une texture 2D. Examinons son contenu étape par étape.\nLa première chose à faire est de récupérer la profondeur du cubemap. Vous vous souvenez peut-être que dans la section cubemap de ce chapitre, nous avons stocké la profondeur en tant que distance linéaire entre le fragment et la position de la lumière ; nous adoptons une approche similaire ici :\nfloat ShadowCalculation(vec3 fragPos) { vec3 fragToLight = fragPos - lightPos; float closestDepth = texture(depthMap, fragToLight).r; } Ici, nous prenons le vecteur de différence entre la position du fragment et la position de la lumière et nous utilisons ce vecteur comme vecteur de direction pour échantillonner le cubemap. Le vecteur de direction n’a pas besoin d’être un vecteur unitaire pour échantillonner à partir d’un cubemap, il n’est donc pas nécessaire de le normaliser. La valeur closeestDepth résultante est la valeur de profondeur normalisée entre la source lumineuse et le fragment visible le plus proche.\nLa valeur closestDepth est actuellement comprise dans l’intervalle $[0,1]$, nous la transformons donc d’abord en $[0,far_plane]$ en la multipliant par far_plane.\nclosestDepth *= far_plane; Ensuite, nous récupérons la valeur de profondeur entre le fragment actuel et la source lumineuse, que nous pouvons facilement obtenir en prenant la longueur de fragToLight en raison de la façon dont nous avons calculé les valeurs de profondeur dans le cubemap :\nfloat currentDepth = length(fragToLight); Cela renvoie une valeur de profondeur dans le même intervalle (ou plus grand) que closestDepth.\nNous pouvons maintenant comparer les deux valeurs de profondeur pour voir laquelle est la plus proche de l’autre et déterminer si le fragment actuel est dans l’ombre. Nous incluons également un biais d’ombre afin de ne pas obtenir d’acné d’ombre, comme nous l’avons vu dans le chapitre précédent.\nfloat bias = 0.05; float shadow = currentDepth - bias \u003e closestDepth ? 1.0 : 0.0; La fonction devient alors :\nfloat ShadowCalculation(vec3 fragPos) { // get vector between fragment position and light position vec3 fragToLight = fragPos - lightPos; // use the light to fragment vector to sample from the depth map float closestDepth = texture(depthMap, fragToLight).r; // it is currently in linear range between [0,1]. Re-transform back to original value closestDepth *= far_plane; // now get current linear depth as the length between the fragment and light position float currentDepth = length(fragToLight); // now test for shadows float bias = 0.05; float shadow = currentDepth - bias \u003e closestDepth ? 1.0 : 0.0; return shadow; } Avec ces shaders, nous obtenons déjà de bonnes ombres, et cette fois dans toutes les directions environnantes, à partir d’une lumière ponctuelle. Avec une lumière ponctuelle positionnée au centre d’une scène simple, cela ressemblera un peu à ceci : Vous pouvez trouver le code source de cette démo ici.\nVisualisation du tampon de profondeur cubemap Si vous êtes un peu comme moi, vous n’avez probablement pas réussi du premier coup, il est donc logique de faire un peu de débogage, l’une des vérifications évidentes étant de valider si la map de profondeur a été construite correctement. Une astuce simple pour visualiser le tampon de profondeur est de prendre la variable closestDepth dans la fonction ShadowCalculation et de l’afficher comme suit :\nFragColor = vec4(vec3(closestDepth / far_plane), 1.0); Le résultat est une scène grisée où chaque couleur représente les valeurs de profondeur linéaire de la scène : Vous pouvez également voir les zones d’ombre à venir sur le mur extérieur. Si l’aspect est similaire, vous savez que le cubemap de profondeur a été correctement généré.\nPCF Comme les maps d’ombres omnidirectionnelles sont basées sur les mêmes principes que les maps d’ombres traditionnelles, elles présentent les mêmes artefacts dépendant de la résolution. Si vous zoomez suffisamment près, vous pouvez à nouveau voir des bords irréguliers. Le filtrage par pourcentage de proximité (Percentage-closer filtering ou PCF) nous permet de lisser ces bords irréguliers en filtrant plusieurs échantillons autour de la position du fragment et en faisant la moyenne des résultats.\nSi nous prenons le même filtre PCF simple du chapitre précédent et que nous y ajoutons une troisième dimension, nous obtenons :\nfloat shadow = 0.0; float bias = 0.05; float samples = 4.0; float offset = 0.1; for(float x = -offset; x \u003c offset; x += offset / (samples * 0.5)) { for(float y = -offset; y \u003c offset; y += offset / (samples * 0.5)) { for(float z = -offset; z \u003c offset; z += offset / (samples * 0.5)) { float closestDepth = texture(depthMap, fragToLight + vec3(x, y, z)).r; closestDepth *= far_plane; // undo mapping [0;1] if(currentDepth - bias \u003e closestDepth) shadow += 1.0; } } } shadow /= (samples * samples * samples); Le code n’est pas très différent du code traditionnel de shadow mapping. Nous calculons et ajoutons des décalages de texture dynamiquement pour chaque axe sur la base d’un nombre fixe d’échantillons. Pour chaque échantillon, nous répétons le processus d’ombrage original sur la direction de l’échantillon décalé et nous faisons la moyenne des résultats à la fin.\nLes ombres sont maintenant plus douces et lisses et donnent des résultats plus plausibles. Cependant, avec des échantillons réglés sur $4.0$, nous prélevons un total de 64 échantillons par fragment, ce qui est beaucoup !\nComme la plupart de ces échantillons sont redondants en ce sens qu’ils échantillonnent à proximité du vecteur de direction original, il pourrait être plus judicieux de n’échantillonner que dans les directions perpendiculaires au vecteur de direction de l’échantillon. Cependant, comme il n’y a pas de moyen (facile) de déterminer quelles sous-directions sont redondantes, cela devient difficile. Une astuce consiste à prendre un tableau de directions de décalage qui sont toutes à peu près séparables, c’est-à-dire que chacune d’entre elles pointe dans des directions complètement différentes. Cela permet de réduire considérablement le nombre de sous-directions proches les unes des autres. Nous présentons ci-dessous un tableau de 20 directions de décalage au maximum :\nvec3 sampleOffsetDirections[20] = vec3[] ( vec3( 1, 1, 1), vec3( 1, -1, 1), vec3(-1, -1, 1), vec3(-1, 1, 1), vec3( 1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1), vec3( 1, 1, 0), vec3( 1, -1, 0), vec3(-1, -1, 0), vec3(-1, 1, 0), vec3( 1, 0, 1), vec3(-1, 0, 1), vec3( 1, 0, -1), vec3(-1, 0, -1), vec3( 0, 1, 1), vec3( 0, -1, 1), vec3( 0, -1, -1), vec3( 0, 1, -1) ); À partir de là, nous pouvons adapter l’algorithme PCF pour qu’il prenne une quantité fixe d’échantillons à partir de sampleOffsetDirections et qu’il les utilise pour échantillonner le cubemap. L’avantage est que nous avons besoin de beaucoup moins d’échantillons pour obtenir des résultats visuellement similaires.\nfloat shadow = 0.0; float bias = 0.15; int samples = 20; float viewDistance = length(viewPos - fragPos); float diskRadius = 0.05; for(int i = 0; i \u003c samples; ++i) { float closestDepth = texture(depthMap, fragToLight + sampleOffsetDirections[i] * diskRadius).r; closestDepth *= far_plane; // undo mapping [0;1] if(currentDepth - bias \u003e closestDepth) shadow += 1.0; } shadow /= float(samples); Ici, nous ajoutons plusieurs décalages, mis à l’échelle par un certain diskRadius, autour du vecteur de direction fragToLight original pour échantillonner à partir du cubemap.\nUne autre astuce intéressante que nous pouvons appliquer ici est que nous pouvons changer le diskRadius en fonction de la distance de l’observateur au fragment, rendant les ombres plus douces lorsqu’elles sont éloignées et plus nettes lorsqu’elles sont proches.\nfloat diskRadius = (1.0 + (viewDistance / far_plane)) / 25.0; Les résultats de l’algorithme PCF mis à jour donnent des résultats tout aussi bons, voire meilleurs, pour les ombres douces : Bien entendu, le biais que nous ajoutons à chaque échantillon dépend fortement du contexte et devra toujours être ajusté en fonction de la scène avec laquelle vous travaillez. Jouez avec toutes les valeurs et voyez comment elles affectent la scène.\nVous pouvez trouver le code final ici.\nJe dois mentionner que l’utilisation de shaders géométriques pour générer une map de profondeur n’est pas nécessairement plus rapide que de rendre la scène 6 fois pour chaque face. L’utilisation d’un shader géométrique comme celui-ci a ses propres inconvénients en termes de performances qui peuvent l’emporter sur le gain de performance de l’utilisation d’un shader géométrique en premier lieu. Cela dépend bien sûr du type d’environnement, des pilotes spécifiques de la carte vidéo et de nombreux autres facteurs. Par conséquent, si vous souhaitez vraiment tirer le meilleur parti de votre système, assurez-vous d’établir le profil des deux méthodes et de sélectionner la plus efficace pour votre scène.\nRessources additionnelles Cartographie des ombres pour les sources lumineuses ponctuelles dans OpenGL : tutoriel de cartographie des ombres omnidirectionnelle par sunandblackcat. Multipass Shadow Mapping With Point Lights : tutoriel sur les ombres omnidirectionnelles par ogldev. Ombres omnidirectionnelles : une belle série de diapositives sur le mappage omnidirectionnel des ombres par Peter Houska. ",
  "wordCount" : "3894",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/02b_point_shadows/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "hrst4's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hrst4.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hrst4.xyz/" accesskey="h" title="hrst4&#39;s blog (Alt + H)">hrst4&#39;s blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://hrst4.xyz/docs" title="docs">
                    <span>docs</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="ombres-ponctuelles">Ombres ponctuelles<a hidden class="anchor" aria-hidden="true" href="#ombres-ponctuelles">#</a></h1>
<p>Dans le dernier chapitre, nous avons appris à créer des ombres dynamiques avec le shadow mapping. Cette méthode fonctionne très bien, mais elle est surtout adaptée aux lumières directionnelles (ou ponctuelles), car les ombres ne sont générées que dans la direction de la source lumineuse. C&rsquo;est pourquoi elle est également connue sous le nom de mapping directionnel des ombres, car la map de profondeur (ou d&rsquo;ombres) est générée uniquement dans la direction vers laquelle la lumière regarde.</p>
<p>Ce chapitre se concentre sur la génération d&rsquo;ombres dynamiques dans toutes les directions environnantes. La technique que nous utilisons est parfaite pour les lumières ponctuelles, car une vraie lumière ponctuelle projetterait des ombres dans toutes les directions. Cette technique est connue sous le nom d&rsquo;ombres ponctuelles (lumière) ou plus anciennement sous le nom de maps d&rsquo;ombres omnidirectionnelles.</p>
<blockquote>
<p>Ce chapitre s&rsquo;appuie sur le chapitre précédent consacré au mapping des ombres. Par conséquent, si vous n&rsquo;êtes pas familiarisé avec le mapping des ombres traditionnel, il est conseillé de lire d&rsquo;abord le chapitre consacré au <a href="/docs/learnopengl_fr/05_advanced_lighting/02a_shadow_mapping/">mapping des ombres</a>.</p>
</blockquote>
<p>La technique est essentiellement similaire au mapping directionnel des ombres : nous générons une map de profondeur à partir de la ou des perspectives de la lumière, nous échantillonnons la map de profondeur en fonction de la position actuelle du fragment et nous comparons chaque fragment à la valeur de profondeur stockée pour voir s&rsquo;il se trouve dans l&rsquo;ombre. La principale différence entre le mappage directionnel des ombres et le mappage omnidirectionnel des ombres est la carte de profondeur utilisée.</p>
<p>La carte de profondeur dont nous avons besoin nécessite le rendu d&rsquo;une scène à partir de toutes les directions environnantes d&rsquo;une lumière ponctuelle et, de ce fait, une map de profondeur 2D normale ne fonctionnera pas ; et si nous utilisions une cubemap à la place ? Comme une cubemap peut stocker des données d&rsquo;environnement complètes avec seulement 6 faces, il est possible de rendre la scène entière sur chacune des faces d&rsquo;une cubemap et de les échantillonner comme les valeurs de profondeur environnantes de la lumière ponctuelle.
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/02b_point_shadows-20230830-cubemap.png" alt="02b_point_shadows-20230830-cubemap"/>
Le cubemap de profondeur généré est ensuite transmis au shader de fragment d&rsquo;éclairage qui échantillonne le cubemap avec un vecteur de direction pour obtenir la profondeur la plus proche (du point de vue de la lumière) de ce fragment. La plupart des choses compliquées ont déjà été abordées dans le chapitre sur le <a href="/docs/learnopengl_fr/05_advanced_lighting/02a_shadow_mapping/">shadow mapping</a>. Ce qui rend cette technique un peu plus difficile est la génération du cubemap de profondeur.</p>
<h2 id="générer-la-cubemap-de-profondeur">Générer la cubemap de profondeur<a hidden class="anchor" aria-hidden="true" href="#générer-la-cubemap-de-profondeur">#</a></h2>
<p>Pour créer une cubemap des valeurs de profondeur environnantes d&rsquo;une lumière, nous devons effectuer le rendu de la scène 6 fois : une fois pour chaque face. Une façon (assez évidente) de le faire est de rendre la scène 6 fois avec 6 matrices de vue différentes, en attachant à chaque fois une face cubemap différente à l&rsquo;objet framebuffer. Cela ressemblerait à quelque chose comme ceci :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">6</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    GLenum face <span style="color:#f92672">=</span> GL_TEXTURE_CUBE_MAP_POSITIVE_X <span style="color:#f92672">+</span> i;
</span></span><span style="display:flex;"><span>    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, face, depthCubemap, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    BindViewMatrix(lightViewMatrices[i]);
</span></span><span style="display:flex;"><span>    RenderScene();  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Cependant, cela peut s&rsquo;avérer assez coûteux car de nombreux appels de rendu sont nécessaires pour cette seule map de profondeur. Dans ce chapitre, nous allons utiliser une approche alternative (plus organisée) en utilisant une petite astuce dans le shader géométrique qui nous permet de construire le cubemap de profondeur avec une seule passe de rendu.</p>
<p>Tout d&rsquo;abord, nous devons créer une cubemap :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> depthCubemap;
</span></span><span style="display:flex;"><span>glGenTextures(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>depthCubemap);
</span></span></code></pre></div><p>Et attribuer à chacune des faces du cubemap une image de texture 2D évaluée en fonction de la profondeur :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> SHADOW_WIDTH <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span>, SHADOW_HEIGHT <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span>;
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">6</span>; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X <span style="color:#f92672">+</span> i, <span style="color:#ae81ff">0</span>, GL_DEPTH_COMPONENT, 
</span></span><span style="display:flex;"><span>                     SHADOW_WIDTH, SHADOW_HEIGHT, <span style="color:#ae81ff">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
</span></span></code></pre></div><p>N&rsquo;oubliez pas de définir les paramètres de texture :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
</span></span></code></pre></div><p>Normalement, nous attacherions une seule face d&rsquo;une texture cubemap à l&rsquo;objet framebuffer et rendrions la scène 6 fois, en changeant à chaque fois la cible du tampon de profondeur du framebuffer pour une face cubemap différente. Puisque nous allons utiliser un shader géométrique, qui nous permet d&rsquo;effectuer le rendu sur toutes les faces en un seul passage, nous pouvons directement attacher la texture cubemap à l&rsquo;objet framebuffer avec <code>glFramebufferTexture</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
</span></span><span style="display:flex;"><span>glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthCubemap, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>glDrawBuffer(GL_NONE);
</span></span><span style="display:flex;"><span>glReadBuffer(GL_NONE);
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, <span style="color:#ae81ff">0</span>);  
</span></span></code></pre></div><p>Encore une fois, notez l&rsquo;appel à <code>glDrawBuffer</code> et <code>glReadBuffer</code> : nous ne nous intéressons qu&rsquo;aux valeurs de profondeur lors de la génération d&rsquo;un cubemap de profondeur, nous devons donc explicitement indiquer à OpenGL que cet objet framebuffer n&rsquo;effectue pas de rendu vers un tampon de couleur.</p>
<p>Avec les maps d&rsquo;ombres omnidirectionnelles, nous avons deux passes de rendu : <strong>premièrement, nous générons la cubemap de profondeur et deuxièmement, nous utilisons la cubemap de profondeur dans la passe de rendu normale pour ajouter des ombres à la scène</strong>. Ce processus ressemble un peu à ceci :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 1. first render to depth cubemap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glViewport(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
</span></span><span style="display:flex;"><span>    glClear(GL_DEPTH_BUFFER_BIT);
</span></span><span style="display:flex;"><span>    ConfigureShaderAndMatrices();
</span></span><span style="display:flex;"><span>    RenderScene();
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 2. then render scene as normal with shadow mapping (using depth cubemap)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glViewport(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, SCR_WIDTH, SCR_HEIGHT);
</span></span><span style="display:flex;"><span>glClear(GL_COLOR_BUFFER_BIT <span style="color:#f92672">|</span> GL_DEPTH_BUFFER_BIT);
</span></span><span style="display:flex;"><span>ConfigureShaderAndMatrices();
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap);
</span></span><span style="display:flex;"><span>RenderScene();
</span></span></code></pre></div><p>Le processus est exactement le même que pour le mappage d&rsquo;ombres par défaut, bien que cette fois-ci nous effectuions le rendu et utilisions une texture de profondeur cubemap au lieu d&rsquo;une texture de profondeur 2D.</p>
<h3 id="light-space-transform">Light space transform<a hidden class="anchor" aria-hidden="true" href="#light-space-transform">#</a></h3>
<p>Avec le framebuffer et le cubemap définis, nous avons besoin d&rsquo;un moyen de transformer toute la géométrie de la scène vers les espaces de lumière pertinents dans les 6 directions de la lumière. Tout comme pour le chapitre sur le shadow mapping, nous allons avoir besoin d&rsquo;une matrice de transformation de l&rsquo;espace de lumière $T$ mais cette fois-ci une pour chaque face.</p>
<p>Chaque matrice de transformation de l&rsquo;espace lumière contient à la fois une matrice de projection et une matrice de vue. Pour la matrice de projection, nous allons utiliser une matrice de projection en perspective ; la source lumineuse représente un point dans l&rsquo;espace et la projection en perspective est donc la plus logique. Chaque matrice de transformation de l&rsquo;espace lumière utilise la même matrice de projection :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> aspect <span style="color:#f92672">=</span> (<span style="color:#66d9ef">float</span>)SHADOW_WIDTH<span style="color:#f92672">/</span>(<span style="color:#66d9ef">float</span>)SHADOW_HEIGHT;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> near <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> far <span style="color:#f92672">=</span> <span style="color:#ae81ff">25.0f</span>;
</span></span><span style="display:flex;"><span>glm<span style="color:#f92672">::</span>mat4 shadowProj <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>perspective(glm<span style="color:#f92672">::</span>radians(<span style="color:#ae81ff">90.0f</span>), aspect, near, far); 
</span></span></code></pre></div><p>Il est important de noter que le paramètre de champ de vision de <code>glm::perspective</code> est fixé à 90 degrés. En fixant ce paramètre à 90 degrés, nous nous assurons que le champ de vision est exactement assez grand pour remplir une seule face de la cubemap, de sorte que toutes les faces s&rsquo;alignent correctement les unes sur les autres au niveau des bords.</p>
<p>Comme la matrice de projection ne change pas en fonction de la direction, nous pouvons la réutiliser pour chacune des 6 matrices de transformation. Nous avons besoin d&rsquo;une matrice de vue différente pour chaque direction. Avec <code>glm::lookAt</code>, nous créons 6 directions de vue, chacune regardant une direction de face du cubemap dans l&rsquo;ordre suivant : droite, gauche, haut, bas, près et loin.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>glm<span style="color:#f92672">::</span>mat4<span style="color:#f92672">&gt;</span> shadowTransforms;
</span></span><span style="display:flex;"><span>shadowTransforms.push_back(shadowProj <span style="color:#f92672">*</span> 
</span></span><span style="display:flex;"><span>                 glm<span style="color:#f92672">::</span>lookAt(lightPos, lightPos <span style="color:#f92672">+</span> glm<span style="color:#f92672">::</span>vec3( <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>), glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">0.0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>));
</span></span><span style="display:flex;"><span>shadowTransforms.push_back(shadowProj <span style="color:#f92672">*</span> 
</span></span><span style="display:flex;"><span>                 glm<span style="color:#f92672">::</span>lookAt(lightPos, lightPos <span style="color:#f92672">+</span> glm<span style="color:#f92672">::</span>vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>), glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">0.0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>));
</span></span><span style="display:flex;"><span>shadowTransforms.push_back(shadowProj <span style="color:#f92672">*</span> 
</span></span><span style="display:flex;"><span>                 glm<span style="color:#f92672">::</span>lookAt(lightPos, lightPos <span style="color:#f92672">+</span> glm<span style="color:#f92672">::</span>vec3( <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>), glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>));
</span></span><span style="display:flex;"><span>shadowTransforms.push_back(shadowProj <span style="color:#f92672">*</span> 
</span></span><span style="display:flex;"><span>                 glm<span style="color:#f92672">::</span>lookAt(lightPos, lightPos <span style="color:#f92672">+</span> glm<span style="color:#f92672">::</span>vec3( <span style="color:#ae81ff">0.0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>), glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>));
</span></span><span style="display:flex;"><span>shadowTransforms.push_back(shadowProj <span style="color:#f92672">*</span> 
</span></span><span style="display:flex;"><span>                 glm<span style="color:#f92672">::</span>lookAt(lightPos, lightPos <span style="color:#f92672">+</span> glm<span style="color:#f92672">::</span>vec3( <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>), glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">0.0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>));
</span></span><span style="display:flex;"><span>shadowTransforms.push_back(shadowProj <span style="color:#f92672">*</span> 
</span></span><span style="display:flex;"><span>                 glm<span style="color:#f92672">::</span>lookAt(lightPos, lightPos <span style="color:#f92672">+</span> glm<span style="color:#f92672">::</span>vec3( <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>), glm<span style="color:#f92672">::</span>vec3(<span style="color:#ae81ff">0.0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>));
</span></span></code></pre></div><p>Ici, nous créons 6 matrices de vue et les multiplions avec la matrice de projection pour obtenir un total de 6 matrices de transformation de l&rsquo;espace lumière différentes. Le paramètre cible de <code>glm::lookAt</code> regarde chacun dans la direction d&rsquo;une seule face du cubemap.</p>
<p>Ces matrices de transformation sont envoyées aux shaders qui rendent la profondeur dans le cubemap.</p>
<h3 id="shaders-de-profondeur-depth-shaders">Shaders de profondeur (depth shaders)<a hidden class="anchor" aria-hidden="true" href="#shaders-de-profondeur-depth-shaders">#</a></h3>
<p>Pour rendre les valeurs de profondeur dans un cubemap de profondeur, nous aurons besoin de trois shaders au total : un vertex et un fragment shader, et un geometry shader entre les deux.</p>
<p>Le shader de géométrie sera le shader responsable de la transformation de tous les sommets de l&rsquo;espace monde (world space) en 6 espaces de lumière différents. Par conséquent, le shader de sommets transforme simplement les sommets dans l&rsquo;espace-monde et les dirige vers le shader de géométrie :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) in vec3 aPos;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform mat4 model;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    gl_Position <span style="color:#f92672">=</span> model <span style="color:#f92672">*</span> vec4(aPos, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Le shader géométrique prend en entrée 3 sommets de triangle et un tableau uniforme de matrices de transformation de l&rsquo;espace lumineux. Le shader géométrique est responsable de la transformation des sommets en espaces de lumière ; c&rsquo;est là que les choses deviennent intéressantes.</p>
<p>Le shader géométrique possède une variable intégrée appelée <code>gl_Layer</code> qui spécifie la face du cubemap vers laquelle émettre une primitive. Lorsqu&rsquo;il est laissé à lui-même, le shader de géométrie envoie simplement ses primitives le long du pipeline comme d&rsquo;habitude, mais lorsque nous mettons à jour cette variable, nous pouvons contrôler vers quelle face du cubemap nous effectuons le rendu pour chaque primitive. Bien sûr, cela ne fonctionne que lorsque nous avons une texture cubemap attachée au framebuffer actif.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>layout (triangles) in;
</span></span><span style="display:flex;"><span>layout (triangle_strip, max_vertices<span style="color:#f92672">=</span><span style="color:#ae81ff">18</span>) out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform mat4 shadowMatrices[<span style="color:#ae81ff">6</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out vec4 FragPos; <span style="color:#75715e">// FragPos from GS (output per emitvertex)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> face <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; face <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">6</span>; <span style="color:#f92672">++</span>face)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        gl_Layer <span style="color:#f92672">=</span> face; <span style="color:#75715e">// built-in variable that specifies to which face we render.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; <span style="color:#f92672">++</span>i) <span style="color:#75715e">// for each triangle vertex
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        {
</span></span><span style="display:flex;"><span>            FragPos <span style="color:#f92672">=</span> gl_in[i].gl_Position;
</span></span><span style="display:flex;"><span>            gl_Position <span style="color:#f92672">=</span> shadowMatrices[face] <span style="color:#f92672">*</span> FragPos;
</span></span><span style="display:flex;"><span>            EmitVertex();
</span></span><span style="display:flex;"><span>        }    
</span></span><span style="display:flex;"><span>        EndPrimitive();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Ce shader géométrique est relativement simple. Nous prenons en entrée un triangle, et sortons un total de 6 triangles (6 * 3 égale 18 sommets). Dans la fonction principale, nous itérons sur 6 faces de cubemap où nous spécifions chaque face comme face de sortie en stockant l&rsquo;entier de la face dans <code>gl_Layer</code>. Nous générons ensuite les triangles de sortie en transformant chaque sommet d&rsquo;entrée de l&rsquo;espace-monde dans l&rsquo;espace-lumière approprié en multipliant <code>FragPos</code> avec la matrice de transformation de l&rsquo;espace-lumière de la face. Notez que nous avons également envoyé la variable <code>FragPos</code> résultante au shader de fragments dont nous aurons besoin pour calculer une valeur de profondeur.</p>
<p>Dans le chapitre précédent, nous avons utilisé un fragment shader vide et laissé OpenGL calculer les valeurs de profondeur de la map de profondeur. Cette fois-ci, nous allons calculer notre propre profondeur (linéaire) comme la distance linéaire entre chaque position de fragment la plus proche et la position de la source lumineuse. Le calcul de nos propres valeurs de profondeur rend les calculs d&rsquo;ombres ultérieurs un peu plus intuitifs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>in vec4 FragPos;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform vec3 lightPos;
</span></span><span style="display:flex;"><span>uniform <span style="color:#66d9ef">float</span> far_plane;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// get distance between fragment and light source
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> lightDistance <span style="color:#f92672">=</span> length(FragPos.xyz <span style="color:#f92672">-</span> lightPos);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// map to [0;1] range by dividing by far_plane
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    lightDistance <span style="color:#f92672">=</span> lightDistance <span style="color:#f92672">/</span> far_plane;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// write this as modified depth
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    gl_FragDepth <span style="color:#f92672">=</span> lightDistance;
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>Le fragment shader prend en entrée le <code>FragPos</code> du geometry shader, le vecteur de position de la lumière, et la valeur du plan lointain du frustum. Ici, nous prenons la distance entre le fragment et la source lumineuse, nous l&rsquo;inscrivons dans l&rsquo;intervalle $[0,1]$ et nous l&rsquo;écrivons en tant que valeur de profondeur du fragment.</p>
<p>Le rendu de la scène avec ces shaders et l&rsquo;objet framebuffer attaché au cubemap actif devrait vous donner un cubemap de profondeur complètement rempli pour les calculs d&rsquo;ombres de la deuxième passe.</p>
<h2 id="map-dombres-omnidirectionnelles">Map d&rsquo;ombres omnidirectionnelles<a hidden class="anchor" aria-hidden="true" href="#map-dombres-omnidirectionnelles">#</a></h2>
<p>Une fois que tout est en place, il est temps de rendre les ombres omnidirectionnelles. La procédure est similaire à celle du chapitre sur le mappage directionnel des ombres, bien que cette fois nous lions une texture cubemap au lieu d&rsquo;une texture 2D et que nous transmettions également la variable du plan éloigné de la projection lumineuse aux shaders.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glViewport(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, SCR_WIDTH, SCR_HEIGHT);
</span></span><span style="display:flex;"><span>glClear(GL_COLOR_BUFFER_BIT <span style="color:#f92672">|</span> GL_DEPTH_BUFFER_BIT);
</span></span><span style="display:flex;"><span>shader.use();  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ... send uniforms to shader (including light&#39;s far_plane value)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glActiveTexture(GL_TEXTURE0);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ... bind other textures
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>RenderScene();
</span></span></code></pre></div><p>Ici, la fonction <code>renderScene</code> rend quelques cubes dans une grande pièce cubique dispersés autour d&rsquo;une source lumineuse au centre de la scène.</p>
<p>Les shaders de sommets et de fragments sont pour la plupart similaires aux shader de shadow mapping originaux : la différence étant que le shader de fragments n&rsquo;a plus besoin d&rsquo;une position de fragment dans l&rsquo;espace lumière puisque nous pouvons maintenant échantillonner les valeurs de profondeur avec un vecteur de direction.</p>
<p>De ce fait, le vertex shader n&rsquo;a pas besoin de transformer ses vecteurs de position dans l&rsquo;espace lumière et nous pouvons donc supprimer la variable <code>FragPosLightSpace</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) in vec3 aPos;
</span></span><span style="display:flex;"><span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) in vec3 aNormal;
</span></span><span style="display:flex;"><span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>) in vec2 aTexCoords;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out vec2 TexCoords;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out VS_OUT {
</span></span><span style="display:flex;"><span>    vec3 FragPos;
</span></span><span style="display:flex;"><span>    vec3 Normal;
</span></span><span style="display:flex;"><span>    vec2 TexCoords;
</span></span><span style="display:flex;"><span>} vs_out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform mat4 projection;
</span></span><span style="display:flex;"><span>uniform mat4 view;
</span></span><span style="display:flex;"><span>uniform mat4 model;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vs_out.FragPos <span style="color:#f92672">=</span> vec3(model <span style="color:#f92672">*</span> vec4(aPos, <span style="color:#ae81ff">1.0</span>));
</span></span><span style="display:flex;"><span>    vs_out.Normal <span style="color:#f92672">=</span> transpose(inverse(mat3(model))) <span style="color:#f92672">*</span> aNormal;
</span></span><span style="display:flex;"><span>    vs_out.TexCoords <span style="color:#f92672">=</span> aTexCoords;
</span></span><span style="display:flex;"><span>    gl_Position <span style="color:#f92672">=</span> projection <span style="color:#f92672">*</span> view <span style="color:#f92672">*</span> model <span style="color:#f92672">*</span> vec4(aPos, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Le code d&rsquo;éclairage Blinn-Phong du fragment shader est exactement le même que celui que nous avions auparavant, avec une multiplication de l&rsquo;ombre à la fin :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>out vec4 FragColor;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>in VS_OUT {
</span></span><span style="display:flex;"><span>    vec3 FragPos;
</span></span><span style="display:flex;"><span>    vec3 Normal;
</span></span><span style="display:flex;"><span>    vec2 TexCoords;
</span></span><span style="display:flex;"><span>} fs_in;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform sampler2D diffuseTexture;
</span></span><span style="display:flex;"><span>uniform samplerCube depthMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform vec3 lightPos;
</span></span><span style="display:flex;"><span>uniform vec3 viewPos;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform <span style="color:#66d9ef">float</span> far_plane;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">ShadowCalculation</span>(vec3 fragPos)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    [...]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{           
</span></span><span style="display:flex;"><span>    vec3 color <span style="color:#f92672">=</span> texture(diffuseTexture, fs_in.TexCoords).rgb;
</span></span><span style="display:flex;"><span>    vec3 normal <span style="color:#f92672">=</span> normalize(fs_in.Normal);
</span></span><span style="display:flex;"><span>    vec3 lightColor <span style="color:#f92672">=</span> vec3(<span style="color:#ae81ff">0.3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ambient
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 ambient <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.3</span> <span style="color:#f92672">*</span> color;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// diffuse
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 lightDir <span style="color:#f92672">=</span> normalize(lightPos <span style="color:#f92672">-</span> fs_in.FragPos);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> diff <span style="color:#f92672">=</span> max(dot(lightDir, normal), <span style="color:#ae81ff">0.0</span>);
</span></span><span style="display:flex;"><span>    vec3 diffuse <span style="color:#f92672">=</span> diff <span style="color:#f92672">*</span> lightColor;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// specular
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 viewDir <span style="color:#f92672">=</span> normalize(viewPos <span style="color:#f92672">-</span> fs_in.FragPos);
</span></span><span style="display:flex;"><span>    vec3 reflectDir <span style="color:#f92672">=</span> reflect(<span style="color:#f92672">-</span>lightDir, normal);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> spec <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>    vec3 halfwayDir <span style="color:#f92672">=</span> normalize(lightDir <span style="color:#f92672">+</span> viewDir);  
</span></span><span style="display:flex;"><span>    spec <span style="color:#f92672">=</span> pow(max(dot(normal, halfwayDir), <span style="color:#ae81ff">0.0</span>), <span style="color:#ae81ff">64.0</span>);
</span></span><span style="display:flex;"><span>    vec3 specular <span style="color:#f92672">=</span> spec <span style="color:#f92672">*</span> lightColor;    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// calculate shadow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> shadow <span style="color:#f92672">=</span> ShadowCalculation(fs_in.FragPos);                      
</span></span><span style="display:flex;"><span>    vec3 lighting <span style="color:#f92672">=</span> (ambient <span style="color:#f92672">+</span> (<span style="color:#ae81ff">1.0</span> <span style="color:#f92672">-</span> shadow) <span style="color:#f92672">*</span> (diffuse <span style="color:#f92672">+</span> specular)) <span style="color:#f92672">*</span> color;    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> vec4(lighting, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>Il y a quelques différences subtiles : le code d&rsquo;éclairage est le même, mais nous avons maintenant un uniforme <code>samplerCube</code> et la fonction <code>ShadowCalculation</code> prend la position du fragment actuel comme argument au lieu de la position du fragment dans l&rsquo;espace lumière. Nous incluons également la valeur <code>far_plane</code> du frustum de lumière dont nous aurons besoin plus tard.</p>
<p>La plus grande différence se trouve dans le contenu de la fonction <code>ShadowCalculation</code> qui échantillonne maintenant les valeurs de profondeur à partir d&rsquo;un cubemap au lieu d&rsquo;une texture 2D. Examinons son contenu étape par étape.</p>
<p>La première chose à faire est de récupérer la profondeur du cubemap. Vous vous souvenez peut-être que dans la section cubemap de ce chapitre, nous avons stocké la profondeur en tant que distance linéaire entre le fragment et la position de la lumière ; nous adoptons une approche similaire ici :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">ShadowCalculation</span>(vec3 fragPos)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vec3 fragToLight <span style="color:#f92672">=</span> fragPos <span style="color:#f92672">-</span> lightPos; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> closestDepth <span style="color:#f92672">=</span> texture(depthMap, fragToLight).r;
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Ici, nous prenons le vecteur de différence entre la position du fragment et la position de la lumière et nous utilisons ce vecteur comme vecteur de direction pour échantillonner le cubemap. Le vecteur de direction n&rsquo;a pas besoin d&rsquo;être un vecteur unitaire pour échantillonner à partir d&rsquo;un cubemap, il n&rsquo;est donc pas nécessaire de le normaliser. La valeur <code>closeestDepth</code> résultante est la valeur de profondeur normalisée entre la source lumineuse et le fragment visible le plus proche.</p>
<p>La valeur <code>closestDepth</code> est actuellement comprise dans l&rsquo;intervalle $[0,1]$, nous la transformons donc d&rsquo;abord en $[0,far_plane]$ en la multipliant par <code>far_plane</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>closestDepth <span style="color:#f92672">*=</span> far_plane;  
</span></span></code></pre></div><p>Ensuite, nous récupérons la valeur de profondeur entre le fragment actuel et la source lumineuse, que nous pouvons facilement obtenir en prenant la longueur de <code>fragToLight</code> en raison de la façon dont nous avons calculé les valeurs de profondeur dans le cubemap :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> currentDepth <span style="color:#f92672">=</span> length(fragToLight);  
</span></span></code></pre></div><p>Cela renvoie une valeur de profondeur dans le même intervalle (ou plus grand) que <code>closestDepth</code>.</p>
<p>Nous pouvons maintenant comparer les deux valeurs de profondeur pour voir laquelle est la plus proche de l&rsquo;autre et déterminer si le fragment actuel est dans l&rsquo;ombre. Nous incluons également un biais d&rsquo;ombre afin de ne pas obtenir d&rsquo;acné d&rsquo;ombre, comme nous l&rsquo;avons vu dans le chapitre précédent.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> bias <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.05</span>; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> shadow <span style="color:#f92672">=</span> currentDepth <span style="color:#f92672">-</span>  bias <span style="color:#f92672">&gt;</span> closestDepth <span style="color:#f92672">?</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0.0</span>; 
</span></span></code></pre></div><p>La fonction devient alors :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">ShadowCalculation</span>(vec3 fragPos)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// get vector between fragment position and light position
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 fragToLight <span style="color:#f92672">=</span> fragPos <span style="color:#f92672">-</span> lightPos;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// use the light to fragment vector to sample from the depth map    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> closestDepth <span style="color:#f92672">=</span> texture(depthMap, fragToLight).r;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// it is currently in linear range between [0,1]. Re-transform back to original value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    closestDepth <span style="color:#f92672">*=</span> far_plane;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// now get current linear depth as the length between the fragment and light position
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> currentDepth <span style="color:#f92672">=</span> length(fragToLight);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// now test for shadows
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> bias <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.05</span>; 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> shadow <span style="color:#f92672">=</span> currentDepth <span style="color:#f92672">-</span>  bias <span style="color:#f92672">&gt;</span> closestDepth <span style="color:#f92672">?</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> shadow;
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Avec ces shaders, nous obtenons déjà de bonnes ombres, et cette fois dans toutes les directions environnantes, à partir d&rsquo;une lumière ponctuelle. Avec une lumière ponctuelle positionnée au centre d&rsquo;une scène simple, cela ressemblera un peu à ceci :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/02b_point_shadows-20230902_shadow01.png" alt="02b_point_shadows-20230902_shadow01"/>
Vous pouvez trouver le code source de cette démo <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/3.2.1.point_shadows/point_shadows.cpp">ici</a>.</p>
<h2 id="visualisation-du-tampon-de-profondeur-cubemap">Visualisation du tampon de profondeur cubemap<a hidden class="anchor" aria-hidden="true" href="#visualisation-du-tampon-de-profondeur-cubemap">#</a></h2>
<p>Si vous êtes un peu comme moi, vous n&rsquo;avez probablement pas réussi du premier coup, il est donc logique de faire un peu de débogage, l&rsquo;une des vérifications évidentes étant de valider si la map de profondeur a été construite correctement. Une astuce simple pour visualiser le tampon de profondeur est de prendre la variable <code>closestDepth</code> dans la fonction <code>ShadowCalculation</code> et de l&rsquo;afficher comme suit :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>FragColor <span style="color:#f92672">=</span> vec4(vec3(closestDepth <span style="color:#f92672">/</span> far_plane), <span style="color:#ae81ff">1.0</span>);  
</span></span></code></pre></div><p>Le résultat est une scène grisée où chaque couleur représente les valeurs de profondeur linéaire de la scène :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/02b_point_shadows-20230902_depth.png" alt="02b_point_shadows-20230902_depth"/>
Vous pouvez également voir les zones d&rsquo;ombre à venir sur le mur extérieur. Si l&rsquo;aspect est similaire, vous savez que le cubemap de profondeur a été correctement généré.</p>
<h2 id="pcf">PCF<a hidden class="anchor" aria-hidden="true" href="#pcf">#</a></h2>
<p>Comme les maps d&rsquo;ombres omnidirectionnelles sont basées sur les mêmes principes que les maps d&rsquo;ombres traditionnelles, elles présentent les mêmes artefacts dépendant de la résolution. Si vous zoomez suffisamment près, vous pouvez à nouveau voir des bords irréguliers. Le filtrage par pourcentage de proximité (Percentage-closer filtering ou PCF) nous permet de lisser ces bords irréguliers en filtrant plusieurs échantillons autour de la position du fragment et en faisant la moyenne des résultats.</p>
<p>Si nous prenons le même filtre PCF simple du chapitre précédent et que nous y ajoutons une troisième dimension, nous obtenons :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> shadow  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> bias    <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.05</span>; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> samples <span style="color:#f92672">=</span> <span style="color:#ae81ff">4.0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> offset  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">float</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>offset; x <span style="color:#f92672">&lt;</span> offset; x <span style="color:#f92672">+=</span> offset <span style="color:#f92672">/</span> (samples <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5</span>))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">float</span> y <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>offset; y <span style="color:#f92672">&lt;</span> offset; y <span style="color:#f92672">+=</span> offset <span style="color:#f92672">/</span> (samples <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5</span>))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">float</span> z <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>offset; z <span style="color:#f92672">&lt;</span> offset; z <span style="color:#f92672">+=</span> offset <span style="color:#f92672">/</span> (samples <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5</span>))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">float</span> closestDepth <span style="color:#f92672">=</span> texture(depthMap, fragToLight <span style="color:#f92672">+</span> vec3(x, y, z)).r; 
</span></span><span style="display:flex;"><span>            closestDepth <span style="color:#f92672">*=</span> far_plane;   <span style="color:#75715e">// undo mapping [0;1]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(currentDepth <span style="color:#f92672">-</span> bias <span style="color:#f92672">&gt;</span> closestDepth)
</span></span><span style="display:flex;"><span>                shadow <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1.0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>shadow <span style="color:#f92672">/=</span> (samples <span style="color:#f92672">*</span> samples <span style="color:#f92672">*</span> samples);
</span></span></code></pre></div><p>Le code n&rsquo;est pas très différent du code traditionnel de shadow mapping. Nous calculons et ajoutons des décalages de texture dynamiquement pour chaque axe sur la base d&rsquo;un nombre fixe d&rsquo;échantillons. Pour chaque échantillon, nous répétons le processus d&rsquo;ombrage original sur la direction de l&rsquo;échantillon décalé et nous faisons la moyenne des résultats à la fin.</p>
<p>Les ombres sont maintenant plus douces et lisses et donnent des résultats plus plausibles.
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/02b_point_shadows-20230902-PCF.png" alt="02b_point_shadows-20230902-PCF"/>
Cependant, avec des échantillons réglés sur $4.0$, nous prélevons un total de 64 échantillons par fragment, ce qui est beaucoup !</p>
<p>Comme la plupart de ces échantillons sont redondants en ce sens qu&rsquo;ils échantillonnent à proximité du vecteur de direction original, il pourrait être plus judicieux de n&rsquo;échantillonner que dans les directions perpendiculaires au vecteur de direction de l&rsquo;échantillon. Cependant, comme il n&rsquo;y a pas de moyen (facile) de déterminer quelles sous-directions sont redondantes, cela devient difficile. Une astuce consiste à prendre un tableau de directions de décalage qui sont toutes à peu près séparables, c&rsquo;est-à-dire que chacune d&rsquo;entre elles pointe dans des directions complètement différentes. Cela permet de réduire considérablement le nombre de sous-directions proches les unes des autres. Nous présentons ci-dessous un tableau de 20 directions de décalage au maximum :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vec3 sampleOffsetDirections[<span style="color:#ae81ff">20</span>] <span style="color:#f92672">=</span> vec3[]
</span></span><span style="display:flex;"><span>(
</span></span><span style="display:flex;"><span>   vec3( <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>), vec3( <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>), vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>), vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>), 
</span></span><span style="display:flex;"><span>   vec3( <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>), vec3( <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>), vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>), vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>   vec3( <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>), vec3( <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>), vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>), vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>   vec3( <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>,  <span style="color:#ae81ff">1</span>), vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>,  <span style="color:#ae81ff">1</span>), vec3( <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>), vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>   vec3( <span style="color:#ae81ff">0</span>,  <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>), vec3( <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">1</span>), vec3( <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>), vec3( <span style="color:#ae81ff">0</span>,  <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>);   
</span></span></code></pre></div><p>À partir de là, nous pouvons adapter l&rsquo;algorithme PCF pour qu&rsquo;il prenne une quantité fixe d&rsquo;échantillons à partir de <code>sampleOffsetDirections</code> et qu&rsquo;il les utilise pour échantillonner le cubemap. L&rsquo;avantage est que nous avons besoin de beaucoup moins d&rsquo;échantillons pour obtenir des résultats visuellement similaires.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> shadow <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> bias   <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.15</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> samples  <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> viewDistance <span style="color:#f92672">=</span> length(viewPos <span style="color:#f92672">-</span> fragPos);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> diskRadius <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.05</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> samples; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> closestDepth <span style="color:#f92672">=</span> texture(depthMap, fragToLight <span style="color:#f92672">+</span> sampleOffsetDirections[i] <span style="color:#f92672">*</span> diskRadius).r;
</span></span><span style="display:flex;"><span>    closestDepth <span style="color:#f92672">*=</span> far_plane;   <span style="color:#75715e">// undo mapping [0;1]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(currentDepth <span style="color:#f92672">-</span> bias <span style="color:#f92672">&gt;</span> closestDepth)
</span></span><span style="display:flex;"><span>        shadow <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1.0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>shadow <span style="color:#f92672">/=</span> <span style="color:#66d9ef">float</span>(samples); 
</span></span></code></pre></div><p>Ici, nous ajoutons plusieurs décalages, mis à l&rsquo;échelle par un certain <code>diskRadius</code>, autour du vecteur de direction <code>fragToLight</code> original pour échantillonner à partir du cubemap.</p>
<p>Une autre astuce intéressante que nous pouvons appliquer ici est que nous pouvons changer le <code>diskRadius</code> en fonction de la distance de l&rsquo;observateur au fragment, rendant les ombres plus douces lorsqu&rsquo;elles sont éloignées et plus nettes lorsqu&rsquo;elles sont proches.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> diskRadius <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1.0</span> <span style="color:#f92672">+</span> (viewDistance <span style="color:#f92672">/</span> far_plane)) <span style="color:#f92672">/</span> <span style="color:#ae81ff">25.0</span>;  
</span></span></code></pre></div><p>Les résultats de l&rsquo;algorithme PCF mis à jour donnent des résultats tout aussi bons, voire meilleurs, pour les ombres douces :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/02b_point_shadows-20230902-PCF2.png" alt="02b_point_shadows-20230902-PCF2"/></p>
<p>Bien entendu, le biais que nous ajoutons à chaque échantillon dépend fortement du contexte et devra toujours être ajusté en fonction de la scène avec laquelle vous travaillez. Jouez avec toutes les valeurs et voyez comment elles affectent la scène.</p>
<p>Vous pouvez trouver le code final <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/3.2.2.point_shadows_soft/point_shadows_soft.cpp">ici</a>.</p>
<p>Je dois mentionner que l&rsquo;utilisation de shaders géométriques pour générer une map de profondeur n&rsquo;est pas nécessairement plus rapide que de rendre la scène 6 fois pour chaque face. L&rsquo;utilisation d&rsquo;un shader géométrique comme celui-ci a ses propres inconvénients en termes de performances qui peuvent l&rsquo;emporter sur le gain de performance de l&rsquo;utilisation d&rsquo;un shader géométrique en premier lieu. Cela dépend bien sûr du type d&rsquo;environnement, des pilotes spécifiques de la carte vidéo et de nombreux autres facteurs. Par conséquent, si vous souhaitez vraiment tirer le meilleur parti de votre système, assurez-vous d&rsquo;établir le profil des deux méthodes et de sélectionner la plus efficace pour votre scène.</p>
<h2 id="ressources-additionnelles">Ressources additionnelles<a hidden class="anchor" aria-hidden="true" href="#ressources-additionnelles">#</a></h2>
<ul>
<li><a href="http://www.sunandblackcat.com/tipFullView.php?l=eng&amp;topicid=36">Cartographie des ombres pour les sources lumineuses ponctuelles dans OpenGL</a> : tutoriel de cartographie des ombres omnidirectionnelle par sunandblackcat.</li>
<li><a href="http://ogldev.atspace.co.uk/www/tutorial43/tutorial43.html">Multipass Shadow Mapping With Point Lights</a> : tutoriel sur les ombres omnidirectionnelles par ogldev.</li>
<li><a href="http://www.cg.tuwien.ac.at/~husky/RTR/OmnidirShadows-whyCaps.pdf">Ombres omnidirectionnelles</a> : une belle série de diapositives sur le mappage omnidirectionnel des ombres par Peter Houska.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hrst4.xyz/">hrst4&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
