<!DOCTYPE html>
<html lang="en-us"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<body><header>
    <nav class="navbar" role="navigation">
        <div class="container">
            <div class="navbar-brand">
                <a href="/" title="home" class="navbar-item">
                    <span class="logo"><h1>hrst4&#39;s blog</h1></span>
                </a>
                
                <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                    <span aria-hidden="true"></span>
                </a>
            </div>

            <div class="navbar-menu">
                <div class="navbar-start">
                    
                    <a href="/apropos" class="navbar-item">apropos</a>
                    
                    <a href="/docs" class="navbar-item">docs</a>
                    
                </div>
                <div class="navbar-end">
                    
                </div>
            </div>

        </div>
    </nav>
    <script>
        $(document).ready(function () {
            $(".navbar-burger").click(function () {
                $(".navbar-burger").toggleClass("is-active");
                $(".navbar-menu").toggleClass("is-active");
            })
        })
    </script>
</header><main>

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="ssao">SSAO<a hidden class="anchor" aria-hidden="true" href="#ssao">#</a></h1>
<p>Nous avons brièvement abordé le sujet dans le chapitre sur l&rsquo;éclairage de base : l&rsquo;éclairage ambiant. <strong>L&rsquo;éclairage ambiant est une constante lumineuse fixe que nous ajoutons à l&rsquo;éclairage global d&rsquo;une scène pour simuler la diffusion de la lumière</strong>. En réalité, la lumière se disperse dans toutes sortes de directions avec des intensités variables, de sorte que les parties indirectement éclairées d&rsquo;une scène doivent également présenter des intensités variables. <strong>L&rsquo;un des types d&rsquo;approximation de l&rsquo;éclairage indirect est appelé occlusion ambiante</strong>. Il tente d&rsquo;approximer l&rsquo;éclairage indirect en assombrissant les plis, les trous et les surfaces proches les unes des autres. Ces zones sont largement occultées par la géométrie environnante et les rayons lumineux ont donc moins d&rsquo;endroits où s&rsquo;échapper, d&rsquo;où l&rsquo;aspect plus sombre de ces zones. Jetez un coup d&rsquo;œil aux coins et aux plis de votre pièce pour constater que la lumière y semble un peu plus sombre.</p>
<p>Vous trouverez ci-dessous un exemple d&rsquo;image d&rsquo;une scène avec et sans occlusion ambiante. Remarquez que la lumière (ambiante) est plus occultée, en particulier entre les plis :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230904-ssao1.png" alt="08_ssao-20230904-ssao1.png"/>
Bien qu&rsquo;il ne s&rsquo;agisse pas d&rsquo;un effet incroyablement évident, l&rsquo;image avec l&rsquo;occlusion ambiante activée semble beaucoup plus réaliste grâce à ces petits détails ressemblant à des occlusions, ce qui donne à l&rsquo;ensemble de la scène une plus grande impression de profondeur.</p>
<p>Les techniques d&rsquo;occlusion ambiante sont coûteuses car elles doivent prendre en compte la géométrie environnante. On pourrait tirer un grand nombre de rayons pour chaque point de l&rsquo;espace afin de déterminer son degré d&rsquo;occlusion, mais cela devient rapidement impossible à calculer pour des solutions en temps réel. En 2007, Crytek a publié une technique appelée &ldquo;<strong>screen-space ambient occlusion</strong>&rdquo; (<strong>SSAO</strong>) pour son titre Crysis. Cette technique utilise le tampon de profondeur d&rsquo;une scène dans l&rsquo;espace-écran pour déterminer la quantité d&rsquo;occlusion au lieu de données géométriques réelles. Cette approche est incroyablement rapide par rapport à l&rsquo;occlusion ambiante réelle et donne des résultats plausibles, ce qui en fait la norme de facto pour l&rsquo;approximation de l&rsquo;occlusion ambiante en temps réel.</p>
<p>Les principes de base de l&rsquo;occlusion ambiante dans l&rsquo;espace-écran sont simples : pour chaque fragment d&rsquo;un quad qui remplit l&rsquo;écran, nous calculons un facteur d&rsquo;occlusion basé sur les valeurs de profondeur environnantes du fragment. Le facteur d&rsquo;occlusion est ensuite utilisé pour réduire ou annuler la composante d&rsquo;éclairage ambiant du fragment. Le facteur d&rsquo;occlusion est obtenu en prenant plusieurs échantillons de profondeur dans un kernel d&rsquo;échantillons de sphère entourant la position du fragment et en comparant chacun des échantillons avec la valeur de profondeur du fragment actuel. Le nombre d&rsquo;échantillons dont la valeur de profondeur est supérieure à celle du fragment représente le facteur d&rsquo;occlusion.
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230904-ssao2.png" alt="08_ssao-20230904-ssao2.png"/>
Chacun des échantillons de profondeur de gris situés à l&rsquo;intérieur de la géométrie contribue au facteur d&rsquo;occlusion total ; plus nous trouvons d&rsquo;échantillons à l&rsquo;intérieur de la géométrie, moins le fragment devrait recevoir d&rsquo;éclairage ambiant.</p>
<p>Il est clair que la qualité et la précision de l&rsquo;effet sont directement liées au nombre d&rsquo;échantillons environnants que nous prenons. Si le nombre d&rsquo;échantillons est trop faible, la précision diminue considérablement et nous obtenons un artefact appelé &ldquo;<strong>banding</strong>&rdquo; ; s&rsquo;il est trop élevé, nous perdons en performance. Nous pouvons réduire le nombre d&rsquo;échantillons à tester en introduisant un peu de hasard dans le kernel de l&rsquo;échantillon. En faisant tourner au hasard le kernel de l&rsquo;échantillon à chaque fragment, nous pouvons obtenir des résultats de haute qualité avec un nombre d&rsquo;échantillons beaucoup plus réduit. <strong>Cela a un prix, car le caractère aléatoire introduit un bruit perceptible que nous devrons corriger en rendant les résultats flous</strong>. L&rsquo;image ci-dessous (avec l&rsquo;aimable autorisation de John Chapman) illustre l&rsquo;effet de bande et l&rsquo;effet du hasard sur les résultats :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230904-ssao3.png" alt="08_ssao-20230904-ssao3.png"/>
Comme vous pouvez le constater, même si les résultats SSAO présentent des bandes visibles en raison du faible nombre d&rsquo;échantillons, l&rsquo;introduction d&rsquo;un élément aléatoire permet de supprimer complètement les effets de bande.</p>
<p>La méthode SSAO développée par Crytek avait un certain style visuel. Le kernel d&rsquo;échantillonnage utilisé étant une sphère, les murs plats paraissent gris car la moitié des échantillons du kernel se retrouvent dans la géométrie environnante. Vous trouverez ci-dessous une image de l&rsquo;occlusion ambiante de l&rsquo;espace-écran de Crysis qui illustre clairement cette impression de gris :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230904-ssao4.png" alt="08_ssao-20230904-ssao4.png"/>
C&rsquo;est pourquoi nous n&rsquo;utiliserons pas un kernel d&rsquo;échantillonnage de sphère, mais plutôt un kernel d&rsquo;échantillonnage d&rsquo;hémisphère orienté le long du vecteur normal d&rsquo;une surface.
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230904-ssao5.png" alt="08_ssao-20230904-ssao5.png"/>
En échantillonnant autour de cet hémisphère orienté vers la normale, nous ne considérons pas la géométrie sous-jacente du fragment comme une contribution au facteur d&rsquo;occlusion. Cela supprime la sensation de gris de l&rsquo;occlusion ambiante et produit généralement des résultats plus réalistes. La technique de ce chapitre est basée sur cette méthode de l&rsquo;hémisphère orienté normal et sur une version légèrement modifiée du brillant tutoriel SSAO de John Chapman.</p>
<h2 id="tampons-pour-les-échantillons">Tampons pour les échantillons<a hidden class="anchor" aria-hidden="true" href="#tampons-pour-les-échantillons">#</a></h2>
<p>SSAO nécessite des informations géométriques car nous avons besoin d&rsquo;un moyen de déterminer le facteur d&rsquo;occlusion d&rsquo;un fragment. Pour chaque fragment, nous aurons besoin des données suivantes :</p>
<ul>
<li>Un vecteur <strong>position</strong> par fragment.</li>
<li>Un vecteur <strong>normal</strong> par fragment.</li>
<li>Une couleur <strong>albedo</strong> par fragment.</li>
<li>Un kernel d&rsquo;échantillon**.</li>
<li>Un vecteur de <strong>rotation aléatoire</strong> par fragment, utilisé pour faire pivoter le kernel de l&rsquo;échantillon.</li>
</ul>
<p>En utilisant une position par fragment dans l&rsquo;espace visuel, nous pouvons orienter un échantillon de kernel hémisphérique autour de la normale à la surface du fragment dans l&rsquo;espace visuel et utiliser ce kernel pour échantillonner la texture du tampon de position à des décalages variables. Pour chaque échantillon de kernel par fragment, nous comparons sa profondeur avec sa profondeur dans le tampon de position pour déterminer le degré d&rsquo;occlusion. Le facteur d&rsquo;occlusion résultant est ensuite utilisé pour limiter la composante finale de l&rsquo;éclairage ambiant. En incluant également un vecteur de rotation par fragment, nous pouvons réduire de manière significative le nombre d&rsquo;échantillons que nous devrons prendre, comme nous le verrons bientôt.
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230904-ssao6.png" alt="08_ssao-20230904-ssao6.png"/>
Le SSAO étant une technique d&rsquo;espace-écran, nous calculons son effet sur chaque fragment dans un quad 2D qui remplit l&rsquo;écran. Cela signifie que nous ne disposons d&rsquo;aucune information géométrique sur la scène. Ce que nous pourrions faire, c&rsquo;est rendre les données géométriques par fragment dans des textures de l&rsquo;espace-écran que nous envoyons ensuite au shader SSAO afin d&rsquo;avoir accès aux données géométriques par fragment. Si vous avez suivi le chapitre précédent, vous vous rendrez compte que cela ressemble beaucoup à la configuration du tampon G d&rsquo;un moteur de rendu différé. C&rsquo;est pourquoi SSAO est parfaitement adapté à la combinaison avec le rendu différé, car nous disposons déjà des vecteurs de position et de normalité dans le G-buffer.</p>
<blockquote>
<p>Dans ce chapitre, nous allons implémenter SSAO au-dessus d&rsquo;une version légèrement simplifiée du <a href="moteur%20de%20rendu%20diff%c3%a9r%c3%a9">moteur de rendu différé</a> (todo: link) du chapitre sur l&rsquo;ombrage différé. Si vous n&rsquo;êtes pas sûr de ce qu&rsquo;est l&rsquo;ombrage différé, lisez d&rsquo;abord ce chapitre.</p>
</blockquote>
<p>Comme nous devrions disposer des données de position et de normale par fragment à partir des objets de la scène, le shader de fragment de l&rsquo;étape de géométrie est assez simple :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) out vec4 gPosition;
</span></span><span style="display:flex;"><span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) out vec3 gNormal;
</span></span><span style="display:flex;"><span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>) out vec4 gAlbedoSpec;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>in vec2 TexCoords;
</span></span><span style="display:flex;"><span>in vec3 FragPos;
</span></span><span style="display:flex;"><span>in vec3 Normal;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// store the fragment position vector in the first gbuffer texture
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    gPosition <span style="color:#f92672">=</span> FragPos;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// also store the per-fragment normals into the gbuffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    gNormal <span style="color:#f92672">=</span> normalize(Normal);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// and the diffuse per-fragment color, ignore specular
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    gAlbedoSpec.rgb <span style="color:#f92672">=</span> vec3(<span style="color:#ae81ff">0.95</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Puisque le SSAO est une technique d&rsquo;espace-écran où l&rsquo;occlusion est calculée à partir de la vue visible, il est logique d&rsquo;implémenter l&rsquo;algorithme dans l&rsquo;espace-écran. Par conséquent, <code>FragPos</code> et <code>Normal</code>, tels qu&rsquo;ils sont fournis par le vertex shader de l&rsquo;étape géométrique, sont transformés en espace de vue (multipliés également par la matrice de vue).</p>
<blockquote>
<p>Il est possible de reconstruire les vecteurs de position à partir des seules valeurs de profondeur, en utilisant quelques astuces astucieuses décrites par Matt Pettineo sur son blog. Cela nécessite quelques calculs supplémentaires dans les shaders, mais nous évite d&rsquo;avoir à stocker les données de position dans le G-buffer (qui coûte beaucoup de mémoire). Pour les besoins d&rsquo;un exemple plus simple, nous laisserons ces optimisations en dehors du chapitre.</p>
</blockquote>
<p>La texture du tampon de couleur <code>gPosition</code> est configurée comme suit :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glGenTextures(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>gPosition);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, gPosition);
</span></span><span style="display:flex;"><span>glTexImage2D(GL_TEXTURE_2D, <span style="color:#ae81ff">0</span>, GL_RGBA16F, SCR_WIDTH, SCR_HEIGHT, <span style="color:#ae81ff">0</span>, GL_RGBA, GL_FLOAT, NULL);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); 
</span></span></code></pre></div><p>Cela nous donne une texture de position que nous pouvons utiliser pour obtenir des valeurs de profondeur pour chacun des échantillons du kernel. Notez que nous stockons les positions dans un format de données à virgule flottante ; de cette façon, les valeurs de position ne sont pas limitées à $[0.0,1.0]$ et nous avons besoin d&rsquo;une plus grande précision. Notez également que la méthode d&rsquo;enveloppement de la texture est <code>GL_CLAMP_TO_EDGE</code>. Cela permet de s&rsquo;assurer que nous ne suréchantillonnons pas accidentellement les valeurs de position/profondeur dans l&rsquo;espace-écran en dehors de la région de coordonnées par défaut de la texture.</p>
<p>Ensuite, nous avons besoin du kernel d&rsquo;échantillonnage de l&rsquo;hémisphère et d&rsquo;une méthode pour le faire pivoter de manière aléatoire.</p>
<h2 id="hémisphère-orienté-vers-la-normale">Hémisphère orienté vers la normale<a hidden class="anchor" aria-hidden="true" href="#hémisphère-orienté-vers-la-normale">#</a></h2>
<p>Nous devons générer un certain nombre d&rsquo;échantillons orientés le long de la normale d&rsquo;une surface. Comme nous l&rsquo;avons brièvement évoqué au début de ce chapitre, nous voulons générer des échantillons qui forment un hémisphère. Comme il est difficile et peu plausible de générer un kernel d&rsquo;échantillons pour chaque direction de la normale à la surface, nous allons générer un kernel d&rsquo;échantillons dans l&rsquo;espace tangent, avec le vecteur normal pointant dans la direction z positive.
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230904-ssao7.png" alt="08_ssao-20230904-ssao7.png"/>
En supposant que nous disposons d&rsquo;un hémisphère unitaire, nous pouvons obtenir un kernel d&rsquo;échantillonnage avec un maximum de 64 valeurs d&rsquo;échantillonnage comme suit :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>uniform_real_distribution<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span> randomFloats(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>); <span style="color:#75715e">// random floats between [0.0, 1.0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>default_random_engine generator;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>glm<span style="color:#f92672">::</span>vec3<span style="color:#f92672">&gt;</span> ssaoKernel;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">64</span>; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    glm<span style="color:#f92672">::</span>vec3 sample(
</span></span><span style="display:flex;"><span>        randomFloats(generator) <span style="color:#f92672">*</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.0</span>, 
</span></span><span style="display:flex;"><span>        randomFloats(generator) <span style="color:#f92672">*</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.0</span>, 
</span></span><span style="display:flex;"><span>        randomFloats(generator)
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>    sample  <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>normalize(sample);
</span></span><span style="display:flex;"><span>    sample <span style="color:#f92672">*=</span> randomFloats(generator);
</span></span><span style="display:flex;"><span>    ssaoKernel.push_back(sample);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Nous faisons varier les directions x et y dans l&rsquo;espace tangent entre $-1.0$ et $1.0$, et la direction z des échantillons entre $0.0$ et $1.0$ (si nous faisions varier la direction z entre $-1.0$ et $1.0$ également, nous aurions un kernel d&rsquo;échantillon sphérique). Comme le kernel d&rsquo;échantillons sera orienté le long de la normale à la surface, les vecteurs d&rsquo;échantillons résultants se retrouveront tous dans l&rsquo;hémisphère.</p>
<p>Actuellement, tous les échantillons sont distribués de manière aléatoire dans le kernel d&rsquo;échantillonnage, mais nous préférons accorder plus d&rsquo;importance aux occlusions proches du fragment réel. Nous voulons distribuer plus d&rsquo;échantillons du kernel près de l&rsquo;origine. Nous pouvons le faire à l&rsquo;aide d&rsquo;une fonction d&rsquo;interpolation accélérée :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> scale <span style="color:#f92672">=</span> (<span style="color:#66d9ef">float</span>)i <span style="color:#f92672">/</span> <span style="color:#ae81ff">64.0</span>; 
</span></span><span style="display:flex;"><span>   scale   <span style="color:#f92672">=</span> lerp(<span style="color:#ae81ff">0.1f</span>, <span style="color:#ae81ff">1.0f</span>, scale <span style="color:#f92672">*</span> scale);
</span></span><span style="display:flex;"><span>   sample <span style="color:#f92672">*=</span> scale;
</span></span><span style="display:flex;"><span>   ssaoKernel.push_back(sample);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Où la fonction <code>lerp</code> est définie comme suit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">lerp</span>(<span style="color:#66d9ef">float</span> a, <span style="color:#66d9ef">float</span> b, <span style="color:#66d9ef">float</span> f)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> f <span style="color:#f92672">*</span> (b <span style="color:#f92672">-</span> a);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Nous obtenons ainsi une distribution du kernel qui place la plupart des échantillons plus près de son origine.
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230904-ssao8.png" alt="08_ssao-20230904-ssao8.png"/>
Chacun des échantillons du kernel sera utilisé pour décaler la position du fragment dans l&rsquo;espace visuel afin d&rsquo;échantillonner la géométrie environnante. Nous avons besoin d&rsquo;un grand nombre d&rsquo;échantillons dans l&rsquo;espace visuel pour obtenir des résultats réalistes, ce qui peut s&rsquo;avérer trop lourd en termes de performances. Cependant, si nous pouvons introduire une rotation/un bruit semi-aléatoire par fragment, nous pouvons réduire de manière significative le nombre d&rsquo;échantillons requis.</p>
<h2 id="rotations-du-kernel-au-hasard">Rotations du kernel au hasard<a hidden class="anchor" aria-hidden="true" href="#rotations-du-kernel-au-hasard">#</a></h2>
<p>En introduisant un peu d&rsquo;aléatoire dans les kernels d&rsquo;échantillonnage, nous réduisons considérablement le nombre d&rsquo;échantillons nécessaires pour obtenir de bons résultats. Nous pourrions créer un vecteur de rotation aléatoire pour chaque fragment d&rsquo;une scène, mais cela consomme rapidement de la mémoire. Il est plus judicieux de créer une petite texture de vecteurs de rotation aléatoire que nous répartissons sur l&rsquo;écran.</p>
<p>Nous créons un tableau $4\times4$ de vecteurs de rotation aléatoires orientés autour de la normale à la surface de l&rsquo;espace tangent :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>glm<span style="color:#f92672">::</span>vec3<span style="color:#f92672">&gt;</span> ssaoNoise;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">16</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    glm<span style="color:#f92672">::</span>vec3 noise(
</span></span><span style="display:flex;"><span>        randomFloats(generator) <span style="color:#f92672">*</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.0</span>, 
</span></span><span style="display:flex;"><span>        randomFloats(generator) <span style="color:#f92672">*</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.0</span>, 
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0.0f</span>); 
</span></span><span style="display:flex;"><span>    ssaoNoise.push_back(noise);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Comme le kernel d&rsquo;échantillonnage est orienté le long de la direction z positive dans l&rsquo;espace tangent, nous laissons la composante z à $0.0$ afin d&rsquo;effectuer une rotation autour de l&rsquo;axe z.</p>
<p>Nous créons ensuite une texture $4\times 4$ qui contient les vecteurs de rotation aléatoires ; assurez-vous de régler sa méthode de wrapping sur <code>GL_REPEAT</code> pour qu&rsquo;elle s&rsquo;étende correctement sur l&rsquo;écran.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> noiseTexture; 
</span></span><span style="display:flex;"><span>glGenTextures(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>noiseTexture);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, noiseTexture);
</span></span><span style="display:flex;"><span>glTexImage2D(GL_TEXTURE_2D, <span style="color:#ae81ff">0</span>, GL_RGBA16F, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>, GL_RGB, GL_FLOAT, <span style="color:#f92672">&amp;</span>ssaoNoise[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);  
</span></span></code></pre></div><p>Nous disposons à présent de toutes les données d&rsquo;entrée nécessaires à la mise en œuvre du SSAO.</p>
<h2 id="le-shader-ssao">Le shader SSAO<a hidden class="anchor" aria-hidden="true" href="#le-shader-ssao">#</a></h2>
<p>Le shader SSAO s&rsquo;exécute sur un quad 2D qui remplit l&rsquo;écran et calcule la valeur d&rsquo;occlusion pour chacun de ses fragments. Comme nous devons stocker le résultat de l&rsquo;étape SSAO (pour l&rsquo;utiliser dans le shader d&rsquo;éclairage final), nous créons encore un autre objet framebuffer :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> ssaoFBO;
</span></span><span style="display:flex;"><span>glGenFramebuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>ssaoFBO);  
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> ssaoColorBuffer;
</span></span><span style="display:flex;"><span>glGenTextures(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>ssaoColorBuffer);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer);
</span></span><span style="display:flex;"><span>glTexImage2D(GL_TEXTURE_2D, <span style="color:#ae81ff">0</span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span style="color:#ae81ff">0</span>, GL_RED, GL_FLOAT, NULL);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBuffer, <span style="color:#ae81ff">0</span>); 
</span></span></code></pre></div><p>Comme le résultat de l&rsquo;occlusion ambiante est une valeur unique en niveaux de gris, nous n&rsquo;aurons besoin que de la composante rouge d&rsquo;une texture, c&rsquo;est pourquoi nous définissons le format interne du tampon de couleur sur <code>GL_RED</code>.</p>
<p>Le processus complet de rendu du SSAO ressemble alors à ceci :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// geometry pass: render stuff into G-buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);
</span></span><span style="display:flex;"><span>    [...]
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, <span style="color:#ae81ff">0</span>);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// use G-buffer to render SSAO texture
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO);
</span></span><span style="display:flex;"><span>    glClear(GL_COLOR_BUFFER_BIT);    
</span></span><span style="display:flex;"><span>    glActiveTexture(GL_TEXTURE0);
</span></span><span style="display:flex;"><span>    glBindTexture(GL_TEXTURE_2D, gPosition);
</span></span><span style="display:flex;"><span>    glActiveTexture(GL_TEXTURE1);
</span></span><span style="display:flex;"><span>    glBindTexture(GL_TEXTURE_2D, gNormal);
</span></span><span style="display:flex;"><span>    glActiveTexture(GL_TEXTURE2);
</span></span><span style="display:flex;"><span>    glBindTexture(GL_TEXTURE_2D, noiseTexture);
</span></span><span style="display:flex;"><span>    shaderSSAO.use();
</span></span><span style="display:flex;"><span>    SendKernelSamplesToShader();
</span></span><span style="display:flex;"><span>    shaderSSAO.setMat4(<span style="color:#e6db74">&#34;projection&#34;</span>, projection);
</span></span><span style="display:flex;"><span>    RenderQuad();
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// lighting pass: render scene lighting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glClear(GL_COLOR_BUFFER_BIT <span style="color:#f92672">|</span> GL_DEPTH_BUFFER_BIT);
</span></span><span style="display:flex;"><span>shaderLightingPass.use();
</span></span><span style="display:flex;"><span>[...]
</span></span><span style="display:flex;"><span>glActiveTexture(GL_TEXTURE3);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer);
</span></span><span style="display:flex;"><span>[...]
</span></span><span style="display:flex;"><span>RenderQuad();  
</span></span></code></pre></div><p>Le shader SSAO prend en entrée les textures du tampon G, la texture de bruit et les échantillons du kernel de l&rsquo;hémisphère orienté vers la normale :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>out <span style="color:#66d9ef">float</span> FragColor;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>in vec2 TexCoords;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform sampler2D gPosition;
</span></span><span style="display:flex;"><span>uniform sampler2D gNormal;
</span></span><span style="display:flex;"><span>uniform sampler2D texNoise;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform vec3 samples[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>uniform mat4 projection;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// tile noise texture over screen, based on screen dimensions divided by noise size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> vec2 noiseScale <span style="color:#f92672">=</span> vec2(<span style="color:#ae81ff">800.0</span><span style="color:#f92672">/</span><span style="color:#ae81ff">4.0</span>, <span style="color:#ae81ff">600.0</span><span style="color:#f92672">/</span><span style="color:#ae81ff">4.0</span>); <span style="color:#75715e">// screen = 800x600
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    [...]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Il est intéressant de noter ici la variable <code>noiseScale</code>. Nous voulons placer la texture de bruit sur tout l&rsquo;écran, mais comme les <code>TexCoords</code> varient entre $0.0$ et $1.0$, la texture <code>texNoise</code> ne sera pas placée sur l&rsquo;ensemble de l&rsquo;écran. Nous allons donc calculer la quantité nécessaire pour mettre à l&rsquo;échelle les <code>TexCoords</code> en divisant les dimensions de l&rsquo;écran par la taille de la texture de bruit.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vec3 fragPos   <span style="color:#f92672">=</span> texture(gPosition, TexCoords).xyz;
</span></span><span style="display:flex;"><span>vec3 normal    <span style="color:#f92672">=</span> texture(gNormal, TexCoords).rgb;
</span></span><span style="display:flex;"><span>vec3 randomVec <span style="color:#f92672">=</span> texture(texNoise, TexCoords <span style="color:#f92672">*</span> noiseScale).xyz; 
</span></span></code></pre></div><p>Comme nous avons réglé les paramètres de tiling de <code>texNoise</code> sur <code>GL_REPEAT</code>, les valeurs aléatoires seront répétées sur tout l&rsquo;écran. Avec le vecteur <code>fragPos</code> et le vecteur normal, nous disposons alors de suffisamment de données pour créer une matrice TBN qui transforme n&rsquo;importe quel vecteur de l&rsquo;espace tangent à l&rsquo;espace visuel :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vec3 tangent   <span style="color:#f92672">=</span> normalize(randomVec <span style="color:#f92672">-</span> normal <span style="color:#f92672">*</span> dot(randomVec, normal));
</span></span><span style="display:flex;"><span>vec3 bitangent <span style="color:#f92672">=</span> cross(normal, tangent);
</span></span><span style="display:flex;"><span>mat3 TBN       <span style="color:#f92672">=</span> mat3(tangent, bitangent, normal); 
</span></span></code></pre></div><p>En utilisant un processus appelé <strong>processus de Gramm-Schmidt</strong>, nous créons une base orthogonale, chaque fois légèrement inclinée en fonction de la valeur de <code>randomVec</code>. Notez que comme nous utilisons un vecteur aléatoire pour construire le vecteur tangent, il n&rsquo;est pas nécessaire que la matrice TBN soit exactement alignée sur la surface de la géométrie, et il n&rsquo;est donc pas nécessaire d&rsquo;avoir des vecteurs tangents (et bitangents) par sommet.</p>
<p>Ensuite, nous itérons sur chacun des échantillons du kernel, transformons les échantillons de la tangente à l&rsquo;espace visuel, les ajoutons à la position actuelle du fragment et comparons la profondeur de la position du fragment avec la profondeur de l&rsquo;échantillon stockée dans le tampon de position de l&rsquo;espace visuel. Voyons cela étape par étape :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> occlusion <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> kernelSize; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// get sample position
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 samplePos <span style="color:#f92672">=</span> TBN <span style="color:#f92672">*</span> samples[i]; <span style="color:#75715e">// from tangent to view-space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    samplePos <span style="color:#f92672">=</span> fragPos <span style="color:#f92672">+</span> samplePos <span style="color:#f92672">*</span> radius; 
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    [...]
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>Ici, <code>kernelSize</code> et radius sont des variables que nous pouvons utiliser pour ajuster l&rsquo;effet ; dans ce cas, une valeur de $64$ et $0.5$ respectivement. Pour chaque itération, nous transformons d&rsquo;abord l&rsquo;échantillon respectif en espace-temps. Nous ajoutons ensuite l&rsquo;échantillon de décalage du kernel de l&rsquo;espace visuel à la position du fragment de l&rsquo;espace visuel. Nous multiplions ensuite l&rsquo;échantillon décalé par le rayon pour augmenter (ou diminuer) le rayon d&rsquo;échantillonnage effectif du <strong>SSAO</strong>.</p>
<p>Ensuite, nous voulons transformer l&rsquo;échantillon en espace-écran afin de pouvoir échantillonner la valeur de position/profondeur de l&rsquo;échantillon comme si nous rendions sa position directement à l&rsquo;écran. Comme le vecteur se trouve actuellement dans l&rsquo;espace de vue, nous allons d&rsquo;abord le transformer en espace-clip à l&rsquo;aide de la matrice de projection uniforme :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vec4 offset <span style="color:#f92672">=</span> vec4(samplePos, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>offset      <span style="color:#f92672">=</span> projection <span style="color:#f92672">*</span> offset;    <span style="color:#75715e">// from view to clip-space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>offset.xyz <span style="color:#f92672">/=</span> offset.w;               <span style="color:#75715e">// perspective divide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>offset.xyz  <span style="color:#f92672">=</span> offset.xyz <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>; <span style="color:#75715e">// transform to range 0.0 - 1.0  
</span></span></span></code></pre></div><p>Une fois la variable transformée en espace-clip, nous effectuons l&rsquo;étape de division de la perspective en divisant ses composantes xyz avec sa composante w. Les coordonnées normalisées du dispositif qui en résultent sont ensuite transformées dans la plage $[0,0, 1,0]$ afin que nous puissions les utiliser pour échantillonner la texture de la position :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> sampleDepth <span style="color:#f92672">=</span> texture(gPosition, offset.xy).z; 
</span></span></code></pre></div><p>Nous utilisons les composantes x et y du vecteur de décalage pour échantillonner la texture de la position afin de récupérer la profondeur (ou la valeur z) de la position de l&rsquo;échantillon telle qu&rsquo;elle est vue du point de vue de l&rsquo;observateur (le premier fragment visible non occulté). Nous vérifions ensuite si la valeur de profondeur actuelle de l&rsquo;échantillon est supérieure à la valeur de profondeur stockée et, si c&rsquo;est le cas, nous l&rsquo;ajoutons au facteur de contribution final :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>occlusion <span style="color:#f92672">+=</span> (sampleDepth <span style="color:#f92672">&gt;=</span> samplePos.z <span style="color:#f92672">+</span> bias <span style="color:#f92672">?</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0.0</span>);
</span></span></code></pre></div><p>Notez que nous ajoutons ici un petit biais à la valeur de profondeur du fragment d&rsquo;origine (fixée à $0.025$ dans cet exemple). Un biais n&rsquo;est pas toujours nécessaire, mais il permet d&rsquo;ajuster visuellement l&rsquo;effet SSAO et de résoudre les effets d&rsquo;acné qui peuvent se produire en fonction de la complexité de la scène.</p>
<p>Nous n&rsquo;avons pas encore tout à fait terminé, car il reste un petit problème à prendre en compte. Lorsqu&rsquo;un fragment est testé pour l&rsquo;occlusion ambiante et qu&rsquo;il est aligné près du bord d&rsquo;une surface, il prendra également en compte les valeurs de profondeur des surfaces situées loin derrière la surface testée ; ces valeurs contribueront (à tort) au facteur d&rsquo;occlusion. Nous pouvons résoudre ce problème en introduisant une vérification de la portée, comme l&rsquo;illustre l&rsquo;image suivante (avec l&rsquo;aimable autorisation de John Chapman) :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230909-ssao9.png" alt="08_ssao-20230909-ssao9.png"/>
Nous introduisons un contrôle de portée qui garantit qu&rsquo;un fragment contribue au facteur d&rsquo;occlusion si ses valeurs de profondeur sont comprises dans le rayon de l&rsquo;échantillon. Nous remplaçons la dernière ligne par :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> rangeCheck <span style="color:#f92672">=</span> smoothstep(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>, radius <span style="color:#f92672">/</span> abs(fragPos.z <span style="color:#f92672">-</span> sampleDepth));
</span></span><span style="display:flex;"><span>occlusion       <span style="color:#f92672">+=</span> (sampleDepth <span style="color:#f92672">&gt;=</span> samplePos.z <span style="color:#f92672">+</span> bias <span style="color:#f92672">?</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0.0</span>) <span style="color:#f92672">*</span> rangeCheck;
</span></span></code></pre></div><p>Ici, nous avons utilisé la fonction <code>smoothstep</code> de GLSL qui interpole son troisième paramètre entre les plages du premier et du deuxième paramètre, en renvoyant $0.0$ si la valeur est inférieure ou égale à son premier paramètre et $1.0$ si elle est égale ou supérieure à son deuxième paramètre. Si la différence de profondeur se situe entre deux rayons, sa valeur est interpolée entre $0.0$ et $1.0$ à l&rsquo;aide de la courbe suivante :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230909-ssao10.png" alt="08_ssao-20230909-ssao10.png"/>
Si nous devions utiliser un contrôle de plage à coupure dure (?) (hard cut-off range) qui supprimerait brusquement les contributions d&rsquo;occlusion si les valeurs de profondeur sont en dehors du rayon, nous verrions des frontières évidentes (peu attrayantes) à l&rsquo;endroit où le contrôle de plage est appliqué.</p>
<p>La dernière étape consiste à normaliser la contribution de l&rsquo;occlusion en fonction de la taille du kernel et à produire les résultats. Notez que nous soustrayons le facteur d&rsquo;occlusion de $1.0$ afin de pouvoir utiliser directement le facteur d&rsquo;occlusion pour mettre à l&rsquo;échelle la composante d&rsquo;éclairage ambiant.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>occlusion <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">-</span> (occlusion <span style="color:#f92672">/</span> kernelSize);
</span></span><span style="display:flex;"><span>FragColor <span style="color:#f92672">=</span> occlusion;  
</span></span></code></pre></div><p>Si nous imaginons une scène où notre modèle de sac à dos préféré fait une petite sieste, le shader d&rsquo;occlusion ambiante produit la texture suivante :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230909-ssao11.png" alt="08_ssao-20230909-ssao11.png"/>
Comme nous pouvons le voir, l&rsquo;occlusion ambiante donne une grande impression de profondeur. Avec la seule texture d&rsquo;occlusion ambiante, nous pouvons déjà voir clairement que le modèle est effectivement posé sur le sol, au lieu de planer légèrement au-dessus.</p>
<p>Le résultat n&rsquo;est pas encore parfait, car le motif répétitif de la texture de bruit est clairement visible. Pour créer un résultat d&rsquo;occlusion ambiante lisse, nous devons flouter la texture d&rsquo;occlusion ambiante.</p>
<h2 id="flou-docclusion-ambiante">Flou d&rsquo;occlusion ambiante<a hidden class="anchor" aria-hidden="true" href="#flou-docclusion-ambiante">#</a></h2>
<p>Entre la passe SSAO et la passe d&rsquo;éclairage, nous voulons d&rsquo;abord flouter la texture SSAO. Créons donc un autre objet framebuffer pour stocker le résultat du flou :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> ssaoBlurFBO, ssaoColorBufferBlur;
</span></span><span style="display:flex;"><span>glGenFramebuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>ssaoBlurFBO);
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, ssaoBlurFBO);
</span></span><span style="display:flex;"><span>glGenTextures(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>ssaoColorBufferBlur);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, ssaoColorBufferBlur);
</span></span><span style="display:flex;"><span>glTexImage2D(GL_TEXTURE_2D, <span style="color:#ae81ff">0</span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span style="color:#ae81ff">0</span>, GL_RED, GL_FLOAT, NULL);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBufferBlur, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>Comme la texture vectorielle aléatoire en mosaïque nous donne un caractère aléatoire cohérent, nous pouvons utiliser cette propriété à notre avantage pour créer un simple shader de flou :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>out <span style="color:#66d9ef">float</span> FragColor;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>in vec2 TexCoords;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>uniform sampler2D ssaoInput;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    vec2 texelSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> vec2(textureSize(ssaoInput, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>; x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>; <span style="color:#f92672">++</span>x) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>; y <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>; <span style="color:#f92672">++</span>y) 
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            vec2 offset <span style="color:#f92672">=</span> vec2(<span style="color:#66d9ef">float</span>(x), <span style="color:#66d9ef">float</span>(y)) <span style="color:#f92672">*</span> texelSize;
</span></span><span style="display:flex;"><span>            result <span style="color:#f92672">+=</span> texture(ssaoInput, TexCoords <span style="color:#f92672">+</span> offset).r;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> result <span style="color:#f92672">/</span> (<span style="color:#ae81ff">4.0</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">4.0</span>);
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>Ici, nous parcourons les texels SSAO environnants entre $-2.0$ et $2.0$, en échantillonnant la texture SSAO d&rsquo;une quantité identique aux dimensions de la texture de bruit. Nous décalons chaque coordonnée de texture de la taille exacte d&rsquo;un seul texel en utilisant <code>textureSize</code> qui renvoie un <code>vec2</code> des dimensions de la texture donnée. Nous faisons la moyenne des résultats obtenus pour obtenir un flou simple mais efficace :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230909-ssao12.png" alt="08_ssao-20230909-ssao12.png"/>
Et voilà, une texture avec des données d&rsquo;occlusion ambiante par fragment, prête à être utilisée dans la passe d&rsquo;éclairage.</p>
<h2 id="application-de-locclusion-ambiante">Application de l&rsquo;occlusion ambiante<a hidden class="anchor" aria-hidden="true" href="#application-de-locclusion-ambiante">#</a></h2>
<p>L&rsquo;application des facteurs d&rsquo;occlusion à l&rsquo;équation d&rsquo;éclairage est incroyablement facile : tout ce que nous avons à faire est de multiplier le facteur d&rsquo;occlusion ambiante par fragment à la composante ambiante de l&rsquo;éclairage et nous avons terminé. Si nous prenons le shader d&rsquo;éclairage différé Blinn-Phong du chapitre précédent et que nous l&rsquo;ajustons un peu, nous obtenons le shader de fragment suivant :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>out vec4 FragColor;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>in vec2 TexCoords;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform sampler2D gPosition;
</span></span><span style="display:flex;"><span>uniform sampler2D gNormal;
</span></span><span style="display:flex;"><span>uniform sampler2D gAlbedo;
</span></span><span style="display:flex;"><span>uniform sampler2D ssao;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Light</span> {
</span></span><span style="display:flex;"><span>    vec3 Position;
</span></span><span style="display:flex;"><span>    vec3 Color;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> Linear;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> Quadratic;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> Radius;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>uniform Light light;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{             
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// retrieve data from gbuffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 FragPos <span style="color:#f92672">=</span> texture(gPosition, TexCoords).rgb;
</span></span><span style="display:flex;"><span>    vec3 Normal <span style="color:#f92672">=</span> texture(gNormal, TexCoords).rgb;
</span></span><span style="display:flex;"><span>    vec3 Diffuse <span style="color:#f92672">=</span> texture(gAlbedo, TexCoords).rgb;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> AmbientOcclusion <span style="color:#f92672">=</span> texture(ssao, TexCoords).r;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// blinn-phong (in view-space)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 ambient <span style="color:#f92672">=</span> vec3(<span style="color:#ae81ff">0.3</span> <span style="color:#f92672">*</span> Diffuse <span style="color:#f92672">*</span> AmbientOcclusion); <span style="color:#75715e">// here we add occlusion factor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 lighting  <span style="color:#f92672">=</span> ambient; 
</span></span><span style="display:flex;"><span>    vec3 viewDir  <span style="color:#f92672">=</span> normalize(<span style="color:#f92672">-</span>FragPos); <span style="color:#75715e">// viewpos is (0.0.0) in view-space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// diffuse
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 lightDir <span style="color:#f92672">=</span> normalize(light.Position <span style="color:#f92672">-</span> FragPos);
</span></span><span style="display:flex;"><span>    vec3 diffuse <span style="color:#f92672">=</span> max(dot(Normal, lightDir), <span style="color:#ae81ff">0.0</span>) <span style="color:#f92672">*</span> Diffuse <span style="color:#f92672">*</span> light.Color;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// specular
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 halfwayDir <span style="color:#f92672">=</span> normalize(lightDir <span style="color:#f92672">+</span> viewDir);  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> spec <span style="color:#f92672">=</span> pow(max(dot(Normal, halfwayDir), <span style="color:#ae81ff">0.0</span>), <span style="color:#ae81ff">8.0</span>);
</span></span><span style="display:flex;"><span>    vec3 specular <span style="color:#f92672">=</span> light.Color <span style="color:#f92672">*</span> spec;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// attenuation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> dist <span style="color:#f92672">=</span> length(light.Position <span style="color:#f92672">-</span> FragPos);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> attenuation <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> (<span style="color:#ae81ff">1.0</span> <span style="color:#f92672">+</span> light.Linear <span style="color:#f92672">*</span> dist <span style="color:#f92672">+</span> light.Quadratic <span style="color:#f92672">*</span> dist <span style="color:#f92672">*</span> dist);
</span></span><span style="display:flex;"><span>    diffuse  <span style="color:#f92672">*=</span> attenuation;
</span></span><span style="display:flex;"><span>    specular <span style="color:#f92672">*=</span> attenuation;
</span></span><span style="display:flex;"><span>    lighting <span style="color:#f92672">+=</span> diffuse <span style="color:#f92672">+</span> specular;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> vec4(lighting, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>La seule chose (à part le changement d&rsquo;espace de vue) que nous avons vraiment changée est la multiplication de la composante ambiante de la scène par <code>AmbientOcclusion</code>. Avec une seule lumière ponctuelle bleutée dans la scène, nous obtiendrions le résultat suivant :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/08_ssao-20230909-ssao12-1.png" alt="08_ssao-20230909-ssao12-1.png"/>
Vous pouvez trouver le code source complet de la scène de démonstration <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/9.ssao/ssao.cpp">ici</a>.</p>
<p>L&rsquo;occlusion ambiante dans l&rsquo;espace-écran est un effet hautement personnalisable qui repose en grande partie sur l&rsquo;ajustement de ses paramètres en fonction du type de scène. Il n&rsquo;existe pas de combinaison parfaite de paramètres pour chaque type de scène. Certaines scènes ne fonctionnent qu&rsquo;avec un petit rayon, tandis que d&rsquo;autres scènes nécessitent un plus grand rayon et un plus grand nombre d&rsquo;échantillons pour être réalistes. La démo actuelle utilise 64 échantillons, ce qui est un peu trop ; essayez d&rsquo;obtenir de bons résultats avec une taille de kernel plus petite.</p>
<p>Certains paramètres peuvent être modifiés (en utilisant des uniformes par exemple) : la taille du kernel, le rayon, le biais et/ou la taille du kernel de bruit. Vous pouvez également augmenter la valeur finale de l&rsquo;occlusion à une puissance définie par l&rsquo;utilisateur afin d&rsquo;accroître sa force :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>occlusion <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">-</span> (occlusion <span style="color:#f92672">/</span> kernelSize);       
</span></span><span style="display:flex;"><span>FragColor <span style="color:#f92672">=</span> pow(occlusion, power);
</span></span></code></pre></div><p>Jouez avec différentes scènes et différents paramètres pour apprécier les possibilités de personnalisation du SSAO.</p>
<p>Même si le SSAO est un effet subtil qui n&rsquo;est pas très visible, il ajoute beaucoup de réalisme aux scènes correctement éclairées et c&rsquo;est sans aucun doute une technique que vous voudrez avoir dans votre boîte à outils.</p>
<h1 id="ressources-supplémentaires">Ressources supplémentaires<a hidden class="anchor" aria-hidden="true" href="#ressources-supplémentaires">#</a></h1>
<ul>
<li><a href="http://john-chapman-graphics.blogspot.nl/2013/01/ssao-tutorial.html">SSAO Tutorial</a> : excellent tutoriel SSAO par John Chapman ; une grande partie du code et des techniques de ce chapitre sont basés sur son article.</li>
<li><a href="https://mtnphil.wordpress.com/2013/06/26/know-your-ssao-artifacts/">Know your SSAO artifacts</a> : excellent article sur l&rsquo;amélioration des artefacts spécifiques au SSAO.</li>
<li><a href="http://ogldev.atspace.co.uk/www/tutorial46/tutorial46.html">SSAO With Depth Reconstruction</a> : tutoriel d&rsquo;extension de SSAO par OGLDev sur la reconstruction des vecteurs de position à partir de la profondeur seule, ce qui nous évite de stocker les vecteurs de position coûteux dans le G-buffer.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
        </main>
<footer class="footer">
    <span>&copy; 2023 <a href="https://hrst4.xyz/">hrst4&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>
</html>