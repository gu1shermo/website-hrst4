<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>hrst4&#39;s blog toml</title>
<meta name="keywords" content="">
<meta name="description" content="Shadow mapping Les ombres résultent de l&rsquo;absence de lumière due à une occlusion. Lorsque les rayons lumineux d&rsquo;une source de lumière n&rsquo;atteignent pas un objet parce qu&rsquo;il est occulté par un autre objet, l&rsquo;objet est dans l&rsquo;ombre. Les ombres ajoutent beaucoup de réalisme à une scène éclairée et permettent au spectateur d&rsquo;observer plus facilement les relations spatiales entre les objets. Elles donnent une plus grande impression de profondeur à la scène et aux objets.">
<meta name="author" content="">
<link rel="canonical" href="https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/02a_shadow_mapping/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://hrst4.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hrst4.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hrst4.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hrst4.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://hrst4.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="Shadow mapping Les ombres résultent de l&rsquo;absence de lumière due à une occlusion. Lorsque les rayons lumineux d&rsquo;une source de lumière n&rsquo;atteignent pas un objet parce qu&rsquo;il est occulté par un autre objet, l&rsquo;objet est dans l&rsquo;ombre. Les ombres ajoutent beaucoup de réalisme à une scène éclairée et permettent au spectateur d&rsquo;observer plus facilement les relations spatiales entre les objets. Elles donnent une plus grande impression de profondeur à la scène et aux objets." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/02a_shadow_mapping/" /><meta property="article:section" content="docs" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Shadow mapping Les ombres résultent de l&rsquo;absence de lumière due à une occlusion. Lorsque les rayons lumineux d&rsquo;une source de lumière n&rsquo;atteignent pas un objet parce qu&rsquo;il est occulté par un autre objet, l&rsquo;objet est dans l&rsquo;ombre. Les ombres ajoutent beaucoup de réalisme à une scène éclairée et permettent au spectateur d&rsquo;observer plus facilement les relations spatiales entre les objets. Elles donnent une plus grande impression de profondeur à la scène et aux objets."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Docs",
      "item": "https://hrst4.xyz/docs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/02a_shadow_mapping/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "Shadow mapping Les ombres résultent de l\u0026rsquo;absence de lumière due à une occlusion. Lorsque les rayons lumineux d\u0026rsquo;une source de lumière n\u0026rsquo;atteignent pas un objet parce qu\u0026rsquo;il est occulté par un autre objet, l\u0026rsquo;objet est dans l\u0026rsquo;ombre. Les ombres ajoutent beaucoup de réalisme à une scène éclairée et permettent au spectateur d\u0026rsquo;observer plus facilement les relations spatiales entre les objets. Elles donnent une plus grande impression de profondeur à la scène et aux objets.",
  "keywords": [
    
  ],
  "articleBody": "Shadow mapping Les ombres résultent de l’absence de lumière due à une occlusion. Lorsque les rayons lumineux d’une source de lumière n’atteignent pas un objet parce qu’il est occulté par un autre objet, l’objet est dans l’ombre. Les ombres ajoutent beaucoup de réalisme à une scène éclairée et permettent au spectateur d’observer plus facilement les relations spatiales entre les objets. Elles donnent une plus grande impression de profondeur à la scène et aux objets. Par exemple, regardez l’image suivante d’une scène avec et sans ombres : Vous pouvez constater qu’avec les ombres, la relation entre les objets devient beaucoup plus évidente. Par exemple, le fait que l’un des cubes flotte au-dessus des autres n’est vraiment perceptible que lorsqu’il y a des ombres.\nLes ombres sont cependant un peu difficiles à mettre en œuvre, notamment parce que la recherche actuelle sur le temps réel (graphiques rastérisés) n’a pas encore mis au point un algorithme d’ombres parfait. Il existe plusieurs bonnes techniques d’approximation des ombres, mais elles ont toutes leurs particularités et leurs inconvénients que nous devons prendre en compte.\nL’une des techniques utilisées par la plupart des jeux vidéo, qui donne des résultats satisfaisants et qui est relativement facile à mettre en œuvre, est le shadow mapping. Le shadow mapping n’est pas trop difficile à comprendre, ne coûte pas trop cher en performance et s’étend facilement à des algorithmes plus avancés (comme les Omnidirectional Shadow Maps et les Cascaded Shadow Maps).\nShadow mapping L’idée derrière le shadow mapping est assez simple : nous rendons la scène du point de vue de la lumière et tout ce que nous voyons du point de vue de la lumière est éclairé et tout ce que nous ne pouvons pas voir doit être dans l’ombre. Imaginez une section de plancher avec une grande caisse entre elle et une source de lumière. Étant donné que la source lumineuse verra cette boîte et non la section du sol lorsqu’elle regardera dans sa direction, cette section spécifique du sol devrait être dans l’ombre. Ici, toutes les lignes bleues représentent les fragments que la source lumineuse peut voir. Les fragments occultés sont représentés par des lignes noires : ils sont rendus comme étant dans l’ombre. Si nous traçons une ligne ou un rayon de la source lumineuse vers un fragment de la boîte la plus à droite, nous pouvons voir que le rayon touche d’abord le conteneur flottant avant de toucher le conteneur le plus à droite. Par conséquent, le fragment du conteneur flottant est éclairé et le fragment du conteneur le plus à droite n’est pas éclairé et se trouve donc dans l’ombre.\nNous voulons déterminer le point du rayon où il a touché un objet pour la première fois et comparer ce point le plus proche à d’autres points du rayon. Nous effectuons ensuite un test de base pour voir si la position du rayon d’un point de test est plus éloignée que le point le plus proche et si c’est le cas, le point de test doit être dans l’ombre. L’itération à travers des milliers de rayons lumineux provenant d’une telle source de lumière est une approche extrêmement inefficace et ne se prête pas très bien au rendu en temps réel. Nous pouvons faire quelque chose de similaire, mais sans lancer de rayons lumineux. À la place, nous utilisons quelque chose que nous connaissons bien : le tampon de profondeur.\nVous vous souvenez peut-être du chapitre sur les tests de profondeur, selon lequel une valeur dans le tampon de profondeur correspond à la profondeur d’un fragment fixé à $[0,1]$ du point de vue de la caméra. Et si nous rendions la scène du point de vue de la lumière et stockions les valeurs de profondeur résultantes dans une texture ? De cette manière, nous pouvons échantillonner les valeurs de profondeur les plus proches du point de vue de la lumière. Après tout, les valeurs de profondeur montrent le premier fragment visible du point de vue de la lumière. Nous stockons toutes ces valeurs de profondeur dans une texture que nous appelons map de profondeur ou shadow map.\nL’image de gauche montre une source lumineuse directionnelle (tous les rayons lumineux sont parallèles) qui projette une ombre sur la surface située sous le cube. En utilisant les valeurs de profondeur stockées dans la map de profondeur, nous trouvons le point le plus proche et l’utilisons pour déterminer si les fragments sont dans l’ombre. Nous créons la map de profondeur en effectuant le rendu de la scène (du point de vue de la lumière) à l’aide d’une vue et d’une matrice de projection spécifiques à cette source lumineuse. Cette projection et cette matrice de vue forment ensemble une transformation $T$ qui transforme toute position 3D en espace de coordonnées de la lumière (visible).\nUne lumière directionnelle n’a pas de position puisqu’elle est modélisée pour être infiniment éloignée. Cependant, pour les besoins de la cartographie des ombres, nous devons rendre la scène du point de vue d’une lumière et donc rendre la scène à partir d’une position située quelque part dans la direction de la lumière.\nDans l’image de droite, nous voyons la même lumière directionnelle et le spectateur. Nous rendons un fragment au point $P$ pour lequel nous devons déterminer s’il est dans l’ombre. Pour ce faire, nous transformons d’abord le point $P$ dans l’espace de coordonnées de la lumière à l’aide de $T$. Étant donné que le point $P$ est maintenant vu du point de vue de la lumière, sa coordonnée $z$ correspond à sa profondeur qui, dans cet exemple, est de $0.9$. En utilisant le point $P$, nous pouvons également indexer la map des profondeurs/ombres pour obtenir la profondeur visible la plus proche du point de vue de la lumière, qui se trouve au point $C$ avec une profondeur échantillonnée de $0.4$. Étant donné que l’indexation de la carte de profondeur renvoie une profondeur inférieure à celle du point $P$, nous pouvons conclure que le point $P$ est occulté et donc dans l’ombre.\nLa cartographie des ombres consiste donc en deux passages : dans un premier temps, nous effectuons le rendu de la map de profondeur et, dans un second temps, nous effectuons le rendu normal de la scène et utilisons la map de profondeur générée pour calculer si des fragments sont dans l’ombre. Cela peut sembler un peu compliqué, mais dès que nous aurons expliqué la technique étape par étape, elle commencera à prendre tout son sens.\nLa map de profondeur La première étape consiste à générer une map de profondeur. La map de profondeur est la texture de profondeur telle qu’elle est rendue du point de vue de la lumière que nous utiliserons pour tester les ombres. Comme nous devons stocker le résultat du rendu d’une scène dans une texture, nous allons à nouveau avoir besoin de framebuffers.\nTout d’abord, nous allons créer un objet framebuffer pour le rendu de la carte de profondeur :\nunsigned int depthMapFBO; glGenFramebuffers(1, \u0026depthMapFBO); Ensuite, nous créons une texture 2D que nous utiliserons comme tampon de profondeur du framebuffer :\nconst unsigned int SHADOW_WIDTH = 1024, SHADOW_HEIGHT = 1024; unsigned int depthMap; glGenTextures(1, \u0026depthMap); glBindTexture(GL_TEXTURE_2D, depthMap); glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, SHADOW_WIDTH, SHADOW_HEIGHT, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); La génération de la map de profondeur ne devrait pas être trop compliquée. Comme nous ne nous intéressons qu’aux valeurs de profondeur, nous spécifions que le format de la texture est GL_DEPTH_COMPONENT. Nous donnons également à la texture une largeur et une hauteur de 1024 : c’est la résolution de la map de profondeur.\nAvec la texture de profondeur générée, nous pouvons l’attacher au tampon de profondeur du framebuffer :\nglBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, 0); glDrawBuffer(GL_NONE); glReadBuffer(GL_NONE); glBindFramebuffer(GL_FRAMEBUFFER, 0); Nous n’avons besoin des informations de profondeur que lors du rendu de la scène du point de vue de la lumière, il n’est donc pas nécessaire d’avoir un tampon de couleur. Un objet framebuffer n’est cependant pas complet sans un tampon de couleur, nous devons donc explicitement dire à OpenGL que nous n’allons pas rendre de données de couleur. Nous le faisons en réglant les tampons de lecture et de dessin sur GL_NONE avec glDrawBuffer et glReadbuffer.\nAvec un framebuffer correctement configuré qui rend les valeurs de profondeur vers une texture, nous pouvons commencer la première passe : générer la carte de profondeur. Combinée à la deuxième passe, l’étape de rendu complète ressemblera à ceci :\n// 1. first render to depth map glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT); glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO); glClear(GL_DEPTH_BUFFER_BIT); ConfigureShaderAndMatrices(); RenderScene(); glBindFramebuffer(GL_FRAMEBUFFER, 0); // 2. then render scene as normal with shadow mapping (using depth map) glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); ConfigureShaderAndMatrices(); glBindTexture(GL_TEXTURE_2D, depthMap); RenderScene(); Ce code a omis quelques détails, mais il vous donnera l’idée générale du shadow mapping. Ce qu’il est important de noter ici, ce sont les appels à glViewport. Comme les cartes d’ombres ont souvent une résolution différente de celle avec laquelle nous avons rendu la scène à l’origine (généralement la résolution de la fenêtre), nous devons modifier les paramètres de la fenêtre pour tenir compte de la taille de la map d’ombres. Si nous oublions de mettre à jour les paramètres de la fenêtre, la carte de profondeur résultante sera soit incomplète, soit trop petite.\nLight space transform La fonction ConfigureShaderAndMatrices est inconnue dans l’extrait de code précédent. Dans la deuxième passe, c’est la routine : s’assurer que les matrices de projection et de vue appropriées sont définies, et définir les matrices de modèle pertinentes par objet. Cependant, dans la première passe, nous devons utiliser une projection et une matrice de vue différentes pour rendre la scène du point de vue de la lumière.\nComme nous modélisons une source de lumière directionnelle, tous ses rayons lumineux sont parallèles. Pour cette raison, nous allons utiliser une matrice de projection orthographique pour la source lumineuse où il n’y a pas de déformation de la perspective :\nfloat near_plane = 1.0f, far_plane = 7.5f; glm::mat4 lightProjection = glm::ortho(-10.0f, 10.0f, -10.0f, 10.0f, near_plane, far_plane); Voici un exemple de matrice de projection orthographique utilisée dans la scène de démonstration de ce chapitre. Étant donné qu’une matrice de projection détermine indirectement l’étendue de ce qui est visible (c’est-à-dire ce qui n’est pas coupé), vous devez vous assurer que la taille du frustum de projection contient correctement les objets que vous souhaitez voir figurer dans la map de profondeur. Lorsque des objets ou des fragments ne figurent pas dans la map de profondeur, ils ne produisent pas d’ombres.\nPour créer une matrice de vue afin de transformer chaque objet pour qu’il soit visible du point de vue de la lumière, nous allons utiliser la fameuse fonction glm::lookAt ; cette fois-ci avec la position de la source de lumière regardant le centre de la scène.\nglm::mat4 lightView = glm::lookAt(glm::vec3(-2.0f, 4.0f, -1.0f), glm::vec3( 0.0f, 0.0f, 0.0f), glm::vec3( 0.0f, 1.0f, 0.0f)); En combinant ces deux éléments, nous obtenons une matrice de transformation de l’espace lumineux qui transforme chaque vecteur de l’espace mondial en l’espace visible depuis la source lumineuse ; c’est exactement ce dont nous avons besoin pour calculer la map de profondeur.\nglm::mat4 lightSpaceMatrix = lightProjection * lightView; Cette matrice espace-lumière est la matrice de transformation que nous avons précédemment désignée par $T$. Avec cette matrice espace-lumière, nous pouvons effectuer le rendu de la scène comme d’habitude tant que nous donnons à chaque shader les équivalents espace-lumière des matrices de projection et de vue. Cependant, nous ne nous intéressons qu’aux valeurs de profondeur et non à tous les calculs coûteux des fragments (éclairage). Pour gagner en performance, nous allons utiliser un shader différent, mais beaucoup plus simple, pour le rendu de la map de profondeur.\nRendu de la depth map Lorsque nous rendons la scène du point de vue de la lumière, nous préférons utiliser un shader simple qui ne transforme que les sommets dans l’espace lumière et pas grand-chose de plus. Pour un tel shader simple appelé simpleDepthShader, nous utiliserons le vertex shader suivant :\n#version 330 core layout (location = 0) in vec3 aPos; uniform mat4 lightSpaceMatrix; uniform mat4 model; void main() { gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0); } Ce shader de vertex prend un modèle par objet, un vertex, et transforme tous les vertex dans l’espace lumière en utilisant lightSpaceMatrix.\nComme nous n’avons pas de tampon de couleur et que nous avons désactivé les tampons de dessin et de lecture, les fragments résultants ne nécessitent aucun traitement et nous pouvons donc simplement utiliser un shader de fragment vide:\n#version 330 core void main() { // gl_FragDepth = gl_FragCoord.z; } Ce fragment shader vide ne fait aucun traitement, et à la fin de son exécution, le tampon de profondeur est mis à jour. Nous pourrions explicitement définir la profondeur en décommentant sa seule ligne, mais c’est en fait ce qui se passe en coulisses de toute façon.\nsimpleDepthShader.use(); glUniformMatrix4fv(lightSpaceMatrixLocation, 1, GL_FALSE, glm::value_ptr(lightSpaceMatrix)); glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT); glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO); glClear(GL_DEPTH_BUFFER_BIT); RenderScene(simpleDepthShader); glBindFramebuffer(GL_FRAMEBUFFER, 0); Ici, la fonction RenderScene prend un programme de shader, appelle toutes les fonctions de dessin pertinentes et définit les matrices de modèle correspondantes si nécessaire.\nLe résultat est un tampon de profondeur joliment rempli qui contient la profondeur la plus proche de chaque fragment visible du point de vue de la lumière. En rendant cette texture sur un quad 2D qui remplit l’écran (similaire à ce que nous avons fait dans la section de post-traitement à la fin du chapitre sur les framebuffers), nous obtenons quelque chose comme ceci : Pour le rendu de la map de profondeur sur un quad, nous avons utilisé le fragment shader suivant :\n#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D depthMap; void main() { float depthValue = texture(depthMap, TexCoords).r; FragColor = vec4(vec3(depthValue), 1.0); } Notez qu’il y a quelques changements subtils lorsque l’on affiche la profondeur en utilisant une matrice de projection en perspective plutôt qu’une matrice de projection orthographique, car la profondeur n’est pas linéaire lorsque l’on utilise la projection en perspective. À la fin de ce chapitre, nous aborderons certaines de ces différences subtiles.\nVous pouvez trouver le code source pour le rendu d’une scène vers une carte de profondeur ici.\nRendu des ombres Avec une map de profondeur correctement générée, nous pouvons commencer à rendre les ombres réelles. Le code permettant de vérifier si un fragment est dans l’ombre est (bien évidemment) exécuté dans le fragment shader, mais nous effectuons la transformation de l’espace-lumière dans le vertex shader :\n#version 330 core layout (location = 0) in vec3 aPos; layout (location = 1) in vec3 aNormal; layout (location = 2) in vec2 aTexCoords; out VS_OUT { vec3 FragPos; vec3 Normal; vec2 TexCoords; vec4 FragPosLightSpace; } vs_out; uniform mat4 projection; uniform mat4 view; uniform mat4 model; uniform mat4 lightSpaceMatrix; void main() { vs_out.FragPos = vec3(model * vec4(aPos, 1.0)); vs_out.Normal = transpose(inverse(mat3(model))) * aNormal; vs_out.TexCoords = aTexCoords; vs_out.FragPosLightSpace = lightSpaceMatrix * vec4(vs_out.FragPos, 1.0); gl_Position = projection * view * vec4(vs_out.FragPos, 1.0); } Ce qui est nouveau ici, c’est le vecteur de sortie supplémentaire FragPosLightSpace. Nous prenons la même matrice lightSpaceMatrix (utilisée pour transformer les sommets en espace lumière dans l’étape de la map de profondeur) et transformons la position des sommets dans l’espace monde en espace lumière pour l’utiliser dans le shader de fragments.\nLe shader de fragments principal que nous utiliserons pour le rendu de la scène utilise le modèle d’éclairage Blinn-Phong. Dans le shader de fragment, nous calculons ensuite une valeur d’ombre qui est soit de $1.0$ lorsque le fragment est dans l’ombre, soit de $0.0$ lorsqu’il n’est pas dans l’ombre. Les composantes diffuse et spéculaire résultantes sont ensuite multipliées par cette composante d’ombre. Les ombres étant rarement complètement sombres (en raison de la diffusion de la lumière), nous ne tenons pas compte de la composante ambiante dans les multiplications de l’ombre.\n#version 330 core out vec4 FragColor; in VS_OUT { vec3 FragPos; vec3 Normal; vec2 TexCoords; vec4 FragPosLightSpace; } fs_in; uniform sampler2D diffuseTexture; uniform sampler2D shadowMap; uniform vec3 lightPos; uniform vec3 viewPos; float ShadowCalculation(vec4 fragPosLightSpace) { [...] } void main() { vec3 color = texture(diffuseTexture, fs_in.TexCoords).rgb; vec3 normal = normalize(fs_in.Normal); vec3 lightColor = vec3(1.0); // ambient vec3 ambient = 0.15 * lightColor; // diffuse vec3 lightDir = normalize(lightPos - fs_in.FragPos); float diff = max(dot(lightDir, normal), 0.0); vec3 diffuse = diff * lightColor; // specular vec3 viewDir = normalize(viewPos - fs_in.FragPos); float spec = 0.0; vec3 halfwayDir = normalize(lightDir + viewDir); spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0); vec3 specular = spec * lightColor; // calculate shadow float shadow = ShadowCalculation(fs_in.FragPosLightSpace); vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color; FragColor = vec4(lighting, 1.0); } Le fragment shader est en grande partie une copie de ce que nous avons utilisé dans le chapitre sur l’éclairage avancé, mais avec un calcul d’ombre supplémentaire. Nous avons déclaré une fonction ShadowCalculation qui effectue la majeure partie du travail sur les ombres. À la fin du fragment shader, nous multiplions les contributions diffuses et spéculaires par l’inverse de la composante d’ombre, c’est-à-dire la proportion du fragment qui n’est pas dans l’ombre. Ce shader de fragment prend comme entrée supplémentaire la position du fragment dans l’espace-lumière et la map de profondeur générée lors de la première passe de rendu.\nLa première chose à faire pour vérifier si un fragment est dans l’ombre est de transformer la position du fragment dans l’espace-lumière dans l’espace-clip en coordonnées normalisées de l’appareil (device). Lorsque nous transmettons une position de vertex dans l’espace-clip à gl_Position dans le vertex shader, OpenGL effectue automatiquement une division en perspective, par exemple en transformant les coordonnées de l’espace-clip dans l’intervalle $[-w,w]$ à $[-1,1]$ en divisant les composantes $x, y$ et $z$ par la composante $w$ du vecteur. Comme le clip-space FragPosLightSpace n’est pas transmis au fragment shader par l’intermédiaire de gl_Position, nous devons effectuer cette division de perspective nous-mêmes :\nfloat ShadowCalculation(vec4 fragPosLightSpace) { // perform perspective divide vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w; [...] } Elle renvoie la position du fragment dans l’espace lumineux dans l’intervalle $[-1,1]$.\nLors de l’utilisation d’une matrice de projection orthographique, la composante w d’un sommet n’est pas modifiée et cette étape n’a donc aucun sens. Cependant, elle est nécessaire lors de l’utilisation d’une projection en perspective et le fait de conserver cette ligne permet de s’assurer qu’elle fonctionne avec les deux matrices de projection.\nÉtant donné que la profondeur de la map de profondeur est comprise dans l’intervalle $[0,1]$ et que nous voulons également utiliser projCoords pour échantillonner à partir de la map de profondeur, nous transformons les coordonnées NDC dans l’intervalle $[0,1]$ :\nprojCoords = projCoords * 0.5 + 0.5; Ces coordonnées projetées nous permettent d’échantillonner la map de profondeur, car les coordonnées $[0,1]$ résultant de projCoords correspondent directement aux coordonnées NDC transformées lors de la première passe de rendu. Cela nous donne la profondeur la plus proche du point de vue de la lumière :\nfloat closestDepth = texture(shadowMap, projCoords.xy).r; Pour obtenir la profondeur actuelle de ce fragment, il suffit de récupérer la coordonnée $z$ du vecteur projeté, qui est égale à la profondeur de ce fragment du point de vue de la lumière.\nfloat currentDepth = projCoords.z; La comparaison proprement dite consiste alors simplement à vérifier si currentDepth est supérieur à closestDepth et si c’est le cas, le fragment est dans l’ombre :\nfloat shadow = currentDepth \u003e closestDepth ? 1.0 : 0.0; La fonction complète de calcul des ombres devient alors :\nfloat ShadowCalculation(vec4 fragPosLightSpace) { // perform perspective divide vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w; // transform to [0,1] range projCoords = projCoords * 0.5 + 0.5; // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords) float closestDepth = texture(shadowMap, projCoords.xy).r; // get depth of current fragment from light's perspective float currentDepth = projCoords.z; // check whether current frag pos is in shadow float shadow = currentDepth \u003e closestDepth ? 1.0 : 0.0; return shadow; } L’activation de ce shader, la liaison des textures appropriées et l’activation des matrices de projection et de vue par défaut lors de la deuxième passe de rendu devraient donner un résultat similaire à l’image ci-dessous : Si vous avez bien fait les choses, vous devriez en effet voir (bien qu’avec quelques artefacts) des ombres sur le sol et les cubes. Vous pouvez trouver le code source de l’application de démonstration ici.\nAméliorer les shadow maps Nous avons réussi à faire fonctionner les bases du shadow mapping, mais comme vous pouvez le constater, nous ne sommes pas encore au bout de nos peines à cause de plusieurs artefacts (clairement visibles) liés au shadow mapping que nous devons corriger. Nous nous concentrerons sur la correction de ces artefacts dans les prochaines sections.\nShadow acne L’image précédente montre clairement que quelque chose ne va pas. Un zoom plus rapproché montre un motif Moiré très évident : Nous pouvons voir qu’une grande partie de la surface du sol est rendue avec des lignes noires évidentes en alternance. Cet artefact de mappage des ombres est appelé acné des ombres et peut être expliqué par l’image suivante : Comme la map des ombres est limitée par la résolution, plusieurs fragments peuvent échantillonner la même valeur de la map de profondeur lorsqu’ils sont relativement éloignés de la source lumineuse. L’image montre le sol où chaque panneau jaune incliné représente un seul texel de la map de profondeur. Comme vous pouvez le voir, plusieurs fragments échantillonnent le même échantillon de profondeur.\nBien que cela soit généralement acceptable, cela devient un problème lorsque la source lumineuse regarde la surface sous un angle, car dans ce cas, la map de profondeur est également rendue sous un angle. Plusieurs fragments accèdent alors au même texel de profondeur incliné alors que certains sont au-dessus et d’autres au-dessous du sol ; nous obtenons une divergence d’ombre. De ce fait, certains fragments sont considérés comme étant dans l’ombre et d’autres non, ce qui donne le motif rayé de l’image.\nNous pouvons résoudre ce problème à l’aide d’une petite astuce appelée “biais d’ombre” (shadow bias), qui consiste simplement à décaler la profondeur de la surface (ou de la map d’ombre) d’une petite quantité de biais, de sorte que les fragments ne soient pas considérés à tort comme étant au-dessus de la surface. Avec le biais appliqué, tous les échantillons ont une profondeur inférieure à la profondeur de la surface et la surface entière est donc correctement éclairée sans aucune ombre. Nous pouvons mettre en œuvre un tel biais de la manière suivante :\nfloat bias = 0.005; float shadow = currentDepth - bias \u003e closestDepth ? 1.0 : 0.0; Un biais d’ombre de $0.005$ résout en grande partie les problèmes de notre scène, mais vous pouvez imaginer que la valeur du biais dépend fortement de l’angle entre la source lumineuse et la surface. Si la surface est très inclinée par rapport à la source lumineuse, les ombres peuvent encore présenter une acné. Une approche plus solide consisterait à modifier la valeur du biais en fonction de l’angle de la surface par rapport à la lumière : un problème que nous pouvons résoudre avec le produit scalaire :\nfloat bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005); Nous avons ici un biais maximum de $0.05$ et un minimum de $0.005$ en fonction de la normale de la surface et de la direction de la lumière. Ainsi, les surfaces comme le sol qui sont presque perpendiculaires à la source lumineuse ont un petit biais, tandis que les surfaces comme les faces latérales du cube ont un biais beaucoup plus important. L’image suivante montre la même scène, mais avec un biais pour les ombres : Le choix de la (des) valeur(s) de biais correcte(s) nécessite quelques ajustements car elle(s) sera(ont) différente(s) pour chaque scène, mais la plupart du temps, il s’agit simplement d’incrémenter lentement le biais jusqu’à ce que toute l’acné soit supprimée.\n### Peter panning L’inconvénient de l’utilisation d’un biais d’ombre est que vous appliquez un décalage à la profondeur réelle des objets. Par conséquent, le biais peut devenir suffisamment important pour que les ombres soient visiblement décalées par rapport à l’emplacement réel des objets, comme vous pouvez le voir ci-dessous (avec une valeur de biais exagérée) : Cet artefact d’ombre est appelé “peter panning”, car les objets semblent légèrement détachés de leurs ombres. Nous pouvons utiliser une petite astuce pour résoudre la plupart des problèmes de peter panning en utilisant l’élimination des faces avant lors du rendu de la carte de profondeur. Vous vous souvenez peut-être du chapitre sur l’élimination des faces qu’OpenGL élimine par défaut les faces arrière. En indiquant à OpenGL que nous voulons éliminer les faces avant pendant l’étape de la map des ombres, nous inversons cet ordre.\nComme nous n’avons besoin que des valeurs de profondeur pour la map de profondeur, cela ne devrait pas avoir d’importance pour les objets solides que nous prenions la profondeur de leurs faces avant ou de leurs faces arrière. L’utilisation de la profondeur de la face arrière ne donne pas de mauvais résultats car l’existence d’ombres à l’intérieur des objets n’a pas d’importance ; de toute façon, nous ne pouvons pas voir à l’intérieur des objets. Pour corriger le peter panning, nous éliminons toutes les faces avant lors de la génération de la map d’ombres. Notez que vous devez d’abord activer GL_CULL_FACE.\nglCullFace(GL_FRONT); RenderSceneToDepthMap(); glCullFace(GL_BACK); // don't forget to reset original culling face Cela résout effectivement les problèmes de peter panning, mais seulement pour les objets solides qui ont réellement un intérieur sans ouvertures. Dans notre scène, par exemple, cela fonctionne parfaitement pour les cubes. Cependant, sur le sol, cela ne fonctionnera pas aussi bien car l’élimination de la face avant supprime complètement le sol de l’équation. Le sol est un plan unique et serait donc complètement éliminé. Si l’on veut résoudre le problème du peter panning à l’aide de cette astuce, il faut veiller à n’éliminer que les faces avant des objets pour lesquels cela a un sens.\nIl faut également tenir compte du fait que les objets proches du récepteur d’ombre (comme le cube éloigné) peuvent encore donner des résultats incorrects. Cependant, avec des valeurs de biais normales, il est généralement possible d’éviter le “peter panning”.\nOver sampling Une autre anomalie visuelle que vous pouvez apprécier ou non est que les régions situées en dehors du frustum visible de la lumière sont considérées comme étant dans l’ombre alors qu’elles ne le sont (généralement) pas. Cela est dû au fait que les coordonnées projetées en dehors du frustum de la lumière sont supérieures à $1.0$ et échantillonneront donc la texture de profondeur en dehors de sa plage par défaut de $[0.1]$. En se basant sur la méthode de wrapping de la texture, nous obtiendrons des résultats de profondeur incorrects qui ne sont pas basés sur les valeurs de profondeur réelles de la source lumineuse. Vous pouvez voir dans l’image qu’il y a une sorte de région imaginaire de lumière, et qu’une grande partie en dehors de cette zone est dans l’ombre ; cette zone représente la taille de la map de profondeur projetée sur le sol. Cette zone représente la taille de la map de profondeur projetée sur le sol. La raison pour laquelle cela se produit est que nous avons précédemment défini les options de wrapping de la map de profondeur sur GL_REPEAT.\nCe que nous préférons, c’est que toutes les coordonnées situées en dehors de la plage de la map de profondeur aient une profondeur de $1.0$, ce qui signifie que ces coordonnées ne seront jamais dans l’ombre (car aucun objet n’aura une profondeur supérieure à $1.0$). Nous pouvons le faire en configurant une couleur de bordure de texture et en réglant les options de wrapping de texture de la map de profondeur sur GL_CLAMP_TO_BORDER :\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER); float borderColor[] = { 1.0f, 1.0f, 1.0f, 1.0f }; glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor); Désormais, chaque fois que nous échantillonnons en dehors de la plage de coordonnées $[0,1]$ de la map de profondeur, la fonction de texture renvoie toujours une profondeur de $1.0$, ce qui produit une valeur d’ombre de $0.0$ Le résultat est désormais plus plausible : Il semble qu’il y ait encore une partie présentant une région sombre. Il s’agit des coordonnées situées à l’extérieur du plan éloigné du frustum orthographique de la lumière. Vous pouvez constater que cette région sombre se trouve toujours à l’extrémité du frustum de la source lumineuse en observant les directions des ombres.\nLa coordonnée d’un fragment projeté dans l’espace lumineux est plus éloignée que le plan éloigné de la lumière lorsque sa coordonnée $z$ est supérieure à $1.0$. Dans ce cas, la méthode de wrapping GL_CLAMP_TO_BORDER ne fonctionne plus car nous comparons la composante $z$ de la coordonnée avec les valeurs de la map de profondeur ; cette méthode renvoie toujours un résultat positif pour les valeurs $z$ supérieures à $1.0$.\nLa solution à ce problème est relativement simple : il suffit de forcer la valeur de l’ombre à $0.0$ chaque fois que la coordonnée $z$ du vecteur projeté est supérieure à $1.0$ :\nfloat ShadowCalculation(vec4 fragPosLightSpace) { [...] if(projCoords.z \u003e 1.0) shadow = 0.0; return shadow; } Le fait de vérifier le plan éloigné et de limiter la map de profondeur à une couleur de bordure spécifiée manuellement résout le problème du suréchantillonnage de la map de profondeur. Cela nous permet enfin d’obtenir le résultat que nous recherchons : Le résultat de tout ceci signifie que nous n’avons des ombres que là où les coordonnées du fragment projeté se trouvent dans la zone de la map de profondeur, donc tout ce qui se trouve en dehors du frustum de lumière n’aura pas d’ombres visibles. Comme les jeux vidéo font généralement en sorte que cela ne se produise qu’au loin, c’est un effet beaucoup plus plausible que les régions noires évidentes que nous avions auparavant.\nPCF Les ombres actuelles sont un ajout agréable au paysage, mais ce n’est pas encore exactement ce que nous voulons. Si l’on zoome sur les ombres, la dépendance de la résolution du mapping des ombres devient rapidement évidente. Comme la map de profondeur a une résolution fixe, la profondeur s’étend souvent sur plus d’un fragment par texel. Par conséquent, plusieurs fragments échantillonnent la même valeur de profondeur à partir de la map de profondeur et parviennent aux mêmes conclusions d’ombre, ce qui produit ces bords irréguliers.\nVous pouvez réduire ces ombres en bloc en augmentant la résolution de la carte de profondeur ou en essayant d’ajuster le cône de lumière le plus près possible de la scène.\nUne autre solution (partielle) à ces bords irréguliers est appelée PCF (percentage-closer filtering), un terme qui englobe de nombreuses fonctions de filtrage différentes qui produisent des ombres plus douces, en les faisant paraître moins bloquées ou dures. L’idée est d’échantillonner plusieurs fois la map de profondeur, chaque fois avec des coordonnées de texture légèrement différentes. Pour chaque échantillon individuel, nous vérifions s’il est dans l’ombre ou non. Tous les sous-résultats sont ensuite combinés et moyennés, ce qui permet d’obtenir une ombre douce et agréable à regarder.\nUne implémentation simple du PCF consiste simplement à échantillonner les texels environnants de la map de profondeur et à faire la moyenne des résultats :\nfloat shadow = 0.0; vec2 texelSize = 1.0 / textureSize(shadowMap, 0); for(int x = -1; x \u003c= 1; ++x) { for(int y = -1; y \u003c= 1; ++y) { float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r; shadow += currentDepth - bias \u003e pcfDepth ? 1.0 : 0.0; } } shadow /= 9.0; Ici, textureSize renvoie un vec2 de la largeur et de la hauteur de la texture du sampler donnée au niveau 0 de la mipmap. 1 divisé par ce vec2 renvoie la taille d’un texel unique que nous utilisons pour décaler les coordonnées de la texture, en nous assurant que chaque nouvel échantillon échantillonne une valeur de profondeur différente. Ici, nous échantillonnons 9 valeurs autour des valeurs $x$ et $y$ de la coordonnée projetée, nous testons l’occlusion des ombres et enfin nous faisons la moyenne des résultats en fonction du nombre total d’échantillons prélevés.\nEn utilisant plus d’échantillons et/ou en variant la variable texelSize, vous pouvez augmenter la qualité des ombres douces. Ci-dessous, vous pouvez voir les ombres avec un simple PCF appliqué : De loin, les ombres sont beaucoup plus belles et moins dures. Si vous zoomez, vous pouvez toujours voir les artefacts de résolution du shadow mapping, mais en général cela donne de bons résultats pour la plupart des applications.\nVous pouvez trouver le code source complet de l’exemple ici.\nIl y a en fait beaucoup plus à faire avec le PCF et pas mal de techniques pour améliorer considérablement la qualité des ombres douces, mais pour des raisons de longueur de ce chapitre, nous laisserons cela pour une discussion ultérieure.\nOrthographique vs Perspective Il existe une différence entre le rendu de la map de profondeur avec une matrice de projection orthographique ou perspective. Une matrice de projection orthographique ne déforme pas la scène avec la perspective, de sorte que tous les rayons de vue/lumière sont parallèles. Cela en fait une excellente matrice de projection pour les lumières directionnelles. En revanche, une matrice de projection en perspective déforme tous les sommets en fonction de la perspective, ce qui donne des résultats différents. L’image suivante montre les différentes zones d’ombre des deux méthodes de projection : Les projections en perspective sont plus utiles pour les sources lumineuses qui ont un emplacement réel, contrairement aux lumières directionnelles. Les projections en perspective sont le plus souvent utilisées avec les projecteurs et les lumières ponctuelles, tandis que les projections orthographiques sont utilisées pour les lumières directionnelles.\nUne autre différence subtile avec l’utilisation d’une matrice de projection en perspective est que la visualisation du tampon de profondeur donne souvent un résultat presque entièrement blanc. Cela s’explique par le fait qu’avec la projection en perspective, la profondeur est transformée en valeurs de profondeur non linéaires dont la majeure partie de la plage visible se situe près du plan proche. Pour pouvoir visualiser correctement les valeurs de profondeur comme nous l’avons fait avec la projection orthographique, vous devez d’abord transformer les valeurs de profondeur non linéaires en valeurs linéaires, comme nous l’avons expliqué dans le chapitre sur les tests de profondeur:\n#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D depthMap; uniform float near_plane; uniform float far_plane; float LinearizeDepth(float depth) { float z = depth * 2.0 - 1.0; // Back to NDC return (2.0 * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane)); } void main() { float depthValue = texture(depthMap, TexCoords).r; FragColor = vec4(vec3(LinearizeDepth(depthValue) / far_plane), 1.0); // perspective // FragColor = vec4(vec3(depthValue), 1.0); // orthographic } Cela montre des valeurs de profondeur similaires à ce que nous avons vu avec la projection orthographique. Notez que cela n’est utile que pour le débogage ; les vérifications de profondeur restent les mêmes avec les matrices orthographiques ou de projection, car les profondeurs relatives ne changent pas.\nRessources additionnelles Tutoriel 16 : Shadow mapping : tutoriel similaire sur le shadow mapping par opengl-tutorial.org avec quelques notes supplémentaires. Shadow Mapping - Part 1 : un autre tutoriel de shadow mapping par ogldev. How Shadow Mapping Works : un tutoriel YouTube en 3 parties par TheBennyBox sur le shadow mapping et son implémentation. Common Techniques to Improve Shadow Depth Maps : un excellent article de Microsoft énumérant un grand nombre de techniques permettant d’améliorer la qualité des maps d’ombres. How I Implemented Shadows in my Game Engine : excellente vidéo de ThinMatrix sur ses méthodes d’amélioration des maps d’ombres. ",
  "wordCount" : "5922",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hrst4.xyz/docs/learnopengl_fr/05_advanced_lighting/02a_shadow_mapping/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "hrst4's blog toml",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hrst4.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hrst4.xyz/" accesskey="h" title="hrst4&#39;s blog toml (Alt + H)">hrst4&#39;s blog toml</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="shadow-mapping">Shadow mapping<a hidden class="anchor" aria-hidden="true" href="#shadow-mapping">#</a></h1>
<p>Les ombres résultent de l&rsquo;absence de lumière due à une occlusion. Lorsque les rayons lumineux d&rsquo;une source de lumière n&rsquo;atteignent pas un objet parce qu&rsquo;il est occulté par un autre objet, l&rsquo;objet est dans l&rsquo;ombre. Les ombres ajoutent beaucoup de réalisme à une scène éclairée et permettent au spectateur d&rsquo;observer plus facilement les relations spatiales entre les objets. Elles donnent une plus grande impression de profondeur à la scène et aux objets. Par exemple, regardez l&rsquo;image suivante d&rsquo;une scène avec et sans ombres :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_with_without.png" alt="shadow_mapping_with_without"/></p>
<p>Vous pouvez constater qu&rsquo;avec les ombres, la relation entre les objets devient beaucoup plus évidente. Par exemple, le fait que l&rsquo;un des cubes flotte au-dessus des autres n&rsquo;est vraiment perceptible que lorsqu&rsquo;il y a des ombres.</p>
<p>Les ombres sont cependant un peu difficiles à mettre en œuvre, notamment parce que la recherche actuelle sur le temps réel (graphiques rastérisés) n&rsquo;a pas encore mis au point un algorithme d&rsquo;ombres parfait. Il existe plusieurs bonnes techniques d&rsquo;approximation des ombres, mais elles ont toutes leurs particularités et leurs inconvénients que nous devons prendre en compte.</p>
<p>L&rsquo;une des techniques utilisées par la plupart des jeux vidéo, qui donne des résultats satisfaisants et qui est relativement facile à mettre en œuvre, est le <strong>shadow mapping</strong>. Le shadow mapping n&rsquo;est pas trop difficile à comprendre, ne coûte pas trop cher en performance et s&rsquo;étend facilement à des algorithmes plus avancés (comme les <strong>Omnidirectional Shadow Maps</strong> et les <strong>Cascaded Shadow Maps</strong>).</p>
<h2 id="shadow-mapping-1">Shadow mapping<a hidden class="anchor" aria-hidden="true" href="#shadow-mapping-1">#</a></h2>
<p>L&rsquo;idée derrière le shadow mapping est assez simple : nous rendons la scène du point de vue de la lumière et tout ce que nous voyons du point de vue de la lumière est éclairé et tout ce que nous ne pouvons pas voir doit être dans l&rsquo;ombre. Imaginez une section de plancher avec une grande caisse entre elle et une source de lumière. Étant donné que la source lumineuse verra cette boîte et non la section du sol lorsqu&rsquo;elle regardera dans sa direction, cette section spécifique du sol devrait être dans l&rsquo;ombre.
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_theory.png" alt="shadow_mapping_theory"/></p>
<p>Ici, toutes les lignes bleues représentent les fragments que la source lumineuse peut voir. Les fragments occultés sont représentés par des lignes noires : ils sont rendus comme étant dans l&rsquo;ombre. Si nous traçons une ligne ou un rayon de la source lumineuse vers un fragment de la boîte la plus à droite, nous pouvons voir que le rayon touche d&rsquo;abord le conteneur flottant avant de toucher le conteneur le plus à droite. Par conséquent, le fragment du conteneur flottant est éclairé et le fragment du conteneur le plus à droite n&rsquo;est pas éclairé et se trouve donc dans l&rsquo;ombre.</p>
<p>Nous voulons déterminer le point du rayon où il a touché un objet pour la première fois et comparer ce point le plus proche à d&rsquo;autres points du rayon. Nous effectuons ensuite un test de base pour voir si la position du rayon d&rsquo;un point de test est plus éloignée que le point le plus proche et si c&rsquo;est le cas, le point de test doit être dans l&rsquo;ombre. L&rsquo;itération à travers des milliers de rayons lumineux provenant d&rsquo;une telle source de lumière est une approche extrêmement inefficace et ne se prête pas très bien au rendu en temps réel. Nous pouvons faire quelque chose de similaire, mais sans lancer de rayons lumineux. À la place, nous utilisons quelque chose que nous connaissons bien : le tampon de profondeur.</p>
<p>Vous vous souvenez peut-être du chapitre sur les tests de profondeur, selon lequel une valeur dans le tampon de profondeur correspond à la profondeur d&rsquo;un fragment fixé à $[0,1]$ du point de vue de la caméra. Et si nous rendions la scène du point de vue de la lumière et stockions les valeurs de profondeur résultantes dans une texture ? De cette manière, nous pouvons échantillonner les valeurs de profondeur les plus proches du point de vue de la lumière. Après tout, les valeurs de profondeur montrent le premier fragment visible du point de vue de la lumière. Nous stockons toutes ces valeurs de profondeur dans une texture que nous appelons map de profondeur ou shadow map.</p>
<p><img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/02a_shadow_mapping-20230829.png" alt="02a_shadow_mapping-20230829"/>
L&rsquo;image de gauche montre une source lumineuse directionnelle (tous les rayons lumineux sont parallèles) qui projette une ombre sur la surface située sous le cube. En utilisant les valeurs de profondeur stockées dans la map de profondeur, nous trouvons le point le plus proche et l&rsquo;utilisons pour déterminer si les fragments sont dans l&rsquo;ombre. Nous créons la map de profondeur en effectuant le rendu de la scène (du point de vue de la lumière) à l&rsquo;aide d&rsquo;une vue et d&rsquo;une matrice de projection spécifiques à cette source lumineuse. Cette projection et cette matrice de vue forment ensemble une transformation $T$ qui transforme toute position 3D en espace de coordonnées de la lumière (visible).</p>
<blockquote>
<p>Une lumière directionnelle n&rsquo;a pas de position puisqu&rsquo;elle est modélisée pour être infiniment éloignée. Cependant, pour les besoins de la cartographie des ombres, nous devons rendre la scène du point de vue d&rsquo;une lumière et donc rendre la scène à partir d&rsquo;une position située quelque part dans la direction de la lumière.</p>
</blockquote>
<p>Dans l&rsquo;image de droite, nous voyons la même lumière directionnelle et le spectateur. Nous rendons un fragment au point $P$ pour lequel nous devons déterminer s&rsquo;il est dans l&rsquo;ombre. Pour ce faire, nous transformons d&rsquo;abord le point $P$ dans l&rsquo;espace de coordonnées de la lumière à l&rsquo;aide de $T$. Étant donné que le point $P$ est maintenant vu du point de vue de la lumière, sa coordonnée $z$ correspond à sa profondeur qui, dans cet exemple, est de $0.9$. En utilisant le point $P$, nous pouvons également indexer la map des profondeurs/ombres pour obtenir la profondeur visible la plus proche du point de vue de la lumière, qui se trouve au point $C$ avec une profondeur échantillonnée de $0.4$. Étant donné que l&rsquo;indexation de la carte de profondeur renvoie une profondeur inférieure à celle du point $P$, nous pouvons conclure que le point $P$ est occulté et donc dans l&rsquo;ombre.</p>
<p><strong>La cartographie des ombres consiste donc en deux passages : dans un premier temps, nous effectuons le rendu de la map de profondeur et, dans un second temps, nous effectuons le rendu normal de la scène et utilisons la map de profondeur générée pour calculer si des fragments sont dans l&rsquo;ombre.</strong> Cela peut sembler un peu compliqué, mais dès que nous aurons expliqué la technique étape par étape, elle commencera à prendre tout son sens.</p>
<h2 id="la-map-de-profondeur">La map de profondeur<a hidden class="anchor" aria-hidden="true" href="#la-map-de-profondeur">#</a></h2>
<p>La première étape consiste à générer une map de profondeur. La map de profondeur est la texture de profondeur telle qu&rsquo;elle est rendue du point de vue de la lumière que nous utiliserons pour tester les ombres. Comme nous devons stocker le résultat du rendu d&rsquo;une scène dans une texture, nous allons à nouveau avoir besoin de framebuffers.</p>
<p>Tout d&rsquo;abord, nous allons créer un objet framebuffer pour le rendu de la carte de profondeur :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> depthMapFBO;
</span></span><span style="display:flex;"><span>glGenFramebuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>depthMapFBO);
</span></span></code></pre></div><p>Ensuite, nous créons une texture 2D que nous utiliserons comme tampon de profondeur du framebuffer :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> SHADOW_WIDTH <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span>, SHADOW_HEIGHT <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> depthMap;
</span></span><span style="display:flex;"><span>glGenTextures(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>depthMap);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, depthMap);
</span></span><span style="display:flex;"><span>glTexImage2D(GL_TEXTURE_2D, <span style="color:#ae81ff">0</span>, GL_DEPTH_COMPONENT, 
</span></span><span style="display:flex;"><span>             SHADOW_WIDTH, SHADOW_HEIGHT, <span style="color:#ae81ff">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); 
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); 
</span></span></code></pre></div><p>La génération de la map de profondeur ne devrait pas être trop compliquée. Comme nous ne nous intéressons qu&rsquo;aux valeurs de profondeur, nous spécifions que le format de la texture est <code>GL_DEPTH_COMPONENT</code>. Nous donnons également à la texture une largeur et une hauteur de 1024 : c&rsquo;est la résolution de la map de profondeur.</p>
<p>Avec la texture de profondeur générée, nous pouvons l&rsquo;attacher au tampon de profondeur du framebuffer :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
</span></span><span style="display:flex;"><span>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>glDrawBuffer(GL_NONE);
</span></span><span style="display:flex;"><span>glReadBuffer(GL_NONE);
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, <span style="color:#ae81ff">0</span>);  
</span></span></code></pre></div><p>Nous n&rsquo;avons besoin des informations de profondeur que lors du rendu de la scène du point de vue de la lumière, il n&rsquo;est donc pas nécessaire d&rsquo;avoir un tampon de couleur. Un objet framebuffer n&rsquo;est cependant pas complet sans un tampon de couleur, nous devons donc explicitement dire à OpenGL que nous n&rsquo;allons pas rendre de données de couleur. Nous le faisons en réglant les tampons de lecture et de dessin sur <code>GL_NONE</code> avec <code>glDrawBuffer</code> et <code>glReadbuffer</code>.</p>
<p>Avec un framebuffer correctement configuré qui rend les valeurs de profondeur vers une texture, nous pouvons commencer la première passe : générer la carte de profondeur. Combinée à la deuxième passe, l&rsquo;étape de rendu complète ressemblera à ceci :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 1. first render to depth map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glViewport(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
</span></span><span style="display:flex;"><span>    glClear(GL_DEPTH_BUFFER_BIT);
</span></span><span style="display:flex;"><span>    ConfigureShaderAndMatrices();
</span></span><span style="display:flex;"><span>    RenderScene();
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 2. then render scene as normal with shadow mapping (using depth map)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glViewport(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, SCR_WIDTH, SCR_HEIGHT);
</span></span><span style="display:flex;"><span>glClear(GL_COLOR_BUFFER_BIT <span style="color:#f92672">|</span> GL_DEPTH_BUFFER_BIT);
</span></span><span style="display:flex;"><span>ConfigureShaderAndMatrices();
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, depthMap);
</span></span><span style="display:flex;"><span>RenderScene();
</span></span></code></pre></div><p>Ce code a omis quelques détails, mais il vous donnera l&rsquo;idée générale du shadow mapping. Ce qu&rsquo;il est important de noter ici, ce sont les appels à <code>glViewport</code>. Comme les cartes d&rsquo;ombres ont souvent une résolution différente de celle avec laquelle nous avons rendu la scène à l&rsquo;origine (généralement la résolution de la fenêtre), nous devons modifier les paramètres de la fenêtre pour tenir compte de la taille de la map d&rsquo;ombres. Si nous oublions de mettre à jour les paramètres de la fenêtre, la carte de profondeur résultante sera soit incomplète, soit trop petite.</p>
<h2 id="light-space-transform">Light space transform<a hidden class="anchor" aria-hidden="true" href="#light-space-transform">#</a></h2>
<p>La fonction <code>ConfigureShaderAndMatrices</code> est inconnue dans l&rsquo;extrait de code précédent. Dans la deuxième passe, c&rsquo;est la routine : s&rsquo;assurer que les matrices de projection et de vue appropriées sont définies, et définir les matrices de modèle pertinentes par objet. Cependant, dans la première passe, nous devons utiliser une projection et une matrice de vue différentes pour rendre la scène du point de vue de la lumière.</p>
<p>Comme nous modélisons une source de lumière directionnelle, tous ses rayons lumineux sont parallèles. Pour cette raison, nous allons utiliser une matrice de projection orthographique pour la source lumineuse où il n&rsquo;y a pas de déformation de la perspective :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> near_plane <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span>, far_plane <span style="color:#f92672">=</span> <span style="color:#ae81ff">7.5f</span>;
</span></span><span style="display:flex;"><span>glm<span style="color:#f92672">::</span>mat4 lightProjection <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>ortho(<span style="color:#f92672">-</span><span style="color:#ae81ff">10.0f</span>, <span style="color:#ae81ff">10.0f</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">10.0f</span>, <span style="color:#ae81ff">10.0f</span>, near_plane, far_plane);
</span></span></code></pre></div><p>Voici un exemple de matrice de projection orthographique utilisée dans la scène de démonstration de ce chapitre. Étant donné qu&rsquo;une matrice de projection détermine indirectement l&rsquo;étendue de ce qui est visible (c&rsquo;est-à-dire ce qui n&rsquo;est pas coupé), vous devez vous assurer que la taille du frustum de projection contient correctement les objets que vous souhaitez voir figurer dans la map de profondeur. Lorsque des objets ou des fragments ne figurent pas dans la map de profondeur, ils ne produisent pas d&rsquo;ombres.</p>
<p>Pour créer une matrice de vue afin de transformer chaque objet pour qu&rsquo;il soit visible du point de vue de la lumière, nous allons utiliser la fameuse fonction <code>glm::lookAt</code> ; cette fois-ci avec la position de la source de lumière regardant le centre de la scène.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glm<span style="color:#f92672">::</span>mat4 lightView <span style="color:#f92672">=</span> glm<span style="color:#f92672">::</span>lookAt(glm<span style="color:#f92672">::</span>vec3(<span style="color:#f92672">-</span><span style="color:#ae81ff">2.0f</span>, <span style="color:#ae81ff">4.0f</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1.0f</span>), 
</span></span><span style="display:flex;"><span>                                  glm<span style="color:#f92672">::</span>vec3( <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>,  <span style="color:#ae81ff">0.0f</span>), 
</span></span><span style="display:flex;"><span>                                  glm<span style="color:#f92672">::</span>vec3( <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">1.0f</span>,  <span style="color:#ae81ff">0.0f</span>));  
</span></span></code></pre></div><p>En combinant ces deux éléments, nous obtenons une matrice de transformation de l&rsquo;espace lumineux qui transforme chaque vecteur de l&rsquo;espace mondial en l&rsquo;espace visible depuis la source lumineuse ; c&rsquo;est exactement ce dont nous avons besoin pour calculer la map de profondeur.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glm<span style="color:#f92672">::</span>mat4 lightSpaceMatrix <span style="color:#f92672">=</span> lightProjection <span style="color:#f92672">*</span> lightView; 
</span></span></code></pre></div><p>Cette matrice espace-lumière est la matrice de transformation que nous avons précédemment désignée par $T$. Avec cette matrice espace-lumière, nous pouvons effectuer le rendu de la scène comme d&rsquo;habitude tant que nous donnons à chaque shader les équivalents espace-lumière des matrices de projection et de vue. Cependant, nous ne nous intéressons qu&rsquo;aux valeurs de profondeur et non à tous les calculs coûteux des fragments (éclairage). Pour gagner en performance, nous allons utiliser un shader différent, mais beaucoup plus simple, pour le rendu de la map de profondeur.</p>
<h2 id="rendu-de-la-depth-map">Rendu de la depth map<a hidden class="anchor" aria-hidden="true" href="#rendu-de-la-depth-map">#</a></h2>
<p>Lorsque nous rendons la scène du point de vue de la lumière, nous préférons utiliser un shader simple qui ne transforme que les sommets dans l&rsquo;espace lumière et pas grand-chose de plus. Pour un tel shader simple appelé <code>simpleDepthShader</code>, nous utiliserons le vertex shader suivant :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) in vec3 aPos;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform mat4 lightSpaceMatrix;
</span></span><span style="display:flex;"><span>uniform mat4 model;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    gl_Position <span style="color:#f92672">=</span> lightSpaceMatrix <span style="color:#f92672">*</span> model <span style="color:#f92672">*</span> vec4(aPos, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><p>Ce shader de vertex prend un modèle par objet, un vertex, et transforme tous les vertex dans l&rsquo;espace lumière en utilisant <code>lightSpaceMatrix</code>.</p>
<p>Comme nous n&rsquo;avons pas de tampon de couleur et que nous avons désactivé les tampons de dessin et de lecture, les fragments résultants ne nécessitent aucun traitement et nous pouvons donc simplement utiliser un shader de fragment vide:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{             
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// gl_FragDepth = gl_FragCoord.z;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}  
</span></span></code></pre></div><p>Ce fragment shader vide ne fait aucun traitement, et à la fin de son exécution, le tampon de profondeur est mis à jour. Nous pourrions explicitement définir la profondeur en décommentant sa seule ligne, mais c&rsquo;est en fait ce qui se passe en coulisses de toute façon.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>simpleDepthShader.use();
</span></span><span style="display:flex;"><span>glUniformMatrix4fv(lightSpaceMatrixLocation, <span style="color:#ae81ff">1</span>, GL_FALSE, glm<span style="color:#f92672">::</span>value_ptr(lightSpaceMatrix));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>glViewport(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
</span></span><span style="display:flex;"><span>    glClear(GL_DEPTH_BUFFER_BIT);
</span></span><span style="display:flex;"><span>    RenderScene(simpleDepthShader);
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, <span style="color:#ae81ff">0</span>);  
</span></span></code></pre></div><p>Ici, la fonction <code>RenderScene</code> prend un programme de shader, appelle toutes les fonctions de dessin pertinentes et définit les matrices de modèle correspondantes si nécessaire.</p>
<p>Le résultat est un tampon de profondeur joliment rempli qui contient la profondeur la plus proche de chaque fragment visible du point de vue de la lumière. En rendant cette texture sur un quad 2D qui remplit l&rsquo;écran (similaire à ce que nous avons fait dans la section de post-traitement à la fin du chapitre sur les framebuffers), nous obtenons quelque chose comme ceci :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_depth_map.png" alt="shadow_mapping_depth_map"/>
Pour le rendu de la map de profondeur sur un quad, nous avons utilisé le fragment shader suivant :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>out vec4 FragColor;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>in vec2 TexCoords;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform sampler2D depthMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{             
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> depthValue <span style="color:#f92672">=</span> texture(depthMap, TexCoords).r;
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> vec4(vec3(depthValue), <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Notez qu&rsquo;il y a quelques changements subtils lorsque l&rsquo;on affiche la profondeur en utilisant une matrice de projection en perspective plutôt qu&rsquo;une matrice de projection orthographique, car la profondeur n&rsquo;est pas linéaire lorsque l&rsquo;on utilise la projection en perspective. À la fin de ce chapitre, nous aborderons certaines de ces différences subtiles.</p>
<p>Vous pouvez trouver le code source pour le rendu d&rsquo;une scène vers une carte de profondeur <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/3.1.1.shadow_mapping_depth/shadow_mapping_depth.cpp">ici</a>.</p>
<h2 id="rendu-des-ombres">Rendu des ombres<a hidden class="anchor" aria-hidden="true" href="#rendu-des-ombres">#</a></h2>
<p>Avec une map de profondeur correctement générée, nous pouvons commencer à rendre les ombres réelles. Le code permettant de vérifier si un fragment est dans l&rsquo;ombre est (bien évidemment) exécuté dans le fragment shader, mais nous effectuons la transformation de l&rsquo;espace-lumière dans le vertex shader :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) in vec3 aPos;
</span></span><span style="display:flex;"><span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) in vec3 aNormal;
</span></span><span style="display:flex;"><span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>) in vec2 aTexCoords;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out VS_OUT {
</span></span><span style="display:flex;"><span>    vec3 FragPos;
</span></span><span style="display:flex;"><span>    vec3 Normal;
</span></span><span style="display:flex;"><span>    vec2 TexCoords;
</span></span><span style="display:flex;"><span>    vec4 FragPosLightSpace;
</span></span><span style="display:flex;"><span>} vs_out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform mat4 projection;
</span></span><span style="display:flex;"><span>uniform mat4 view;
</span></span><span style="display:flex;"><span>uniform mat4 model;
</span></span><span style="display:flex;"><span>uniform mat4 lightSpaceMatrix;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{    
</span></span><span style="display:flex;"><span>    vs_out.FragPos <span style="color:#f92672">=</span> vec3(model <span style="color:#f92672">*</span> vec4(aPos, <span style="color:#ae81ff">1.0</span>));
</span></span><span style="display:flex;"><span>    vs_out.Normal <span style="color:#f92672">=</span> transpose(inverse(mat3(model))) <span style="color:#f92672">*</span> aNormal;
</span></span><span style="display:flex;"><span>    vs_out.TexCoords <span style="color:#f92672">=</span> aTexCoords;
</span></span><span style="display:flex;"><span>    vs_out.FragPosLightSpace <span style="color:#f92672">=</span> lightSpaceMatrix <span style="color:#f92672">*</span> vec4(vs_out.FragPos, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>    gl_Position <span style="color:#f92672">=</span> projection <span style="color:#f92672">*</span> view <span style="color:#f92672">*</span> vec4(vs_out.FragPos, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Ce qui est nouveau ici, c&rsquo;est le vecteur de sortie supplémentaire <code>FragPosLightSpace</code>. Nous prenons la même matrice <code>lightSpaceMatrix</code> (utilisée pour transformer les sommets en espace lumière dans l&rsquo;étape de la map de profondeur) et transformons la position des sommets dans l&rsquo;espace monde en espace lumière pour l&rsquo;utiliser dans le shader de fragments.</p>
<p>Le shader de fragments principal que nous utiliserons pour le rendu de la scène utilise le modèle d&rsquo;éclairage Blinn-Phong. Dans le shader de fragment, nous calculons ensuite une valeur d&rsquo;ombre qui est soit de $1.0$ lorsque le fragment est dans l&rsquo;ombre, soit de $0.0$ lorsqu&rsquo;il n&rsquo;est pas dans l&rsquo;ombre. Les composantes diffuse et spéculaire résultantes sont ensuite multipliées par cette composante d&rsquo;ombre. Les ombres étant rarement complètement sombres (en raison de la diffusion de la lumière), nous ne tenons pas compte de la composante ambiante dans les multiplications de l&rsquo;ombre.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>out vec4 FragColor;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>in VS_OUT {
</span></span><span style="display:flex;"><span>    vec3 FragPos;
</span></span><span style="display:flex;"><span>    vec3 Normal;
</span></span><span style="display:flex;"><span>    vec2 TexCoords;
</span></span><span style="display:flex;"><span>    vec4 FragPosLightSpace;
</span></span><span style="display:flex;"><span>} fs_in;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform sampler2D diffuseTexture;
</span></span><span style="display:flex;"><span>uniform sampler2D shadowMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform vec3 lightPos;
</span></span><span style="display:flex;"><span>uniform vec3 viewPos;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">ShadowCalculation</span>(vec4 fragPosLightSpace)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    [...]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{           
</span></span><span style="display:flex;"><span>    vec3 color <span style="color:#f92672">=</span> texture(diffuseTexture, fs_in.TexCoords).rgb;
</span></span><span style="display:flex;"><span>    vec3 normal <span style="color:#f92672">=</span> normalize(fs_in.Normal);
</span></span><span style="display:flex;"><span>    vec3 lightColor <span style="color:#f92672">=</span> vec3(<span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ambient
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 ambient <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.15</span> <span style="color:#f92672">*</span> lightColor;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// diffuse
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 lightDir <span style="color:#f92672">=</span> normalize(lightPos <span style="color:#f92672">-</span> fs_in.FragPos);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> diff <span style="color:#f92672">=</span> max(dot(lightDir, normal), <span style="color:#ae81ff">0.0</span>);
</span></span><span style="display:flex;"><span>    vec3 diffuse <span style="color:#f92672">=</span> diff <span style="color:#f92672">*</span> lightColor;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// specular
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 viewDir <span style="color:#f92672">=</span> normalize(viewPos <span style="color:#f92672">-</span> fs_in.FragPos);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> spec <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>    vec3 halfwayDir <span style="color:#f92672">=</span> normalize(lightDir <span style="color:#f92672">+</span> viewDir);  
</span></span><span style="display:flex;"><span>    spec <span style="color:#f92672">=</span> pow(max(dot(normal, halfwayDir), <span style="color:#ae81ff">0.0</span>), <span style="color:#ae81ff">64.0</span>);
</span></span><span style="display:flex;"><span>    vec3 specular <span style="color:#f92672">=</span> spec <span style="color:#f92672">*</span> lightColor;    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// calculate shadow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> shadow <span style="color:#f92672">=</span> ShadowCalculation(fs_in.FragPosLightSpace);       
</span></span><span style="display:flex;"><span>    vec3 lighting <span style="color:#f92672">=</span> (ambient <span style="color:#f92672">+</span> (<span style="color:#ae81ff">1.0</span> <span style="color:#f92672">-</span> shadow) <span style="color:#f92672">*</span> (diffuse <span style="color:#f92672">+</span> specular)) <span style="color:#f92672">*</span> color;    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> vec4(lighting, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Le fragment shader est en grande partie une copie de ce que nous avons utilisé dans le chapitre sur l&rsquo;éclairage avancé, mais avec un calcul d&rsquo;ombre supplémentaire. Nous avons déclaré une fonction <code>ShadowCalculation</code> qui effectue la majeure partie du travail sur les ombres. À la fin du fragment shader, nous multiplions les contributions diffuses et spéculaires par l&rsquo;inverse de la composante d&rsquo;ombre, c&rsquo;est-à-dire la proportion du fragment qui n&rsquo;est pas dans l&rsquo;ombre. Ce shader de fragment prend comme entrée supplémentaire la position du fragment dans l&rsquo;espace-lumière et la map de profondeur générée lors de la première passe de rendu.</p>
<p>La première chose à faire pour vérifier si un fragment est dans l&rsquo;ombre est de transformer la position du fragment dans l&rsquo;espace-lumière dans l&rsquo;espace-clip en coordonnées normalisées de l&rsquo;appareil (device). Lorsque nous transmettons une position de vertex dans l&rsquo;espace-clip à <code>gl_Position</code> dans le vertex shader, OpenGL effectue automatiquement une division en perspective, par exemple en transformant les coordonnées de l&rsquo;espace-clip dans l&rsquo;intervalle $[-w,w]$ à $[-1,1]$ en divisant les composantes $x, y$ et $z$ par la composante $w$ du vecteur. Comme le clip-space <code>FragPosLightSpace</code> n&rsquo;est pas transmis au fragment shader par l&rsquo;intermédiaire de <code>gl_Position</code>, nous devons effectuer cette division de perspective nous-mêmes :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">ShadowCalculation</span>(vec4 fragPosLightSpace)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// perform perspective divide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 projCoords <span style="color:#f92672">=</span> fragPosLightSpace.xyz <span style="color:#f92672">/</span> fragPosLightSpace.w;
</span></span><span style="display:flex;"><span>    [...]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Elle renvoie la position du fragment dans l&rsquo;espace lumineux dans l&rsquo;intervalle $[-1,1]$.</p>
<blockquote>
<p>Lors de l&rsquo;utilisation d&rsquo;une matrice de projection orthographique, la composante w d&rsquo;un sommet n&rsquo;est pas modifiée et cette étape n&rsquo;a donc aucun sens. Cependant, elle est nécessaire lors de l&rsquo;utilisation d&rsquo;une projection en perspective et le fait de conserver cette ligne permet de s&rsquo;assurer qu&rsquo;elle fonctionne avec les deux matrices de projection.</p>
</blockquote>
<p>Étant donné que la profondeur de la map de profondeur est comprise dans l&rsquo;intervalle $[0,1]$ et que nous voulons également utiliser <code>projCoords</code> pour échantillonner à partir de la map de profondeur, nous transformons les coordonnées NDC dans l&rsquo;intervalle $[0,1]$ :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>projCoords <span style="color:#f92672">=</span> projCoords <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>; 
</span></span></code></pre></div><p>Ces coordonnées projetées nous permettent d&rsquo;échantillonner la map de profondeur, car les coordonnées $[0,1]$ résultant de <code>projCoords</code> correspondent directement aux coordonnées NDC transformées lors de la première passe de rendu. Cela nous donne la profondeur la plus proche du point de vue de la lumière :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> closestDepth <span style="color:#f92672">=</span> texture(shadowMap, projCoords.xy).r;   
</span></span></code></pre></div><p>Pour obtenir la profondeur actuelle de ce fragment, il suffit de récupérer la coordonnée $z$ du vecteur projeté, qui est égale à la profondeur de ce fragment du point de vue de la lumière.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> currentDepth <span style="color:#f92672">=</span> projCoords.z;  
</span></span></code></pre></div><p>La comparaison proprement dite consiste alors simplement à vérifier si <code>currentDepth</code> est supérieur à <code>closestDepth</code> et si c&rsquo;est le cas, le fragment est dans l&rsquo;ombre :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> shadow <span style="color:#f92672">=</span> currentDepth <span style="color:#f92672">&gt;</span> closestDepth  <span style="color:#f92672">?</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0.0</span>;  
</span></span></code></pre></div><p>La fonction complète de calcul des ombres devient alors :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">ShadowCalculation</span>(vec4 fragPosLightSpace)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// perform perspective divide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    vec3 projCoords <span style="color:#f92672">=</span> fragPosLightSpace.xyz <span style="color:#f92672">/</span> fragPosLightSpace.w;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// transform to [0,1] range
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    projCoords <span style="color:#f92672">=</span> projCoords <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// get closest depth value from light&#39;s perspective (using [0,1] range fragPosLight as coords)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> closestDepth <span style="color:#f92672">=</span> texture(shadowMap, projCoords.xy).r; 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// get depth of current fragment from light&#39;s perspective
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> currentDepth <span style="color:#f92672">=</span> projCoords.z;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// check whether current frag pos is in shadow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float</span> shadow <span style="color:#f92672">=</span> currentDepth <span style="color:#f92672">&gt;</span> closestDepth  <span style="color:#f92672">?</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> shadow;
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>L&rsquo;activation de ce shader, la liaison des textures appropriées et l&rsquo;activation des matrices de projection et de vue par défaut lors de la deuxième passe de rendu devraient donner un résultat similaire à l&rsquo;image ci-dessous :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_shadows.png" alt="shadow_mapping_shadows"/>
Si vous avez bien fait les choses, vous devriez en effet voir (bien qu&rsquo;avec quelques artefacts) des ombres sur le sol et les cubes. Vous pouvez trouver le code source de l&rsquo;application de démonstration <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/3.1.2.shadow_mapping_base/shadow_mapping_base.cpp">ici</a>.</p>
<h2 id="améliorer-les-shadow-maps">Améliorer les shadow maps<a hidden class="anchor" aria-hidden="true" href="#améliorer-les-shadow-maps">#</a></h2>
<p>Nous avons réussi à faire fonctionner les bases du shadow mapping, mais comme vous pouvez le constater, nous ne sommes pas encore au bout de nos peines à cause de plusieurs artefacts (clairement visibles) liés au shadow mapping que nous devons corriger. Nous nous concentrerons sur la correction de ces artefacts dans les prochaines sections.</p>
<h3 id="shadow-acne">Shadow acne<a hidden class="anchor" aria-hidden="true" href="#shadow-acne">#</a></h3>
<p>L&rsquo;image précédente montre clairement que quelque chose ne va pas. Un zoom plus rapproché montre un motif <em>Moiré</em> très évident :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_acne.png" alt="shadow_mapping_acne"/>
Nous pouvons voir qu&rsquo;une grande partie de la surface du sol est rendue avec des lignes noires évidentes en alternance. Cet artefact de mappage des ombres est appelé acné des ombres et peut être expliqué par l&rsquo;image suivante :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_acne_diagram.png" alt="shadow_mapping_acne_diagram"/>
Comme la map des ombres est limitée par la résolution, plusieurs fragments peuvent échantillonner la même valeur de la map de profondeur lorsqu&rsquo;ils sont relativement éloignés de la source lumineuse. L&rsquo;image montre le sol où chaque panneau jaune incliné représente un seul texel de la map de profondeur. Comme vous pouvez le voir, plusieurs fragments échantillonnent le même échantillon de profondeur.</p>
<p>Bien que cela soit généralement acceptable, cela devient un problème lorsque la source lumineuse regarde la surface sous un angle, car dans ce cas, la map de profondeur est également rendue sous un angle. Plusieurs fragments accèdent alors au même texel de profondeur incliné alors que certains sont au-dessus et d&rsquo;autres au-dessous du sol ; nous obtenons une divergence d&rsquo;ombre. De ce fait, certains fragments sont considérés comme étant dans l&rsquo;ombre et d&rsquo;autres non, ce qui donne le motif rayé de l&rsquo;image.</p>
<p>Nous pouvons résoudre ce problème à l&rsquo;aide d&rsquo;une petite astuce appelée &ldquo;biais d&rsquo;ombre&rdquo; (shadow bias), qui consiste simplement à décaler la profondeur de la surface (ou de la map d&rsquo;ombre) d&rsquo;une petite quantité de biais, de sorte que les fragments ne soient pas considérés à tort comme étant au-dessus de la surface.
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping-20230830.png" alt="shadow_mapping-20230830"/>
Avec le biais appliqué, tous les échantillons ont une profondeur inférieure à la profondeur de la surface et la surface entière est donc correctement éclairée sans aucune ombre. Nous pouvons mettre en œuvre un tel biais de la manière suivante :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> bias <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> shadow <span style="color:#f92672">=</span> currentDepth <span style="color:#f92672">-</span> bias <span style="color:#f92672">&gt;</span> closestDepth  <span style="color:#f92672">?</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0.0</span>;  
</span></span></code></pre></div><p>Un biais d&rsquo;ombre de $0.005$ résout en grande partie les problèmes de notre scène, mais <strong>vous pouvez imaginer que la valeur du biais dépend fortement de l&rsquo;angle entre la source lumineuse et la surface</strong>. Si la surface est très inclinée par rapport à la source lumineuse, les ombres peuvent encore présenter une acné. Une approche plus solide consisterait à modifier la valeur du biais en fonction de l&rsquo;angle de la surface par rapport à la lumière : un problème que nous pouvons résoudre avec le produit scalaire :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> bias <span style="color:#f92672">=</span> max(<span style="color:#ae81ff">0.05</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1.0</span> <span style="color:#f92672">-</span> dot(normal, lightDir)), <span style="color:#ae81ff">0.005</span>);  
</span></span></code></pre></div><p>Nous avons ici un biais maximum de $0.05$ et un minimum de $0.005$ en fonction de la normale de la surface et de la direction de la lumière. Ainsi, les surfaces comme le sol qui sont presque perpendiculaires à la source lumineuse ont un petit biais, tandis que les surfaces comme les faces latérales du cube ont un biais beaucoup plus important. L&rsquo;image suivante montre la même scène, mais avec un biais pour les ombres :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_with_bias.png" alt="shadow_mapping_with_bias"/>
Le choix de la (des) valeur(s) de biais correcte(s) nécessite quelques ajustements car elle(s) sera(ont) différente(s) pour chaque scène, mais la plupart du temps, il s&rsquo;agit simplement d&rsquo;incrémenter lentement le biais jusqu&rsquo;à ce que toute l&rsquo;acné soit supprimée.</p>
<h3 id="-peter-panning">### Peter panning<a hidden class="anchor" aria-hidden="true" href="#-peter-panning">#</a></h3>
<p>L&rsquo;inconvénient de l&rsquo;utilisation d&rsquo;un biais d&rsquo;ombre est que vous appliquez un décalage à la profondeur réelle des objets. Par conséquent, le biais peut devenir suffisamment important pour que les ombres soient visiblement décalées par rapport à l&rsquo;emplacement réel des objets, comme vous pouvez le voir ci-dessous (avec une valeur de biais exagérée) :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_peter_panning.png" alt="shadow_mapping_peter_panning"/>
Cet artefact d&rsquo;ombre est appelé &ldquo;<strong>peter panning</strong>&rdquo;, car les objets semblent légèrement détachés de leurs ombres. Nous pouvons utiliser une petite astuce pour résoudre la plupart des problèmes de peter panning en utilisant l&rsquo;élimination des faces avant lors du rendu de la carte de profondeur. Vous vous souvenez peut-être du chapitre sur l&rsquo;élimination des faces qu&rsquo;OpenGL élimine par défaut les faces arrière. <strong>En indiquant à OpenGL que nous voulons éliminer les faces avant pendant l&rsquo;étape de la map des ombres, nous inversons cet ordre.</strong></p>
<p>Comme nous n&rsquo;avons besoin que des valeurs de profondeur pour la map de profondeur, cela ne devrait pas avoir d&rsquo;importance pour les objets solides que nous prenions la profondeur de leurs faces avant ou de leurs faces arrière. L&rsquo;utilisation de la profondeur de la face arrière ne donne pas de mauvais résultats car l&rsquo;existence d&rsquo;ombres à l&rsquo;intérieur des objets n&rsquo;a pas d&rsquo;importance ; de toute façon, nous ne pouvons pas voir à l&rsquo;intérieur des objets.
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/Pasted%20image%2020230830111353.png" alt="Pasted image 20230830111353.png"/>
Pour corriger le peter panning, nous éliminons toutes les faces avant lors de la génération de la map d&rsquo;ombres. Notez que vous devez d&rsquo;abord activer <code>GL_CULL_FACE</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glCullFace(GL_FRONT);
</span></span><span style="display:flex;"><span>RenderSceneToDepthMap();
</span></span><span style="display:flex;"><span>glCullFace(GL_BACK); <span style="color:#75715e">// don&#39;t forget to reset original culling face
</span></span></span></code></pre></div><p>Cela résout effectivement les problèmes de peter panning, mais seulement pour les objets solides qui ont réellement un intérieur sans ouvertures. <strong>Dans notre scène, par exemple, cela fonctionne parfaitement pour les cubes. Cependant, sur le sol, cela ne fonctionnera pas aussi bien car l&rsquo;élimination de la face avant supprime complètement le sol de l&rsquo;équation</strong>. Le sol est un plan unique et serait donc complètement éliminé. Si l&rsquo;on veut résoudre le problème du peter panning à l&rsquo;aide de cette astuce, il faut veiller à n&rsquo;éliminer que les faces avant des objets pour lesquels cela a un sens.</p>
<p>Il faut également tenir compte du fait que les objets proches du récepteur d&rsquo;ombre (comme le cube éloigné) peuvent encore donner des résultats incorrects. Cependant, avec des valeurs de biais normales, il est généralement possible d&rsquo;éviter le &ldquo;peter panning&rdquo;.</p>
<h3 id="over-sampling">Over sampling<a hidden class="anchor" aria-hidden="true" href="#over-sampling">#</a></h3>
<p>Une autre anomalie visuelle que vous pouvez apprécier ou non est que les régions situées en dehors du frustum visible de la lumière sont considérées comme étant dans l&rsquo;ombre alors qu&rsquo;elles ne le sont (généralement) pas. Cela est dû au fait que les coordonnées projetées en dehors du frustum de la lumière sont supérieures à $1.0$ et échantillonneront donc la texture de profondeur en dehors de sa plage par défaut de $[0.1]$. En se basant sur la méthode de wrapping de la texture, nous obtiendrons des résultats de profondeur incorrects qui ne sont pas basés sur les valeurs de profondeur réelles de la source lumineuse.
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_outside_frustum.png" alt="shadow_mapping_outside_frustum"/>
Vous pouvez voir dans l&rsquo;image qu&rsquo;il y a une sorte de région imaginaire de lumière, et qu&rsquo;une grande partie en dehors de cette zone est dans l&rsquo;ombre ; cette zone représente la taille de la map de profondeur projetée sur le sol. Cette zone représente la taille de la map de profondeur projetée sur le sol. La raison pour laquelle cela se produit est que nous avons précédemment défini les options de wrapping de la map de profondeur sur <code>GL_REPEAT</code>.</p>
<p>Ce que nous préférons, c&rsquo;est que toutes les coordonnées situées en dehors de la plage de la map de profondeur aient une profondeur de $1.0$, ce qui signifie que ces coordonnées ne seront jamais dans l&rsquo;ombre (car aucun objet n&rsquo;aura une profondeur supérieure à $1.0$). Nous pouvons le faire en configurant une couleur de bordure de texture et en réglant les options de wrapping de texture de la map de profondeur sur <code>GL_CLAMP_TO_BORDER</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> borderColor[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span> };
</span></span><span style="display:flex;"><span>glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);  
</span></span></code></pre></div><p>Désormais, chaque fois que nous échantillonnons en dehors de la plage de coordonnées $[0,1]$ de la map de profondeur, la fonction de texture renvoie toujours une profondeur de $1.0$, ce qui produit une valeur d&rsquo;ombre de $0.0$ Le résultat est désormais plus plausible :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_clamp_edge.png" alt="shadow_mapping_clamp_edge"/>
Il semble qu&rsquo;il y ait encore une partie présentant une région sombre. Il s&rsquo;agit des coordonnées situées à l&rsquo;extérieur du plan éloigné du frustum orthographique de la lumière. Vous pouvez constater que cette région sombre se trouve toujours à l&rsquo;extrémité du frustum de la source lumineuse en observant les directions des ombres.</p>
<p>La coordonnée d&rsquo;un fragment projeté dans l&rsquo;espace lumineux est plus éloignée que le plan éloigné de la lumière lorsque sa coordonnée $z$ est supérieure à $1.0$. Dans ce cas, la méthode de wrapping <code>GL_CLAMP_TO_BORDER</code> ne fonctionne plus car nous comparons la composante $z$ de la coordonnée avec les valeurs de la map de profondeur ; cette méthode renvoie toujours un résultat positif pour les valeurs $z$ supérieures à $1.0$.</p>
<p>La solution à ce problème est relativement simple : il suffit de forcer la valeur de l&rsquo;ombre à $0.0$ chaque fois que la coordonnée $z$ du vecteur projeté est supérieure à $1.0$ :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">ShadowCalculation</span>(vec4 fragPosLightSpace)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    [...]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(projCoords.z <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1.0</span>)
</span></span><span style="display:flex;"><span>        shadow <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> shadow;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Le fait de vérifier le plan éloigné et de limiter la map de profondeur à une couleur de bordure spécifiée manuellement résout le problème du suréchantillonnage de la map de profondeur. Cela nous permet enfin d&rsquo;obtenir le résultat que nous recherchons :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_over_sampling_fixed.png" alt="shadow_mapping_over_sampling_fixed"/>
Le résultat de tout ceci signifie que nous n&rsquo;avons des ombres que là où les coordonnées du fragment projeté se trouvent dans la zone de la map de profondeur, donc tout ce qui se trouve en dehors du frustum de lumière n&rsquo;aura pas d&rsquo;ombres visibles. Comme les jeux vidéo font généralement en sorte que cela ne se produise qu&rsquo;au loin, c&rsquo;est un effet beaucoup plus plausible que les régions noires évidentes que nous avions auparavant.</p>
<h3 id="pcf">PCF<a hidden class="anchor" aria-hidden="true" href="#pcf">#</a></h3>
<p>Les ombres actuelles sont un ajout agréable au paysage, mais ce n&rsquo;est pas encore exactement ce que nous voulons. Si l&rsquo;on zoome sur les ombres, la dépendance de la résolution du mapping des ombres devient rapidement évidente.
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_zoom.png" alt="shadow_mapping_zoom.png"/>
Comme la map de profondeur a une résolution fixe, la profondeur s&rsquo;étend souvent sur plus d&rsquo;un fragment par texel. Par conséquent, plusieurs fragments échantillonnent la même valeur de profondeur à partir de la map de profondeur et parviennent aux mêmes conclusions d&rsquo;ombre, ce qui produit ces bords irréguliers.</p>
<p>Vous pouvez réduire ces ombres en bloc en augmentant la résolution de la carte de profondeur ou en essayant d&rsquo;ajuster le cône de lumière le plus près possible de la scène.</p>
<p>Une autre solution (partielle) à ces bords irréguliers est appelée <strong>PCF</strong> (<strong>percentage-closer filtering</strong>), un terme qui englobe de nombreuses fonctions de filtrage différentes qui produisent des ombres plus douces, en les faisant paraître moins bloquées ou dures. <strong>L&rsquo;idée est d&rsquo;échantillonner plusieurs fois la map de profondeur, chaque fois avec des coordonnées de texture légèrement différentes</strong>. Pour chaque échantillon individuel, nous vérifions s&rsquo;il est dans l&rsquo;ombre ou non. Tous les sous-résultats sont ensuite combinés et moyennés, ce qui permet d&rsquo;obtenir une ombre douce et agréable à regarder.</p>
<p>Une implémentation simple du PCF consiste simplement à échantillonner les texels environnants de la map de profondeur et à faire la moyenne des résultats :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> shadow <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>vec2 texelSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> textureSize(shadowMap, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; x <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; y <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>y)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">float</span> pcfDepth <span style="color:#f92672">=</span> texture(shadowMap, projCoords.xy <span style="color:#f92672">+</span> vec2(x, y) <span style="color:#f92672">*</span> texelSize).r; 
</span></span><span style="display:flex;"><span>        shadow <span style="color:#f92672">+=</span> currentDepth <span style="color:#f92672">-</span> bias <span style="color:#f92672">&gt;</span> pcfDepth <span style="color:#f92672">?</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0.0</span>;        
</span></span><span style="display:flex;"><span>    }    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>shadow <span style="color:#f92672">/=</span> <span style="color:#ae81ff">9.0</span>;
</span></span></code></pre></div><p>Ici, <code>textureSize</code> renvoie un <code>vec2</code> de la largeur et de la hauteur de la texture du sampler donnée au niveau 0 de la mipmap. 1 divisé par ce <code>vec2</code> <strong>renvoie la taille d&rsquo;un texel unique</strong> que nous utilisons pour décaler les coordonnées de la texture, en nous assurant que chaque nouvel échantillon échantillonne une valeur de profondeur différente. Ici, nous échantillonnons 9 valeurs autour des valeurs $x$ et $y$ de la coordonnée projetée, nous testons l&rsquo;occlusion des ombres et enfin nous faisons la moyenne des résultats en fonction du nombre total d&rsquo;échantillons prélevés.</p>
<p>En utilisant plus d&rsquo;échantillons et/ou en variant la variable <code>texelSize</code>, vous pouvez augmenter la qualité des ombres douces. Ci-dessous, vous pouvez voir les ombres avec un simple PCF appliqué :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping_soft_shadows.png" alt="shadow_mapping_soft_shadows"/>
De loin, les ombres sont beaucoup plus belles et moins dures. Si vous zoomez, vous pouvez toujours voir les artefacts de résolution du shadow mapping, mais en général cela donne de bons résultats pour la plupart des applications.</p>
<p>Vous pouvez trouver le code source complet de l&rsquo;exemple <a href="https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/3.1.3.shadow_mapping/shadow_mapping.cpp">ici</a>.</p>
<p>Il y a en fait beaucoup plus à faire avec le PCF et pas mal de techniques pour améliorer considérablement la qualité des ombres douces, mais pour des raisons de longueur de ce chapitre, nous laisserons cela pour une discussion ultérieure.</p>
<h3 id="orthographique-vs-perspective">Orthographique vs Perspective<a hidden class="anchor" aria-hidden="true" href="#orthographique-vs-perspective">#</a></h3>
<p>Il existe une différence entre le rendu de la map de profondeur avec une matrice de projection orthographique ou perspective. Une matrice de projection orthographique ne déforme pas la scène avec la perspective, de sorte que tous les rayons de vue/lumière sont parallèles. Cela en fait une excellente matrice de projection pour les lumières directionnelles. En revanche, une matrice de projection en perspective déforme tous les sommets en fonction de la perspective, ce qui donne des résultats différents. L&rsquo;image suivante montre les différentes zones d&rsquo;ombre des deux méthodes de projection :
<img src="/docs/LEARNOPENGL_FR/05_Advanced_Lighting/shadow_mapping-ortho-proj-0230830.png" alt="shadow_mapping-ortho-proj-0230830"/>
Les projections en perspective sont plus utiles pour les sources lumineuses qui ont un emplacement réel, contrairement aux lumières directionnelles. <strong>Les projections en perspective sont le plus souvent utilisées avec les projecteurs et les lumières ponctuelles, tandis que les projections orthographiques sont utilisées pour les lumières directionnelles.</strong></p>
<p>Une autre différence subtile avec l&rsquo;utilisation d&rsquo;une matrice de projection en perspective est que la visualisation du tampon de profondeur donne souvent un résultat presque entièrement blanc. Cela s&rsquo;explique par le fait qu&rsquo;avec la projection en perspective, la profondeur est transformée en valeurs de profondeur non linéaires dont la majeure partie de la plage visible se situe près du plan proche. Pour pouvoir visualiser correctement les valeurs de profondeur comme nous l&rsquo;avons fait avec la projection orthographique, vous devez d&rsquo;abord transformer les valeurs de profondeur non linéaires en valeurs linéaires, comme nous l&rsquo;avons expliqué dans le chapitre sur les <a href="/docs/learnopengl_fr/04_advanced_opengl/00_depth_testing/">tests de profondeur</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>out vec4 FragColor;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>in vec2 TexCoords;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform sampler2D depthMap;
</span></span><span style="display:flex;"><span>uniform <span style="color:#66d9ef">float</span> near_plane;
</span></span><span style="display:flex;"><span>uniform <span style="color:#66d9ef">float</span> far_plane;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">LinearizeDepth</span>(<span style="color:#66d9ef">float</span> depth)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> z <span style="color:#f92672">=</span> depth <span style="color:#f92672">*</span> <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.0</span>; <span style="color:#75715e">// Back to NDC 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> (<span style="color:#ae81ff">2.0</span> <span style="color:#f92672">*</span> near_plane <span style="color:#f92672">*</span> far_plane) <span style="color:#f92672">/</span> (far_plane <span style="color:#f92672">+</span> near_plane <span style="color:#f92672">-</span> z <span style="color:#f92672">*</span> (far_plane <span style="color:#f92672">-</span> near_plane));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{             
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> depthValue <span style="color:#f92672">=</span> texture(depthMap, TexCoords).r;
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> vec4(vec3(LinearizeDepth(depthValue) <span style="color:#f92672">/</span> far_plane), <span style="color:#ae81ff">1.0</span>); <span style="color:#75715e">// perspective
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// FragColor = vec4(vec3(depthValue), 1.0); // orthographic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}  
</span></span></code></pre></div><p>Cela montre des valeurs de profondeur similaires à ce que nous avons vu avec la projection orthographique. Notez que cela n&rsquo;est utile que pour le débogage ; les vérifications de profondeur restent les mêmes avec les matrices orthographiques ou de projection, car les profondeurs relatives ne changent pas.</p>
<h2 id="ressources-additionnelles">Ressources additionnelles<a hidden class="anchor" aria-hidden="true" href="#ressources-additionnelles">#</a></h2>
<ul>
<li><a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">Tutoriel 16 : Shadow mapping</a> : tutoriel similaire sur le shadow mapping par opengl-tutorial.org avec quelques notes supplémentaires.</li>
<li><a href="http://ogldev.atspace.co.uk/www/tutorial23/tutorial23.html">Shadow Mapping - Part 1</a> : un autre tutoriel de shadow mapping par ogldev.</li>
<li><a href="https://www.youtube.com/watch?v=EsccgeUpdsM">How Shadow Mapping Works</a> : un tutoriel YouTube en 3 parties par TheBennyBox sur le shadow mapping et son implémentation.</li>
<li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324%28v=vs.85%29.aspx">Common Techniques to Improve Shadow Depth Maps</a> : un excellent article de Microsoft énumérant un grand nombre de techniques permettant d&rsquo;améliorer la qualité des maps d&rsquo;ombres.</li>
<li><a href="https://www.youtube.com/watch?v=uueB2kVvbHo">How I Implemented Shadows in my Game Engine</a> : excellente vidéo de ThinMatrix sur ses méthodes d&rsquo;amélioration des maps d&rsquo;ombres.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://hrst4.xyz/">hrst4&#39;s blog toml</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
