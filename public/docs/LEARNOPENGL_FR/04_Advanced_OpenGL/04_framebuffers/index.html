<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <title></title>
    <style>
    .container {
      max-width: 700px;
    }
    #nav a {
      font-weight: bold;
      color: inherit;
    }
    #nav-border {
      border-bottom: 1px solid #212529;
    }
    #main {
      margin-top: 1em;
      margin-bottom: 4em;
    }
    #home-jumbotron {
      background-color: inherit;
    }
    .font-125 {
      font-size: 125%;
    }
    .tag-btn {
      margin-bottom: 0.3em;
    }
    img {
      max-width: 100%;
    }
    </style>
  </head>
  <body>
    <div id="nav-border" class="container">
    <nav id="nav" class="nav justify-content-center">
    
      
      
      <a class="nav-link" href="/"><i data-feather="home"></i> Home</a>
    
      
      
      <a class="nav-link" href="/blog/"><i data-feather="edit"></i> Blog</a>
    
      
      
      <a class="nav-link" href="/tags/"><i data-feather="tag"></i> Tags</a>
    
    </nav>
  </div>
  
    <div class="container">
      <main id="main">
       

<h1></h1>


<i data-feather="calendar"></i> <time datetime="0001-01-01">Jan 1, 0001</time>

<br><br>
<h1 id="framebuffers">Framebuffers</h1>
<p>Jusqu&rsquo;à présent, nous avons utilisé plusieurs types de tampons d&rsquo;écran (screen buffers) : un tampon de couleur pour écrire les valeurs de couleur, un tampon de profondeur pour écrire et tester les informations de profondeur, et enfin un tampon de stencil qui nous permet d&rsquo;écarter certains fragments en fonction d&rsquo;une certaine condition. <strong>La combinaison de ces tampons est stockée quelque part dans la mémoire du GPU et est appelée framebuffer</strong>. OpenGL nous donne la possibilité de définir nos propres framebuffers et donc de définir notre propre tampon de couleur (et optionnellement un tampon de profondeur et de stencil).</p>
<p>Les opérations de rendu que nous avons effectuées jusqu&rsquo;à présent ont toutes été réalisées au-dessus des tampons de rendu attachés au framebuffer par défaut. <strong>Le framebuffer par défaut est créé et configuré lorsque vous créez votre fenêtre (GLFW le fait pour nous)</strong>. <strong>En créant notre propre framebuffer, nous pouvons obtenir une cible supplémentaire pour le rendu.</strong></p>
<p>L&rsquo;application des framebuffers n&rsquo;a peut-être pas de sens immédiat, mais **rendre votre scène dans un framebuffer différent nous permet d&rsquo;utiliser ce résultat pour créer des miroirs dans une scène, ou faire des effets de post-traitement intéressants par exemple.**Nous verrons d&rsquo;abord comment ils fonctionnent, puis nous les utiliserons en mettant en œuvre ces effets de post-traitement.</p>
<h2 id="créer-un-framebuffer">Créer un framebuffer</h2>
<p>Comme tout autre objet d&rsquo;OpenGL, nous pouvons créer un objet framebuffer (abrégé en FBO) en utilisant une fonction appelée <code>glGenFramebuffers</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> fbo;
</span></span><span style="display:flex;"><span>glGenFramebuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>fbo);
</span></span></code></pre></div><p>Ce modèle de création et d&rsquo;utilisation d&rsquo;objets est quelque chose que nous avons vu des dizaines de fois maintenant, de sorte que leurs fonctions d&rsquo;utilisation sont similaires à celles de tous les autres objets que nous avons vus : <strong>nous créons d&rsquo;abord un objet framebuffer, nous le lions en tant que framebuffer actif, nous effectuons quelques opérations et nous délions le framebuffer. Pour lier le framebuffer, nous utilisons <code>glBindFramebuffer</code> :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, fbo);  
</span></span></code></pre></div><p>En se liant à la cible <code>GL_FRAMEBUFFER</code>, toutes les prochaines opérations de lecture et d&rsquo;écriture du framebuffer affecteront le framebuffer actuellement lié. Il est également possible de lier un framebuffer à une cible de lecture ou d&rsquo;écriture spécifique en le liant à <code>GL_READ_FRAMEBUFFER</code> ou <code>GL_DRAW_FRAMEBUFFER</code> respectivement. Le framebuffer lié à <code>GL_READ_FRAMEBUFFER</code> est alors utilisé pour toutes les opérations de lecture comme <code>glReadPixels</code> et le framebuffer lié à <code>GL_DRAW_FRAMEBUFFER</code> est utilisé comme destination pour le rendu, l&rsquo;effacement et d&rsquo;autres opérations d&rsquo;écriture. La plupart du temps, vous n&rsquo;aurez pas besoin de faire cette distinction et vous liez généralement les deux avec <code>GL_FRAMEBUFFER</code>.</p>
<p>Malheureusement, nous ne pouvons pas encore utiliser notre framebuffer car il n&rsquo;est pas complet. <strong>Pour qu&rsquo;un framebuffer soit complet, les conditions suivantes doivent être remplies :</strong></p>
<ul>
<li>Nous devons <strong>attacher au moins un tampon</strong> (tampon de couleur, de profondeur ou de stencil).</li>
<li>Il doit y avoir <strong>au moins un tampon de couleur.</strong></li>
<li>Toutes les pièces jointes doivent également être complètes (mémoire réservée).</li>
<li>Chaque tampon doit avoir <strong>le même nombre d&rsquo;échantillons.</strong></li>
</ul>
<p>Ne vous inquiétez pas si vous ne savez pas ce que sont les échantillons (samples), nous y reviendrons dans un chapitre ultérieur.</p>
<p>D&rsquo;après les exigences, il devrait être clair que nous devons créer une sorte d&rsquo;attachement pour le framebuffer et attacher cet attachement au framebuffer. Après avoir rempli toutes les conditions, nous pouvons vérifier si nous avons réussi à compléter le framebuffer en appelant <code>glCheckFramebufferStatus</code> avec <code>GL_FRAMEBUFFER</code>. Il vérifie alors le framebuffer actuellement lié et renvoie l&rsquo;une des valeurs trouvées dans la spécification. S&rsquo;il renvoie <code>GL_FRAMEBUFFER_COMPLETE</code>, nous sommes prêts :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(glCheckFramebufferStatus(GL_FRAMEBUFFER) <span style="color:#f92672">==</span> GL_FRAMEBUFFER_COMPLETE)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// execute victory dance
</span></span></span></code></pre></div><p>Toutes les opérations de rendu ultérieures seront désormais effectuées sur les pièces jointes du framebuffer actuellement lié. Comme notre framebuffer n&rsquo;est pas le framebuffer par défaut, les commandes de rendu n&rsquo;auront aucun impact sur la sortie visuelle de votre fenêtre. <strong>C&rsquo;est pour cette raison que l&rsquo;on parle de rendu hors écran lorsque le rendu est effectué vers un framebuffer différent</strong>. <strong>Si vous voulez que toutes les opérations de rendu aient à nouveau un impact visuel sur la fenêtre principale, nous devons rendre le framebuffer par défaut actif en le liant à 0 :</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, <span style="color:#ae81ff">0</span>);   
</span></span></code></pre></div><p>Lorsque nous avons terminé toutes les opérations sur le framebuffer, n&rsquo;oubliez pas de supprimer l&rsquo;objet framebuffer :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glDeleteFramebuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>fbo);  
</span></span></code></pre></div><p>Avant d&rsquo;exécuter le contrôle de complétude, nous devons attacher une ou plusieurs pièces jointes au framebuffer. Un attachement est un emplacement de mémoire qui peut agir comme un tampon pour le framebuffer, pensez-y comme une image. Lors de la création d&rsquo;un attachement, deux options s&rsquo;offrent à nous : les textures ou les objets du tampon de rendu.</p>
<h2 id="texture-attachments">Texture attachments</h2>
<p>Lorsqu&rsquo;on attache une texture à un framebuffer, toutes les commandes de rendu écrivent dans la texture comme s&rsquo;il s&rsquo;agissait d&rsquo;un tampon couleur/profondeur normal ou d&rsquo;un tampon stencil. L&rsquo;avantage d&rsquo;utiliser des textures est que la sortie du rendu est stockée dans l&rsquo;image de la texture que nous pouvons ensuite facilement utiliser dans nos shaders.</p>
<p>La création d&rsquo;une texture pour un framebuffer est à peu près la même que la création d&rsquo;une texture normale :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> texture;
</span></span><span style="display:flex;"><span>glGenTextures(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>texture);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, texture);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>glTexImage2D(GL_TEXTURE_2D, <span style="color:#ae81ff">0</span>, GL_RGB, <span style="color:#ae81ff">800</span>, <span style="color:#ae81ff">600</span>, <span style="color:#ae81ff">0</span>, GL_RGB, GL_UNSIGNED_BYTE, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);  
</span></span></code></pre></div><p><strong>Les principales différences sont que les dimensions sont égales à la taille de l&rsquo;écran (bien que cela ne soit pas nécessaire) et que le paramètre de données de la texture est NULL.</strong> Pour cette texture, nous ne faisons qu&rsquo;allouer de la mémoire et nous ne la remplissons pas. Le remplissage de la texture se fera dès que nous effectuerons le rendu dans le framebuffer. Notez également que nous ne nous soucions pas des méthodes de wrapping ou de mipmapping puisque nous n&rsquo;en aurons pas besoin dans la plupart des cas.</p>
<blockquote>
<p>Si vous voulez rendre tout votre écran dans une texture de taille plus petite ou plus grande, vous devez appeler à nouveau <code>glViewport</code> (avant d&rsquo;effectuer le rendu dans votre framebuffer) avec les nouvelles dimensions de votre texture, sinon les commandes de rendu ne rempliront qu&rsquo;une partie de la texture.</p>
</blockquote>
<p>Maintenant que nous avons créé une texture, la dernière chose à faire est de l&rsquo;attacher au framebuffer :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span style="color:#ae81ff">0</span>);  
</span></span></code></pre></div><p>La fonction <code>glFrameBufferTexture2D</code> a les paramètres suivants :</p>
<ul>
<li><code>target</code> : le type de framebuffer que nous visons (draw, read ou les deux).</li>
<li><code>attachment</code> : le type d&rsquo;attachement que nous allons attacher. Pour l&rsquo;instant, nous attachons un attachement de couleur. Notez que <strong>le <code>0</code> à la fin suggère que nous pouvons attacher plus d&rsquo;un attachement de couleur. Nous y reviendrons dans un chapitre ultérieur.</strong></li>
<li><code>textarget</code> : le type de texture que vous voulez attacher.</li>
<li><code>texture</code> : la texture à attacher.</li>
<li><code>level</code> : le niveau de la mipmap. Nous le gardons à <code>0</code>.</li>
</ul>
<p>Outre les attachements de couleur, nous pouvons également attacher une profondeur et une texture de stencil à l&rsquo;objet framebuffer. Pour attacher une texture de profondeur, nous spécifions le type d&rsquo;attachement comme <code>GL_DEPTH_ATTACHMENT</code>. Notez que le format de la texture et le type de format interne doivent alors devenir <code>GL_DEPTH_COMPONENT</code> pour refléter le format de stockage du tampon de profondeur. Pour attacher un tampon de stencil, utilisez <code>GL_STENCIL_ATTACHMENT</code> comme second argument et spécifiez les formats de la texture comme <code>GL_STENCIL_INDEX</code>.</p>
<p>Il est également possible d&rsquo;attacher à la fois un tampon de profondeur et un tampon de stencil en tant que texture unique. Chaque valeur de 32 bits de la texture contient alors 24 bits d&rsquo;informations sur la profondeur et 8 bits d&rsquo;informations sur le stencil. Pour attacher un tampon de profondeur et un tampon de stencil en tant que texture unique, nous utilisons le type <code>GL_DEPTH_STENCIL_ATTACHMENT</code> et configurons les formats de la texture pour qu&rsquo;ils contiennent des valeurs combinées de profondeur et de stencil. Un exemple d&rsquo;attachement d&rsquo;un tampon de profondeur et de stencil en tant que texture au framebuffer est donné ci-dessous :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glTexImage2D(
</span></span><span style="display:flex;"><span>  GL_TEXTURE_2D, <span style="color:#ae81ff">0</span>, GL_DEPTH24_STENCIL8, <span style="color:#ae81ff">800</span>, <span style="color:#ae81ff">600</span>, <span style="color:#ae81ff">0</span>, 
</span></span><span style="display:flex;"><span>  GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><h2 id="renderbuffer-object-attachments">Renderbuffer object attachments</h2>
<p>Les objets renderbuffer ont été introduits dans OpenGL après les textures comme un type possible d&rsquo;attachement au framebuffer. <strong>Tout comme une image de texture, un objet renderbuffer est un tampon réel, par exemple un tableau d&rsquo;octets, d&rsquo;entiers, de pixels ou autre.</strong> Cependant, il n&rsquo;est pas possible de lire directement un objet renderbuffer. Cela lui confère l&rsquo;avantage supplémentaire qu&rsquo;OpenGL peut effectuer quelques optimisations de mémoire qui peuvent lui donner un avantage de performance par rapport aux textures pour le rendu hors écran vers un framebuffer.</p>
<p>Les objets <code>Renderbuffer</code> stockent toutes les données de rendu directement dans leur tampon sans aucune conversion vers des formats spécifiques aux textures, ce qui les rend plus rapides en tant que support de stockage inscriptible. Il n&rsquo;est pas possible de les lire directement, mais il est possible de les lire via la fonction lente <code>glReadPixels</code>. <strong>Cette fonction renvoie une zone spécifiée de pixels à partir du framebuffer actuellement lié, mais pas directement à partir de l&rsquo;attachement lui-même.</strong></p>
<p>Comme leurs données sont dans un format natif, ils sont assez rapides lorsqu&rsquo;il s&rsquo;agit d&rsquo;écrire des données ou de les copier dans d&rsquo;autres tampons. Les opérations telles que le changement de tampon sont donc très rapides lors de l&rsquo;utilisation d&rsquo;objets renderbuffer. <strong>La fonction <code>glfwSwapBuffers</code> que nous avons utilisée à la fin de chaque image peut tout aussi bien être implémentée avec des objets renderbuffer</strong> : nous écrivons simplement dans une image renderbuffer, et nous passons à l&rsquo;autre à la fin. Les objets renderbuffer sont parfaits pour ce genre d&rsquo;opérations.</p>
<p>La création d&rsquo;un objet renderbuffer ressemble au code du framebuffer :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> rbo;
</span></span><span style="display:flex;"><span>glGenRenderbuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>rbo);
</span></span></code></pre></div><p>De même, nous voulons lier l&rsquo;objet renderbuffer pour que toutes les opérations ultérieures sur le renderbuffer affectent le <code>rbo</code> actuel :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glBindRenderbuffer(GL_RENDERBUFFER, rbo);  
</span></span></code></pre></div><p>Comme les objets renderbuffer sont en écriture seule, ils sont souvent utilisés comme attachements pour la profondeur et le stencil, car la plupart du temps, nous n&rsquo;avons pas vraiment besoin de lire les valeurs qu&rsquo;ils contiennent, mais nous nous intéressons aux tests de profondeur et de stencil. Nous avons besoin des valeurs de profondeur et de stencil pour les tests, mais nous n&rsquo;avons pas besoin d&rsquo;échantillonner ces valeurs, donc un objet renderbuffer convient parfaitement. Lorsque nous n&rsquo;échantillonnons pas à partir de ces tampons, un objet renderbuffer est généralement préféré.</p>
<p>La création d&rsquo;un objet de tampon de rendu de profondeur et de stencil se fait en appelant la fonction <code>glRenderbufferStorage</code> :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, <span style="color:#ae81ff">800</span>, <span style="color:#ae81ff">600</span>);
</span></span></code></pre></div><p>La création d&rsquo;un objet renderbuffer est similaire à celle d&rsquo;un objet texture, à la différence que cet objet est spécifiquement conçu pour être utilisé en tant qu&rsquo;attachement à un framebuffer, au lieu d&rsquo;un tampon de données à usage général comme une texture. Ici, nous avons choisi <code>GL_DEPTH24_STENCIL8</code> comme format interne, qui contient à la fois la profondeur et le tampon de stencil avec 24 et 8 bits respectivement.</p>
<p>La dernière chose à faire est d&rsquo;attacher l&rsquo;objet renderbuffer :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);  
</span></span></code></pre></div><p>Les objets renderbuffer peuvent être plus efficaces dans vos projets de rendu hors écran, mais il est important de savoir quand utiliser les objets renderbuffer et quand utiliser les textures. En règle générale, si vous n&rsquo;avez jamais besoin d&rsquo;échantillonner des données à partir d&rsquo;un tampon spécifique, il est judicieux d&rsquo;utiliser un objet renderbuffer pour ce tampon spécifique. Si vous avez besoin d&rsquo;échantillonner des données à partir d&rsquo;un tampon spécifique, comme des couleurs ou des valeurs de profondeur, vous devriez plutôt utiliser un attachement de texture.</p>
<h2 id="rendre-une-texture">Rendre une texture</h2>
<p>Maintenant que nous savons comment fonctionnent les framebuffers (en quelque sorte), il est temps de les utiliser à bon escient. Nous allons rendre la scène dans une texture de couleur attachée à un objet framebuffer que nous avons créé, puis dessiner cette texture sur un simple quad qui s&rsquo;étend sur tout l&rsquo;écran. La sortie visuelle est alors exactement la même que sans framebuffer, mais cette fois-ci, tout est imprimé sur un seul quad. Pourquoi est-ce utile ? Nous le verrons dans la section suivante.</p>
<p>La première chose à faire est de créer un objet framebuffer et de le lier, ce qui est relativement simple :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> framebuffer;
</span></span><span style="display:flex;"><span>glGenFramebuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>framebuffer);
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);    
</span></span></code></pre></div><p>Ensuite, nous créons une image de texture que nous attachons au framebuffer en tant qu&rsquo;attachement de couleur. Les dimensions de la texture sont égales à la largeur et à la hauteur de la fenêtre et ses données ne sont pas initialisées :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// generate texture
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> textureColorbuffer;
</span></span><span style="display:flex;"><span>glGenTextures(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>textureColorbuffer);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, textureColorbuffer);
</span></span><span style="display:flex;"><span>glTexImage2D(GL_TEXTURE_2D, <span style="color:#ae81ff">0</span>, GL_RGB, <span style="color:#ae81ff">800</span>, <span style="color:#ae81ff">600</span>, <span style="color:#ae81ff">0</span>, GL_RGB, GL_UNSIGNED_BYTE, NULL);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// attach it to currently bound framebuffer object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureColorbuffer, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>Nous voulons aussi nous assurer qu&rsquo;OpenGL est capable de faire des tests de profondeur (et optionnellement des tests de stencils) donc nous devons nous assurer d&rsquo;ajouter un attachement de profondeur (et de stencil) au framebuffer. Puisque nous n&rsquo;échantillonnerons que le tampon de couleur et pas les autres tampons, nous pouvons créer un objet renderbuffer dans ce but.</p>
<p>La création d&rsquo;un objet renderbuffer n&rsquo;est pas trop difficile. La seule chose dont nous devons nous souvenir est que nous le créons en tant qu&rsquo;objet de rendu avec attachement de profondeur et de stencil. Nous définissons son format interne à <code>GL_DEPTH24_STENCIL8</code>, ce qui est suffisamment précis pour nos besoins :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> rbo;
</span></span><span style="display:flex;"><span>glGenRenderbuffers(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>rbo);
</span></span><span style="display:flex;"><span>glBindRenderbuffer(GL_RENDERBUFFER, rbo); 
</span></span><span style="display:flex;"><span>glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, <span style="color:#ae81ff">800</span>, <span style="color:#ae81ff">600</span>);  
</span></span><span style="display:flex;"><span>glBindRenderbuffer(GL_RENDERBUFFER, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>Une fois que nous avons alloué suffisamment de mémoire à l&rsquo;objet renderbuffer, nous pouvons le délier.</p>
<p>Ensuite, comme dernière étape avant de terminer le framebuffer, nous attachons l&rsquo;objet renderbuffer à l&rsquo;attachement de profondeur et de stencil du framebuffer :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);
</span></span></code></pre></div><p>Ensuite, nous voulons vérifier si le framebuffer est complet et si ce n&rsquo;est pas le cas, nous affichons un message d&rsquo;erreur.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(glCheckFramebufferStatus(GL_FRAMEBUFFER) <span style="color:#f92672">!=</span> GL_FRAMEBUFFER_COMPLETE)
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ERROR::FRAMEBUFFER:: Framebuffer is not complete!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>glBindFramebuffer(GL_FRAMEBUFFER, <span style="color:#ae81ff">0</span>);  
</span></span></code></pre></div><p>Veillez à délier le framebuffer pour vous assurer que nous ne rendons pas accidentellement vers le mauvais framebuffer.</p>
<p>Maintenant que le framebuffer est complet, tout ce que nous avons à faire pour effectuer le rendu dans les tampons du framebuffer au lieu des tampons par défaut est simplement de lier l&rsquo;objet framebuffer. Toutes les commandes de rendu suivantes influenceront alors le framebuffer actuellement lié. Toutes les opérations de profondeur et de stencil liront également les attachements de profondeur et de stencil du framebuffer actuellement lié, s&rsquo;ils sont disponibles. Si vous deviez omettre un tampon de profondeur par exemple, toutes les opérations de test de profondeur ne fonctionneraient plus.</p>
<p>Ainsi, pour dessiner la scène sur une seule texture, nous devrons suivre les étapes suivantes :</p>
<ol>
<li>Rendu de la scène comme d&rsquo;habitude avec le nouveau framebuffer lié comme framebuffer actif.</li>
<li>Lier au framebuffer par défaut.</li>
<li>Dessinez un quad qui s&rsquo;étend sur tout l&rsquo;écran avec le tampon de couleur du nouveau framebuffer comme texture.</li>
</ol>
<p>Nous allons effectuer le rendu de la même scène que nous avons utilisée dans le chapitre <a href="/docs/learnopengl_fr/04_advanced_opengl/00_depth_testing/">depth testing</a>, mais cette fois-ci avec la texture <a href="https://learnopengl.com/img/textures/container.jpg">container</a> de la vieille école.</p>
<p>Pour effectuer le rendu du quad, nous allons créer un nouvel ensemble de shaders simples. Nous n&rsquo;allons pas inclure de transformations matricielles fantaisistes puisque nous fournirons les coordonnées des sommets en tant que coordonnées normalisées du device afin de pouvoir les transmettre directement en sortie du shader de sommets. Le vertex shader ressemble à ceci :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) in vec2 aPos;
</span></span><span style="display:flex;"><span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) in vec2 aTexCoords;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out vec2 TexCoords;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    gl_Position <span style="color:#f92672">=</span> vec4(aPos.x, aPos.y, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>); 
</span></span><span style="display:flex;"><span>    TexCoords <span style="color:#f92672">=</span> aTexCoords;
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Rien de bien compliqué. Le fragment shader est encore plus basique puisque la seule chose que nous avons à faire est d&rsquo;échantillonner une texture :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>out vec4 FragColor;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>in vec2 TexCoords;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uniform sampler2D screenTexture;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> texture(screenTexture, TexCoords);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Il vous appartient ensuite de créer et de configurer un VAO pour le quad de l&rsquo;écran. Une seule itération de rendu de la procédure framebuffer a la structure suivante :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// first pass
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
</span></span><span style="display:flex;"><span>glClearColor(<span style="color:#ae81ff">0.1f</span>, <span style="color:#ae81ff">0.1f</span>, <span style="color:#ae81ff">0.1f</span>, <span style="color:#ae81ff">1.0f</span>);
</span></span><span style="display:flex;"><span>glClear(GL_COLOR_BUFFER_BIT <span style="color:#f92672">|</span> GL_DEPTH_BUFFER_BIT); <span style="color:#75715e">// we&#39;re not using the stencil buffer now
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glEnable(GL_DEPTH_TEST);
</span></span><span style="display:flex;"><span>DrawScene();	
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// second pass
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glBindFramebuffer(GL_FRAMEBUFFER, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// back to default
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glClearColor(<span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>); 
</span></span><span style="display:flex;"><span>glClear(GL_COLOR_BUFFER_BIT);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>screenShader.use();  
</span></span><span style="display:flex;"><span>glBindVertexArray(quadVAO);
</span></span><span style="display:flex;"><span>glDisable(GL_DEPTH_TEST);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, textureColorbuffer);
</span></span><span style="display:flex;"><span>glDrawArrays(GL_TRIANGLES, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>);  
</span></span></code></pre></div><p>Il y a quelques points à noter.
Tout d&rsquo;abord, puisque chaque framebuffer que nous utilisons a son propre ensemble de tampons, nous voulons effacer chacun de ces tampons avec les bits appropriés en appelant <code>glClear</code>.
Deuxièmement, lorsque nous dessinons le quad, nous désactivons le test de profondeur car nous voulons nous assurer que le quad s&rsquo;affiche toujours devant tout le reste ; nous devrons réactiver le test de profondeur lorsque nous dessinerons la scène normale.</p>
<p>Il y a pas mal d&rsquo;étapes qui peuvent mal se passer ici, donc si vous n&rsquo;avez pas de résultat, essayez de déboguer là où c&rsquo;est possible et relisez les sections pertinentes du chapitre. Si tout s&rsquo;est déroulé correctement, vous obtiendrez un résultat visuel qui ressemble à ceci :</p>
<p><img src="/docs%5cLEARNOPENGL_FR%5c04_Advanced_OpenGL%5cframebuffers_screen_texture-1.png" alt="framebuffers_screen_texture-1"/>
La partie gauche montre le résultat visuel, exactement le même que nous avons vu dans le chapitre sur les tests de profondeur, mais cette fois rendu sur un simple quad. Si nous rendons la scène en wireframe, il est évident que nous n&rsquo;avons dessiné qu&rsquo;un seul quad dans le framebuffer par défaut.</p>
<p>Vous pouvez trouver le code source de l&rsquo;application <a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/5.1.framebuffers/framebuffers.cpp">ici</a>.</p>
<p>Alors, à quoi cela sert-il encore ? Eh bien, parce que nous pouvons maintenant accéder librement à chacun des pixels de la scène entièrement rendue comme une seule image de texture, nous pouvons créer quelques effets intéressants dans le fragment shader.</p>
<h2 id="post-processing">Post-processing</h2>
<p><strong>Maintenant que la scène entière est rendue dans une texture unique, nous pouvons créer des effets de post-traitement intéressants en manipulant la texture de la scène</strong>. Dans cette section, nous allons vous présenter quelques-uns des effets de post-traitement les plus populaires et vous montrer comment vous pouvez créer les vôtres avec un peu plus de créativité.</p>
<p>Commençons par l&rsquo;un des effets de post-traitement les plus simples.</p>
<h3 id="inversion">Inversion</h3>
<p>Nous avons accès à chacune des couleurs de la sortie du rendu, il n&rsquo;est donc pas difficile de retourner l&rsquo;inverse de ces couleurs dans le fragment shader. Nous pouvons prendre la couleur de la texture de l&rsquo;écran et l&rsquo;inverser en la soustrayant de 1.0 :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> vec4(vec3(<span style="color:#ae81ff">1.0</span> <span style="color:#f92672">-</span> texture(screenTexture, TexCoords)), <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Bien que l&rsquo;inversion soit un effet de post-traitement relativement simple, elle permet déjà d&rsquo;obtenir des résultats étonnants :</p>
<p><img src="/docs%5cLEARNOPENGL_FR%5c04_Advanced_OpenGL%5cframebuffers_inverse%201.png" alt="framebuffers_inverse 1"/>
La scène entière a maintenant toutes ses couleurs inversées avec une seule ligne de code dans le fragment shader. Plutôt cool, non ?</p>
<h3 id="niveaux-de-gris-grayscale">Niveaux de gris (grayscale)</h3>
<p>Un autre effet intéressant consiste à supprimer toutes les couleurs de la scène à l&rsquo;exception du blanc, du gris et du noir. Pour ce faire, il suffit de prendre toutes les composantes de couleur et de calculer la moyenne de leurs résultats :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> texture(screenTexture, TexCoords);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> average <span style="color:#f92672">=</span> (FragColor.r <span style="color:#f92672">+</span> FragColor.g <span style="color:#f92672">+</span> FragColor.b) <span style="color:#f92672">/</span> <span style="color:#ae81ff">3.0</span>;
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> vec4(average, average, average, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}   
</span></span></code></pre></div><p>Cela donne déjà d&rsquo;assez bons résultats, mais l&rsquo;œil humain a tendance à être plus sensible aux couleurs vertes et moins aux bleues. Pour obtenir les résultats les plus précis sur le plan physique, nous devons donc utiliser des canaux pondérés :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> texture(screenTexture, TexCoords);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> average <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.2126</span> <span style="color:#f92672">*</span> FragColor.r <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.7152</span> <span style="color:#f92672">*</span> FragColor.g <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.0722</span> <span style="color:#f92672">*</span> FragColor.b;
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> vec4(average, average, average, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p><img src="/docs%5cLEARNOPENGL_FR%5c04_Advanced_OpenGL%5cframebuffers_grayscale%201.png" alt="framebuffers_grayscale 1"/>
Vous ne remarquerez probablement pas la différence tout de suite, mais avec des scènes plus complexes, un tel effet d&rsquo;échelle de gris pondérée tend à être plus réaliste.</p>
<h3 id="effets-kernel">Effets Kernel</h3>
<p>Un autre avantage du post-traitement sur une seule image de texture est qu&rsquo;il est possible d&rsquo;échantillonner des valeurs de couleur à partir d&rsquo;autres parties de la texture qui ne sont pas spécifiques à ce fragment. Nous pouvons par exemple prendre une petite zone autour de la coordonnée de texture actuelle et échantillonner plusieurs valeurs de texture autour de la valeur de texture actuelle. Nous pouvons ensuite créer des effets intéressants en les combinant de manière créative.</p>
<p>Un kernel (ou matrice de convolution) est un petit tableau matriciel de valeurs centrées sur le pixel courant qui multiplie les valeurs des pixels environnants par ses valeurs de kernel et les additionne pour former une valeur unique. Nous ajoutons un petit décalage aux coordonnées de la texture dans les directions environnantes du pixel actuel et nous combinons les résultats en fonction du kernel. Un exemple de kernel est donné ci-dessous :
$$
\begin{bmatrix}
2 &amp; 2 &amp; 2 \
2 &amp; -15 &amp; 2 \
2 &amp; 2 &amp; 2 \
\end{bmatrix}
$$
Ce kernel prend 8 valeurs de pixels environnants et les multiplie par 2 et le pixel actuel par -15. Cet exemple de kernel multiplie les pixels environnants par plusieurs poids déterminés dans le kernel et équilibre le résultat en multipliant le pixel actuel par un poids négatif important.</p>
<p><strong>La plupart des kernels que vous trouverez sur Internet sont tous égaux à 1 si vous additionnez tous les poids. Si la somme n&rsquo;est pas égale à 1, cela signifie que la couleur de la texture résultante est plus claire ou plus foncée que la valeur de la texture d&rsquo;origine</strong>.</p>
<p>Les kernels sont un outil extrêmement utile pour le post-traitement car ils sont assez faciles à utiliser et à expérimenter, et de nombreux exemples peuvent être trouvés en ligne. Nous devons légèrement adapter le fragment shader pour qu&rsquo;il prenne en charge les kernels. Nous supposons que chaque kernel que nous utiliserons est un kernel 3x3 (ce qui est le cas de la plupart des kernels) :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">float</span> offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">300.0</span>;  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vec2 offsets[<span style="color:#ae81ff">9</span>] <span style="color:#f92672">=</span> vec2[](
</span></span><span style="display:flex;"><span>        vec2(<span style="color:#f92672">-</span>offset,  offset), <span style="color:#75715e">// top-left
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vec2( <span style="color:#ae81ff">0.0f</span>,    offset), <span style="color:#75715e">// top-center
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vec2( offset,  offset), <span style="color:#75715e">// top-right
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vec2(<span style="color:#f92672">-</span>offset,  <span style="color:#ae81ff">0.0f</span>),   <span style="color:#75715e">// center-left
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vec2( <span style="color:#ae81ff">0.0f</span>,    <span style="color:#ae81ff">0.0f</span>),   <span style="color:#75715e">// center-center
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vec2( offset,  <span style="color:#ae81ff">0.0f</span>),   <span style="color:#75715e">// center-right
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vec2(<span style="color:#f92672">-</span>offset, <span style="color:#f92672">-</span>offset), <span style="color:#75715e">// bottom-left
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vec2( <span style="color:#ae81ff">0.0f</span>,   <span style="color:#f92672">-</span>offset), <span style="color:#75715e">// bottom-center
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        vec2( offset, <span style="color:#f92672">-</span>offset)  <span style="color:#75715e">// bottom-right    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> kernel[<span style="color:#ae81ff">9</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">float</span>[](
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">9</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vec3 sampleTex[<span style="color:#ae81ff">9</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        sampleTex[i] <span style="color:#f92672">=</span> vec3(texture(screenTexture, TexCoords.st <span style="color:#f92672">+</span> offsets[i]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    vec3 col <span style="color:#f92672">=</span> vec3(<span style="color:#ae81ff">0.0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">9</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        col <span style="color:#f92672">+=</span> sampleTex[i] <span style="color:#f92672">*</span> kernel[i];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> vec4(col, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Dans le fragment shader, nous créons d&rsquo;abord un tableau de 9 décalages <code>vec2</code> pour chaque coordonnée de texture environnante. Le décalage est une valeur constante que vous pouvez personnaliser à votre guise. Ensuite, nous définissons le kernel, qui dans ce cas est un kernel d&rsquo;accentuation qui accentue chaque valeur de couleur en échantillonnant tous les pixels environnants d&rsquo;une manière intéressante. Enfin, nous ajoutons chaque décalage à la coordonnée de texture actuelle lors de l&rsquo;échantillonnage et nous multiplions ces valeurs de texture avec les valeurs pondérées du kernel que nous additionnons.</p>
<p>Ce kernel de netteté particulier se présente comme suit :</p>
<p><img src="/docs%5cLEARNOPENGL_FR%5c04_Advanced_OpenGL%5cframebuffers_sharpen%201.png" alt="framebuffers_sharpen 1"/>
Cela peut être à la base d&rsquo;effets intéressants lorsque votre joueur se lance dans une aventure narcotique.</p>
<h3 id="blur-flou">Blur (flou)</h3>
<p>Un kernel qui crée un effet de flou est défini comme suit :
$$
\begin{bmatrix}
1 &amp; 2 &amp; 1 \
2 &amp; 4 &amp; 2 \
1 &amp; 2 &amp; 1 \
\end{bmatrix}
/
16
$$
Comme toutes les valeurs sont égales à 16, le fait de renvoyer directement les couleurs échantillonnées combinées donnerait une couleur extrêmement brillante. Nous devons donc diviser chaque valeur du kernel par 16. Le tableau de kernel résultant devient alors :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> kernel[<span style="color:#ae81ff">9</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">float</span>[](
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">4.0</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">16</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">2.0</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">1.0</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">16</span>  
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>En modifiant uniquement le tableau de kernel dans le shader de fragment, nous pouvons changer complètement l&rsquo;effet de post-traitement. Il ressemble maintenant à ceci :</p>
<p><img src="/docs%5cLEARNOPENGL_FR%5c04_Advanced_OpenGL%5cframebuffers_blur%201.png" alt="framebuffers_blur 1"/></p>
<p>Un tel effet de flou offre des possibilités intéressantes. Nous pourrions faire varier la quantité de flou dans le temps pour créer l&rsquo;effet d&rsquo;une personne ivre, ou augmenter le flou lorsque le personnage principal ne porte pas de lunettes. Le flou peut également être un outil utile pour lisser les valeurs de couleur, ce que nous verrons dans les chapitres suivants.</p>
<p>Vous pouvez constater qu&rsquo;une fois que nous avons mis en place un petit kernel, il est assez facile de créer des effets de post-traitement intéressants. Nous allons vous montrer un dernier effet populaire pour terminer cette discussion.</p>
<h3 id="edge-detection-détection-des-contours">Edge detection (détection des contours)</h3>
<p>Vous trouverez ci-dessous un kernel de détection des contours qui est similaire au kernel d&rsquo;affinage (sharpen kernel):</p>
<p>$$
\begin{bmatrix}
1 &amp; 1 &amp; 1 \
1 &amp; -8 &amp; 1 \
1 &amp; 1 &amp; 1 \
\end{bmatrix}</p>
<p>$$</p>
<p>Ce kernel met en évidence tous les contours et assombrit le reste, ce qui est très utile lorsque l&rsquo;on ne s&rsquo;intéresse qu&rsquo;aux contours d&rsquo;une image.</p>
<p>Il n&rsquo;est probablement pas surprenant que des kernels de ce type soient utilisés comme outils/filtres de manipulation d&rsquo;images dans des outils tels que Photoshop. <strong>Grâce à la capacité d&rsquo;une carte graphique à traiter des fragments avec des capacités parallèles extrêmes, nous pouvons manipuler des images par pixel en temps réel avec une relative facilité. Les outils d&rsquo;édition d&rsquo;images ont donc tendance à utiliser des cartes graphiques pour le traitement des images.</strong></p>



      </main>
    </div>
    
<script src="/js/feather.min.js"></script>
<script>
  feather.replace();
</script>
  </body>
</html>